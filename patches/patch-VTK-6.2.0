diff -urBN VTK-6.2.0-org/CMake/vtkModuleMacros.cmake VTK-6.2.0/CMake/vtkModuleMacros.cmake
--- VTK-6.2.0-org/CMake/vtkModuleMacros.cmake	2016-01-27 13:18:50.195682896 +0100
+++ VTK-6.2.0/CMake/vtkModuleMacros.cmake	2016-01-27 13:23:57.861290268 +0100
@@ -293,7 +293,7 @@
       DESTINATION ${VTK_INSTALL_PACKAGE_DIR}/Modules
       COMPONENT Development)
     if(NOT ${vtk-module}_EXCLUDE_FROM_WRAPPING)
-      if(VTK_WRAP_PYTHON OR VTK_WRAP_TCL OR VTK_WRAP_JAVA)
+      if(VTK_WRAP_PYTHON OR VTK_WRAP_TCL OR VTK_WRAP_JAVA OR VTK_WRAP_NODEJS)
         install(FILES ${${vtk-module}_WRAP_HIERARCHY_FILE}
           DESTINATION ${VTK_INSTALL_PACKAGE_DIR}/Modules
           COMPONENT Development)
@@ -590,7 +590,7 @@
   # TODO: Re-order things so we do not need to duplicate this condition.
   if(NOT ${vtk-module}_EXCLUDE_FROM_WRAPPING AND
       NOT ${vtk-module}_EXCLUDE_FROM_WRAP_HIERARCHY AND
-      ( VTK_WRAP_PYTHON OR VTK_WRAP_TCL OR VTK_WRAP_JAVA ))
+      ( VTK_WRAP_PYTHON OR VTK_WRAP_TCL OR VTK_WRAP_JAVA OR VTK_WRAP_NODEJS ))
     set(_hierarchy ${CMAKE_CURRENT_BINARY_DIR}/${vtk-module}Hierarchy.stamp.txt)
   else()
     set(_hierarchy "")
diff -urBN VTK-6.2.0-org/CMake/vtkNodeJsWrapping.cmake VTK-6.2.0/CMake/vtkNodeJsWrapping.cmake
--- VTK-6.2.0-org/CMake/vtkNodeJsWrapping.cmake	1970-01-01 01:00:00.000000000 +0100
+++ VTK-6.2.0/CMake/vtkNodeJsWrapping.cmake	2016-01-27 13:23:57.861290268 +0100
@@ -0,0 +1,32 @@
+include(vtkWrapNodeJs)
+
+function(vtk_add_nodejs_wrapping module_name)
+  if(NOT VTK_WRAP_NODEJS_INIT_EXE)
+    if(TARGET vtkWrapNodeJsInit)
+      set (VTK_WRAP_NODEJS_INIT_EXE vtkWrapNodeJsInit)
+    else()
+      message(FATAL_ERROR "VTK must be built with Node.js wrapping turned on.")
+    endif()
+  endif()
+
+  if(NOT ${module_name}_EXCLUDE_FROM_WRAP_HIERARCHY)
+    set(KIT_HIERARCHY_FILE ${${module_name}_WRAP_HIERARCHY_FILE})
+  endif()
+
+  string(REGEX REPLACE "^vtk" "" kit_name "${module_name}")
+  set(KIT ${kit_name})
+
+  # Figure out the dependent libraries for the module
+  unset(extra_links)
+  set(EXTRA_NODEJS_INCLUDE_DIRS ${${module_name}_NODEJS_INCLUDE_DIRS})
+
+  if(${module_name}_WRAP_HINTS AND EXISTS "${${module_name}_WRAP_HINTS}")
+    set(VTK_WRAP_HINTS "${${module_name}_WRAP_HINTS}")
+  endif()
+
+  vtk_wrap_nodejs(${module_name}NodeJs NodeJs_SRCS ${module_name} )
+
+  add_custom_target( ${module_name}NodeJsD ALL DEPENDS ${NodeJs_SRCS})
+
+endfunction()
+
diff -urBN VTK-6.2.0-org/CMake/vtkWrapNodeJs.cmake VTK-6.2.0/CMake/vtkWrapNodeJs.cmake
--- VTK-6.2.0-org/CMake/vtkWrapNodeJs.cmake	1970-01-01 01:00:00.000000000 +0100
+++ VTK-6.2.0/CMake/vtkWrapNodeJs.cmake	2016-01-27 13:23:57.861290268 +0100
@@ -0,0 +1,146 @@
+#
+# CMake implementation of the Wrap NodeJs command.
+#
+file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/NodeJs)
+
+# Determine the location of the supplied header in the include_dirs supplied.
+macro(vtk_find_header header include_dirs full_path)
+  unset(${full_path})
+  foreach(_dir ${include_dirs})
+    if(EXISTS "${_dir}/${header}")
+      set(${full_path} "${_dir}/${header}")
+      break()
+    endif()
+  endforeach()
+endmacro()
+
+# Macro that just takes the name of the module, figure the rest out from there.
+macro(vtk_wrap_nodejs TARGET SRC_LIST_NAME module)
+  if(NOT VTK_WRAP_NODEJS_INIT_EXE)
+    if(TARGET vtkWrapNodeJsInit)
+      set(VTK_WRAP_NODEJS_INIT_EXE vtkWrapNodeJsInit)
+    else()
+      message(SEND_ERROR
+        "VTK_WRAP_NODEJS_INIT_EXE not specified when calling vtk_wrap_nodejs")
+    endif()
+  endif()
+  if(NOT VTK_WRAP_NODEJS_EXE)
+    if(TARGET vtkWrapNodeJs)
+      set(VTK_WRAP_NODEJS_EXE vtkWrapNodeJs)
+    else()
+      message(SEND_ERROR
+        "VTK_WRAP_NODEJS_EXE not specified when calling vtk_wrap_nodejs")
+    endif()
+  endif()
+
+  # The shell into which nmake.exe executes the custom command has some issues
+  # with mixing quoted and unquoted arguments :( Let's help.
+  if(CMAKE_GENERATOR MATCHES "NMake Makefiles")
+    set(verbatim "")
+    set(quote "\"")
+  else()
+    set(verbatim "VERBATIM")
+    set(quote "")
+  endif()
+
+  # start writing the input file for the init file
+  set(VTK_WRAPPER_INIT_DATA "${TARGET}")
+
+  # all the include directories
+  if(${module}_INCLUDE_DIRS)
+    set(TMP_INCLUDE_DIRS ${${module}_INCLUDE_DIRS})
+  elseif(VTK_WRAP_INCLUDE_DIRS)
+    set(TMP_INCLUDE_DIRS ${VTK_WRAP_INCLUDE_DIRS})
+  else()
+    set(TMP_INCLUDE_DIRS ${VTK_INCLUDE_DIRS})
+  endif()
+  # all the include directories
+
+  if(EXTRA_NODEJS_INCLUDE_DIRS)
+    list(APPEND TMP_INCLUDE_DIRS ${EXTRA_NODEJS_INCLUDE_DIRS})
+  endif()
+
+  # collect the common wrapper-tool arguments
+  set(_common_args)
+  get_directory_property(_def_list DEFINITION COMPILE_DEFINITIONS)
+  foreach(TMP_DEF ${_def_list})
+    set(_common_args "${_common_args}-D${TMP_DEF}\n")
+  endforeach()
+  foreach(INCLUDE_DIR ${TMP_INCLUDE_DIRS})
+    set(_common_args "${_common_args}-I\"${INCLUDE_DIR}\"\n")
+  endforeach()
+  if(VTK_WRAP_HINTS)
+    set(_common_args "${_common_args}--hints \"${VTK_WRAP_HINTS}\"\n")
+  endif()
+  if(KIT_HIERARCHY_FILE)
+    set(_common_args "${_common_args}--types \"${KIT_HIERARCHY_FILE}\"\n")
+  endif()
+
+  # write wrapper-tool arguments to a file
+  string(STRIP "${_common_args}" CMAKE_CONFIGURABLE_FILE_CONTENT)
+  set(_args_file ${CMAKE_CURRENT_BINARY_DIR}/${TARGET}.args)
+  configure_file(${CMAKE_ROOT}/Modules/CMakeConfigurableFile.in
+                 ${_args_file} @ONLY)
+
+  # Decide what to do for each header.
+  foreach(header ${${module}_HEADERS})
+    # Everything in this block is for headers that will be wrapped.
+    if(${module}_HEADER_${header}_WRAP_SPECIAL OR
+       NOT ${module}_HEADER_${header}_WRAP_EXCLUDE)
+
+      # Find the full path to the header file to be wrapped.
+      vtk_find_header(${header}.h "${${module}_INCLUDE_DIRS}" class_header_path)
+      if(NOT class_header_path)
+        message(FATAL_ERROR "Could not find the ${header} header file.")
+      endif()
+
+      # add the info to the init file
+      set(VTK_WRAPPER_INIT_DATA
+        "${VTK_WRAPPER_INIT_DATA}\n${header}")
+
+      # new source file is nameWrap.c, add to resulting list
+      set(${SRC_LIST_NAME} ${${SRC_LIST_NAME}} ${header}Wrap.cc)
+
+      # add custom command to output
+      add_custom_command(
+        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${header}Wrap.cc
+        DEPENDS ${VTK_WRAP_NODEJS_EXE} ${VTK_WRAP_HINTS} ${class_header_path}
+          ${_args_file} ${KIT_HIERARCHY_FILE}
+        COMMAND ${VTK_WRAP_NODEJS_EXE}
+          ARGS
+          "${quote}@${_args_file}${quote}"
+          "-o" "${quote}${CMAKE_BINARY_DIR}/NodeJs/${header}Wrap.cc${quote}"
+          "${quote}${class_header_path}${quote}"
+        COMMENT "NodeJs Wrapping - generating ${header}Wrap.cc"
+          ${verbatim}
+        )
+    else()
+      message("${header} will not be wrapped.")
+    endif()
+  endforeach()
+
+  # finish the data file for the init file
+  configure_file(
+    ${VTK_CMAKE_DIR}/vtkWrapperInit.data.in
+    ${CMAKE_CURRENT_BINARY_DIR}/${TARGET}Init.data
+    COPY_ONLY
+    )
+ 
+  add_custom_command(
+    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${TARGET}Init.cxx
+    DEPENDS ${VTK_WRAP_NODEJS_INIT_EXE}
+      ${CMAKE_CURRENT_BINARY_DIR}/${TARGET}Init.data
+    COMMAND ${VTK_WRAP_NODEJS_INIT_EXE}
+    ARGS
+	  "${quote}${KIT_HIERARCHY_FILE}${quote}"
+      "${quote}${CMAKE_CURRENT_BINARY_DIR}/${TARGET}Init.data${quote}"
+      "${quote}${CMAKE_BINARY_DIR}/NodeJs/${TARGET}Init.cc${quote}"
+    COMMENT "NodeJs Wrapping - generating ${TARGET}Init.cxx"
+      ${verbatim}
+    )
+
+  # Create the Init File
+  set(${SRC_LIST_NAME} ${${SRC_LIST_NAME}} ${TARGET}Init.cxx)
+
+endmacro()
+
diff -urBN VTK-6.2.0-org/CMake/vtkWrapping.cmake VTK-6.2.0/CMake/vtkWrapping.cmake
--- VTK-6.2.0-org/CMake/vtkWrapping.cmake	2016-01-27 13:18:50.199682813 +0100
+++ VTK-6.2.0/CMake/vtkWrapping.cmake	2016-01-27 13:23:57.861290268 +0100
@@ -6,6 +6,9 @@
 if(VTK_WRAP_PYTHON)
 #  include(vtkPythonWrapping)
 endif()
+if(VTK_WRAP_NODEJS)
+#  include(vtkNodeJsWrapping)
+endif()
 if(VTK_WRAP_TCL)
   include(vtkTclWrapping)
 endif()
@@ -24,7 +27,7 @@
 function(vtk_add_wrapping module_name module_srcs module_hdrs)
   if(NOT ${module_name}_EXCLUDE_FROM_WRAPPING)
     set(_wrap_module FALSE)
-    if(VTK_WRAP_PYTHON OR VTK_WRAP_TCL OR VTK_WRAP_JAVA)
+    if(VTK_WRAP_PYTHON OR VTK_WRAP_TCL OR VTK_WRAP_JAVA OR VTK_WRAP_NODEJS)
       set(_wrap_module TRUE)
     endif()
 
@@ -58,6 +61,9 @@
         # Note that the module should be Python wrapped.
         set_property(GLOBAL APPEND PROPERTY VTK_PYTHON_WRAPPED ${module_name})
       endif()
+      if(VTK_WRAP_NODEJS AND NOT ${module_name}_EXCLUDE_FROM_NODEJS_WRAPPING)
+        set_property(GLOBAL APPEND PROPERTY VTK_NODEJS_WRAPPED ${module_name})
+      endif()
       if(VTK_WRAP_TCL AND NOT ${module_name}_EXCLUDE_FROM_TCL_WRAPPING)
         set_property(GLOBAL APPEND PROPERTY VTK_TCL_WRAPPED ${module_name})
         vtk_add_tcl_wrapping(${module_name} "${module_srcs}" "${module_hdrs}")
diff -urBN VTK-6.2.0-org/CMake/vtkWrapPython.cmake VTK-6.2.0/CMake/vtkWrapPython.cmake
--- VTK-6.2.0-org/CMake/vtkWrapPython.cmake	2016-01-27 13:18:50.199682813 +0100
+++ VTK-6.2.0/CMake/vtkWrapPython.cmake	2016-01-27 13:23:57.865290185 +0100
@@ -113,6 +113,11 @@
           "${quote}@${_args_file}${quote}"
           "-o" "${quote}${CMAKE_CURRENT_BINARY_DIR}/${TMP_FILENAME}Python.cxx${quote}"
           "${quote}${TMP_INPUT}${quote}"
+#        COMMAND ${VTK_WRAP_NODEJS_EXE}
+#          ARGS
+#          "${quote}@${_args_file}${quote}"
+#          "-o" "${quote}${CMAKE_BINARY_DIR}/NodeJs/${TMP_FILENAME}Wrap.cxx${quote}"
+#          "${quote}${TMP_INPUT}${quote}"
         COMMENT "Python Wrapping - generating ${TMP_FILENAME}Python.cxx"
           ${verbatim}
         )
diff -urBN VTK-6.2.0-org/CMakeLists.txt VTK-6.2.0/CMakeLists.txt
--- VTK-6.2.0-org/CMakeLists.txt	2016-01-27 13:18:49.995687051 +0100
+++ VTK-6.2.0/CMakeLists.txt	2016-01-27 13:23:57.865290185 +0100
@@ -426,6 +426,9 @@
 # FIXME: The test should be moved and rewritten.
 include(VTKParallelCMakeTests)
 
+# Add the option for build the NodeJS wrapping to VTK.
+option(VTK_WRAP_NODEJS "Should VTK NodeJS wrapping be built?" ON)
+
 # Add the option for build the Python wrapping to VTK.
 option(VTK_WRAP_PYTHON "Should VTK Python wrapping be built?" OFF)
 set(VTK_PYTHON_VERSION 2 CACHE STRING
@@ -467,6 +470,19 @@
     FORCE)
 endif()
 
+if(VTK_WRAP_NODEJS)
+  set(VTK_WRAP_NODEJS_EXE vtkWrapNodeJs)
+  set(VTK_WRAP_NODEJS_INIT_EXE vtkWrapNodeJsInit)
+  set(VTK_NODEJS_EXE vtknodejs)
+  # Force the WrappingNodeJSCore module to on if wrapping is on
+  set(Module_vtkWrappingNodeJs ON CACHE BOOL "Core Node.js wrapping library"
+    FORCE)
+else()
+  # if wrapping is not on then force WrappingNodeJSCore module to be off
+  set(Module_vtkWrappingNodeJs OFF CACHE BOOL "Core Node.js wrapping library"
+    FORCE)
+endif()
+
 if(VTK_WRAP_JAVA)
   set(VTK_WRAP_JAVA3_INIT_DIR "${VTK_SOURCE_DIR}/Wrapping/Java")
   # Wrapping executables.
@@ -501,7 +517,7 @@
     FORCE)
 endif()
 
-if(VTK_WRAP_PYTHON OR VTK_WRAP_TCL OR VTK_WRAP_JAVA)
+if(VTK_WRAP_PYTHON OR VTK_WRAP_TCL OR VTK_WRAP_JAVA OR VTK_WRAP_NODEJS)
   set(VTK_WRAP_HIERARCHY_EXE vtkWrapHierarchy)
 endif()
 
diff -urBN VTK-6.2.0-org/Wrapping/NodeJs/CMakeLists.txt VTK-6.2.0/Wrapping/NodeJs/CMakeLists.txt
--- VTK-6.2.0-org/Wrapping/NodeJs/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ VTK-6.2.0/Wrapping/NodeJs/CMakeLists.txt	2016-01-27 13:23:57.865290185 +0100
@@ -0,0 +1,33 @@
+# This is where we actually wrap the modules that have requested it.
+include(vtkNodeJsWrapping)
+
+get_property(VTK_NODEJS_MODULES GLOBAL PROPERTY VTK_NODEJS_WRAPPED)
+
+# Get the include directories for the module and all its dependencies.
+macro(vtk_include_recurse module)
+  _vtk_module_config_recurse("${module}_NODEJS" ${module})
+  include_directories(${${module}_NODEJS_INCLUDE_DIRS})
+endmacro()
+
+
+set(VTK_NODEJS_INIT_EXTERNALS)
+set(VTK_NODEJS_INIT_CALLS)
+
+# Loop through all modules that should be wrapped, and wrap them.
+foreach(module ${VTK_NODEJS_MODULES})
+  vtk_module_load(${module})
+  vtk_module_headers_load(${module})
+  vtk_include_recurse(${module})
+  vtk_add_nodejs_wrapping(${module})
+  set(VTK_NODEJS_INIT_EXTERNALS "${VTK_NODEJS_INIT_EXTERNALS}\nextern void ${module}NodeJsInit(v8::Local<v8::Object>);")
+  set(VTK_NODEJS_INIT_CALLS "${VTK_NODEJS_INIT_CALLS}\n\t${module}NodeJsInit(exports);")
+endforeach()
+
+
+
+configure_file(
+  ${CMAKE_CURRENT_SOURCE_DIR}/init.cc.in
+  ${CMAKE_BINARY_DIR}/NodeJs/init.cc
+  COPY_ONLY
+)
+
diff -urBN VTK-6.2.0-org/Wrapping/NodeJs/init.cc.in VTK-6.2.0/Wrapping/NodeJs/init.cc.in
--- VTK-6.2.0-org/Wrapping/NodeJs/init.cc.in	1970-01-01 01:00:00.000000000 +0100
+++ VTK-6.2.0/Wrapping/NodeJs/init.cc.in	2016-01-27 13:23:57.865290185 +0100
@@ -0,0 +1,19 @@
+#include <nan.h>
+
+using namespace v8;
+using v8::Local;
+using v8::Object;
+
+// special object to request nowrap creations
+// not available to javascript.
+Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
+@VTK_NODEJS_INIT_EXTERNALS@
+
+void init( Local<Object> exports )
+{
+	vtkNodeJsNoWrap.Reset( Nan::New<v8::Object>() );
+	@VTK_NODEJS_INIT_CALLS@
+}
+
+NODE_MODULE( addon, init )
+
diff -urBN VTK-6.2.0-org/Wrapping/NodeJs/module.cmake VTK-6.2.0/Wrapping/NodeJs/module.cmake
--- VTK-6.2.0-org/Wrapping/NodeJs/module.cmake	1970-01-01 01:00:00.000000000 +0100
+++ VTK-6.2.0/Wrapping/NodeJs/module.cmake	2016-01-27 13:23:57.865290185 +0100
@@ -0,0 +1,9 @@
+vtk_module(vtkWrappingNodeJs
+  DEPENDS
+    vtkCommonCore
+    vtksys
+  COMPILE_DEPENDS
+    vtkWrappingTools
+  EXCLUDE_FROM_ALL
+  EXCLUDE_FROM_WRAPPING
+  )
diff -urBN VTK-6.2.0-org/Wrapping/Tools/CMakeLists.txt VTK-6.2.0/Wrapping/Tools/CMakeLists.txt
--- VTK-6.2.0-org/Wrapping/Tools/CMakeLists.txt	2016-01-27 13:18:50.935667523 +0100
+++ VTK-6.2.0/Wrapping/Tools/CMakeLists.txt	2016-01-27 13:23:57.865290185 +0100
@@ -87,6 +87,13 @@
   add_executable(vtkWrapPythonInit vtkWrapPythonInit.c)
   vtk_compile_tools_target(vtkWrapPython)
   vtk_compile_tools_target(vtkWrapPythonInit)
+  
+  add_executable(vtkWrapNodeJs vtkWrapNodeJs.c)
+  target_link_libraries(vtkWrapNodeJs vtkWrappingTools)
+  add_executable(vtkWrapNodeJsInit vtkWrapNodeJsInit.c)
+  target_link_libraries(vtkWrapNodeJsInit vtkWrappingTools)
+  vtk_compile_tools_target(vtkWrapNodeJs)
+  vtk_compile_tools_target(vtkWrapNodeJsInit)
 
   add_executable(vtkParseJava vtkParseJava.c)
   target_link_libraries(vtkParseJava vtkWrappingTools)
diff -urBN VTK-6.2.0-org/Wrapping/Tools/vtkWrapNodeJs.c VTK-6.2.0/Wrapping/Tools/vtkWrapNodeJs.c
--- VTK-6.2.0-org/Wrapping/Tools/vtkWrapNodeJs.c	1970-01-01 01:00:00.000000000 +0100
+++ VTK-6.2.0/Wrapping/Tools/vtkWrapNodeJs.c	2016-01-27 14:42:26.287651591 +0100
@@ -0,0 +1,1427 @@
+/*=========================================================================
+
+  Program:   Visualization Toolkit
+  Module:    vtkWrapNodeJs.c
+
+  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
+  All rights reserved.
+  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.
+
+     This software is distributed WITHOUT ANY WARRANTY; without even
+     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+     PURPOSE.  See the above copyright notice for more information.
+
+=========================================================================*/
+
+#include "vtkWrap.h"
+#include "vtkWrapText.h"
+#include "vtkParse.h"
+#include "vtkParseData.h"
+#include "vtkParseMain.h"
+#include "vtkParseExtras.h"
+#include "vtkParseMangle.h"
+#include "vtkParseString.h"
+#include "vtkParseHierarchy.h"
+#include "vtkConfigure.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+
+#define MAX_WRAPPED_CLASSES 512
+
+#include "vtkWrapNodeJsSupport.c"
+
+/* -------------------------------------------------------------------- */
+/* Finds the hierachy info of class called "name".       */
+/*
+static HierarchyEntry *findHierarchyEntry(
+  HierarchyInfo *hinfo,
+  char const *name
+)
+{
+  int k;
+
+  for (k = 0; k < hinfo->NumberOfEntries; k++)
+    {
+    if (!strcmp(hinfo->Entries[k].Name, name))
+      {
+      return hinfo->Entries + k;
+      }
+    }
+ 
+  return 0;
+}
+*/
+
+
+/* -------------------------------------------------------------------- */
+/* Check an arg to see if it is wrappable */
+
+static int isValueWrappable(
+  ValueInfo *val,
+  HierarchyInfo *hinfo,
+  int flags
+)
+{
+  static unsigned int wrappableTypes[] = {
+//  FIXME make handles for all stuff commented out
+//  VTK_PARSE_VOID,
+//  VTK_PARSE_BOOL,
+//  VTK_PARSE_FLOAT,
+    VTK_PARSE_DOUBLE,
+    VTK_PARSE_CHAR,
+//  VTK_PARSE_UNSIGNED_CHAR,
+//  VTK_PARSE_SIGNED_CHAR,
+    VTK_PARSE_INT,
+//  VTK_PARSE_UNSIGNED_INT,
+//  VTK_PARSE_SHORT,
+//  VTK_PARSE_UNSIGNED_SHORT,
+//  VTK_PARSE_LONG,
+//  VTK_PARSE_UNSIGNED_LONG,
+//  VTK_PARSE_ID_TYPE,
+//  VTK_PARSE_UNSIGNED_ID_TYPE,
+//  VTK_PARSE_SSIZE_T,
+//  VTK_PARSE_SIZE_T,
+#ifdef VTK_TYPE_USE_LONG_LONG
+//  VTK_PARSE_LONG_LONG,
+//  VTK_PARSE_UNSIGNED_LONG_LONG,
+#endif
+#ifdef VTK_TYPE_USE___INT64
+//  VTK_PARSE___INT64,
+//  VTK_PARSE_UNSIGNED___INT64,
+#endif
+    VTK_PARSE_OBJECT,
+//  VTK_PARSE_QOBJECT,
+//  VTK_PARSE_STRING,
+#ifndef VTK_PYTHON_NO_UNICODE
+//    VTK_PARSE_UNICODE_STRING,
+#endif
+    0
+  };
+
+  HierarchyEntry *he;
+  char const * const* cpp;
+  unsigned int baseType;
+  int j;
+
+  if ((flags & VTK_WRAP_RETURN))
+    {
+    if (vtkWrap_IsVoid(val)) return 1;
+
+    if (vtkWrap_IsNArray(val)) return 0;
+    }
+
+  baseType = val->Type & VTK_PARSE_BASE_TYPE;
+
+  /* go through all types that are indicated as wrappable */
+  for (j = 0; wrappableTypes[j]; j++)
+    {
+    if (baseType == wrappableTypes[j]) { break; }
+    }
+
+  if (wrappableTypes[j] == 0)
+    {
+    return 0;
+    }
+
+  if (baseType == VTK_PARSE_OBJECT)
+    {
+    if (!vtkWrap_IsPointer(val))
+      {
+      return 0;
+      }
+
+      he = vtkParseHierarchy_FindEntry(hinfo, val->Class);
+
+      if (he && vtkParseHierarchy_GetProperty(he, "WRAP_EXCLUDE"))
+        {
+        return 0;
+        }
+
+#ifndef DO_WHITELIST
+      for(cpp = blacklist; *cpp; cpp++)
+        if (!strcmp(val->Class, *cpp))
+          {
+          return 0;
+          }
+#else
+      for(cpp = whitelist; *cpp; cpp++)
+        if (!strcmp(val->Class, *cpp))
+          {
+          break;
+          }
+      if (!*cpp) return 0;
+#endif
+    }
+
+  if (vtkWrap_IsRef(val))
+    {
+    return 0;
+    }
+
+  if (val->Template)
+    {
+    return 0;
+    }
+
+  if (vtkWrap_IsScalar(val))
+    {
+    return 1;
+    }
+  else if (vtkWrap_IsArray(val) || vtkWrap_IsNArray(val))
+    {
+    return 0;
+    }
+  else if (vtkWrap_IsPointer(val))
+    {
+    if (vtkWrap_IsCharPointer(val))
+      {
+      return 1;
+      }
+
+    if (vtkWrap_IsVTKObject(val))
+      {
+      return 1;
+      }
+    }
+
+  return 0;
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Checks a method to see if it is wrappable in python */
+
+static int vtkWrapNodeJs_MethodCheck(
+  FunctionInfo *finfo, HierarchyInfo *hinfo)
+{
+  int i, n;
+
+  /* some functions will not get wrapped no matter what */
+  if (finfo->Access != VTK_ACCESS_PUBLIC)
+    {
+    return 0;
+    }
+
+  /* no need to wrap constructors/destructors as functions */
+  if(!finfo->ReturnValue)
+    {
+    return 0;
+    }
+  
+  if(finfo->IsOperator)
+    {
+    return 0;
+    }
+
+  /* new and delete are meaningless in wrapped languages */
+  if (finfo->Name == 0 ||
+      strcmp("Register", finfo->Name) == 0 ||
+      strcmp("UnRegister", finfo->Name) == 0 ||
+      strcmp("Delete", finfo->Name) == 0 ||
+      strcmp("FastDelete", finfo->Name) == 0 ||
+      strcmp("GetReferenceCount", finfo->Name) == 0 ||
+      strcmp("SetReferenceCount", finfo->Name) == 0 ||
+      strcmp("New", finfo->Name) == 0)
+    {
+    return 0;
+    }
+
+  /* function pointer arguments for callbacks */
+  if (finfo->NumberOfParameters == 2 &&
+      vtkWrap_IsVoidFunction(finfo->Parameters[0]) &&
+      vtkWrap_IsVoidPointer(finfo->Parameters[1]) &&
+      !vtkWrap_IsConst(finfo->Parameters[1]) &&
+      vtkWrap_IsVoid(finfo->ReturnValue))
+    {
+//  return 1;
+    return 0;
+    }
+
+  n = vtkWrap_CountWrappedParameters(finfo);
+
+  /* check to see if we can handle all the args */
+  for (i = 0; i < n; i++)
+    {
+    if (!isValueWrappable(
+          finfo->Parameters[i], hinfo, VTK_WRAP_ARG))
+      {
+      return 0;
+      }
+    }
+
+  /* check the return value */
+  if (!isValueWrappable(
+        finfo->ReturnValue, hinfo, VTK_WRAP_RETURN))
+    {
+    return 0;
+    }
+
+  return 1;
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Compares two function in terms of name/overloading precedence. */
+static int methodCompare(FunctionInfo const *f1, FunctionInfo const *f2)
+{
+  int ncmp, p, fpn1, fpn2;
+  unsigned int t1, t2;
+
+  ncmp = strcmp(f1->Name, f2->Name);
+
+  if( ncmp ) return ncmp;
+
+  p = 0;
+  fpn1 = f1->NumberOfParameters;
+  fpn2 = f2->NumberOfParameters;
+
+  for(;;)
+    {
+    if( p >= fpn1 ) return +1;
+    if( p >= fpn2 ) return -1;
+
+    t1 = f1->Parameters[p]->Type;
+    t2 = f2->Parameters[p]->Type;
+
+    if( t1 > t2 ) return -1;
+    if( t1 < t2 ) return +1;
+
+    p++;
+    }
+
+  fprintf(stderr, "got identical overloads!\n");
+  exit(1);
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Returns a null terminated list of method infos of a class. */
+/* Sorted by name and overloading precedence. */
+
+static FunctionInfo **getMethodsInfo(
+  ClassInfo const * cinfo,
+  HierarchyInfo * hinfo
+)
+{
+  int i, j, nof;
+  FunctionInfo **minfo, *b;
+
+  nof = cinfo->NumberOfFunctions;
+
+  minfo = (FunctionInfo**) calloc(nof + 2, sizeof(FunctionInfo**));
+
+  memcpy(minfo, cinfo->Functions, nof * sizeof(FunctionInfo**));
+    
+  /* removes not wrapables */
+  i = 0;
+  while (i < nof)
+    {
+    if (!vtkWrapNodeJs_MethodCheck(minfo[i], hinfo))
+      {
+      minfo[i] = minfo[--nof];
+      minfo[nof] = 0;
+      }
+      else
+      {
+      i++;
+      }
+    }
+
+  /* sorts them by name/parameters */
+  for(i = 1; i < nof; i++)
+    for(j = i; j > 0 && methodCompare(minfo[j - 1], minfo[ j ]) > 0; j--)
+      {
+      b = minfo[j];
+      minfo[j] = minfo[j-1];
+      minfo[j-1] = b;
+      }
+
+  return minfo;
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Returns true if there is no lowercase char in s.       */
+
+static int isUpperString(
+  char const *s
+)
+{
+  while (*s)
+    {
+    if (*s != toupper(*s)) return 0;
+    s++;
+    }
+
+  return 1;
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Writes the initializer which registers a wrapper class to node       */
+
+static void writeInit(
+  FILE *f,
+  char const *name,
+  char const *wrapperName,
+  ClassInfo *cinfo,
+  FunctionInfo **minfo,
+  HierarchyInfo *hinfo,
+  HierarchyEntry *he
+)
+{
+  char const *lastName;
+  char const *sname;
+  FunctionInfo **m;
+
+  if(he->NumberOfSuperClasses > 1 )
+    {
+    fprintf(stderr, "Cannot do multiple inheritance\n");
+    exit(1);
+    }
+
+  fprintf(f, "void %s::Init(v8::Local<v8::Object> exports)\n", wrapperName);
+  fprintf(f, "{\n");
+
+  fprintf(f,
+    "\tNan::SetAccessor(exports, Nan::New(\"%s\").ToLocalChecked(), ConstructorGetter);\n",
+    name
+    );
+
+  if(!strncmp(name, "vtk", 3 )) 
+    {
+    fprintf(f,
+      "\tNan::SetAccessor(exports, Nan::New(\"%s\").ToLocalChecked(), ConstructorGetter);\n",
+      name + 3
+      );
+    }
+
+  fprintf(f, "}\n");
+  fprintf(f, "\n");
+  
+  fprintf(f, "void %s::ConstructorGetter(\n", wrapperName);
+  fprintf(f, "\tv8::Local<v8::String> property,\n");
+  fprintf(f, "\tconst Nan::PropertyCallbackInfo<v8::Value>& info)\n");
+  fprintf(f, "{\n");
+  fprintf(f, "\tInitPtpl();\n");
+  fprintf(f, "\tinfo.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());\n");
+  fprintf(f, "}\n");
+  fprintf(f, "\n");
+
+  fprintf(f, "void %s::InitPtpl()\n", wrapperName);
+  fprintf(f, "{\n");
+  fprintf(f, "\tif (!ptpl.IsEmpty()) return;\n");
+
+  fprintf(f, "\tv8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);\n");
+
+  if(he->NumberOfSuperClasses > 0 )
+    {
+    sname = he->SuperClasses[0];
+    fprintf(f, "\t%c%sWrap::InitPtpl( );\n", toupper(*sname), sname + 1 );
+    fprintf(f,
+      "\ttpl->Inherit(Nan::New<FunctionTemplate>(%c%sWrap::ptpl));\n",
+      toupper(*sname),
+      sname + 1
+      );
+    }
+
+  fprintf(f, "\ttpl->SetClassName(Nan::New(\"%s\").ToLocalChecked());\n", wrapperName);
+  fprintf(f, "\ttpl->InstanceTemplate()->SetInternalFieldCount(1);\n");
+  fprintf(f, "\n");
+
+  lastName = 0;
+  for (m = minfo; *m; m++)
+    {
+    FunctionInfo *finfo = *m;
+    if (lastName && !strcmp(lastName, (*m)->Name)) continue;
+    lastName = (*m)->Name;
+
+    fprintf(f,
+      "\tNan::SetPrototypeMethod(tpl, \"%s\", %s);\n",
+      finfo->Name,
+      finfo->Name
+      );
+
+    if (!isUpperString(finfo->Name ))
+      {
+      fprintf(f,
+        "\tNan::SetPrototypeMethod(tpl, \"%c%s\", %s);\n",
+        tolower(*finfo->Name), finfo->Name + 1,
+        finfo->Name
+        );
+      }
+    
+    fprintf(f, "\n");
+    }
+
+	fprintf(f, "\tptpl.Reset( tpl );\n");
+  fprintf(f, "}\n");
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Writes the "new" handler. */
+
+static void writeNew(
+  FILE *f,
+  char const *name,
+  char const *wrapperName,
+  ClassInfo *cinfo
+)
+{
+  fprintf(f, "void %s::New(const Nan::FunctionCallbackInfo<v8::Value>& info)\n", wrapperName);
+  fprintf(f, "{\n");
+  fprintf(f, "\tif(!info.IsConstructCall())\n");
+  fprintf(f, "\t{\n");
+  fprintf(f, "\t\tNan::ThrowError(\"Constructor not called in a construct call.\");\n");
+  fprintf(f, "\t\treturn;\n");
+  fprintf(f, "\t}\n");
+  fprintf(f, "\n");
+  fprintf(f, "\tif(info.Length() == 0)\n");
+  fprintf(f, "\t{\n");
+
+  if (!cinfo->IsAbstract)
+    {
+    fprintf(f, "\t\tvtkSmartPointer<%s> native = vtkSmartPointer<%s>::New();\n", name, name);
+    fprintf(f, "\t\t%s* obj = new %s(native);", wrapperName, wrapperName);
+    fprintf(f, "\t\tobj->Wrap(info.This());\n");
+    }
+  else
+    {
+    fprintf(f, "\t\tNan::ThrowError(\"Cannot create instance of abstract class.\");\n");
+    fprintf(f, "\t\treturn;\n");
+    }
+  fprintf(f, "\t}\n");
+  fprintf(f, "\telse\n");
+  fprintf(f, "\t{\n");
+  fprintf(f, "\t\tif(info[0]->ToObject() != vtkNodeJsNoWrap )\n");
+  fprintf(f, "\t\t\tNan::ThrowError(\"Parameter Error\");\n");
+  fprintf(f, "\t}\n");
+  fprintf(f, "\n");
+  fprintf(f, "\tinfo.GetReturnValue().Set(info.This());\n");
+  fprintf(f, "}\n");
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Returns the v8 parameter test function */
+
+static char const * v8ParameterTestFuncName(
+   ValueInfo *vinfo
+)
+{
+  unsigned int baseType = (vinfo->Type & VTK_PARSE_BASE_TYPE);
+
+  switch (baseType )
+    {
+    case VTK_PARSE_DOUBLE :
+      return "IsNumber";
+
+    case VTK_PARSE_INT :
+      return "IsInt32";
+
+    case VTK_PARSE_CHAR :
+      if(vtkWrap_IsPointer(vinfo)) return "IsString";
+      else return "IsInt32";
+
+    default :
+      fprintf(stderr,
+        "Unexpected parameter type %d/%d for %s.\n",
+         baseType, vinfo->Type, vinfo->Name
+         );
+      exit(1);
+    }
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Writes a parameter variable for some parameters that need it. */
+
+static void writeHandlerParameterVar(
+   FILE *f,
+   char const *indent,
+   int p,
+   ValueInfo *vinfo
+)
+{
+  unsigned int baseType = (vinfo->Type & VTK_PARSE_BASE_TYPE);
+
+  switch(baseType)
+    {
+    case VTK_PARSE_CHAR :
+ 
+      if(vtkWrap_IsPointer(vinfo))
+        {
+        fprintf(f, "\t%sNan::Utf8String a%d(info[%d]);\n", indent, p, p);
+        }
+        else
+        {
+        fprintf(f, "\t%schar a%d = info[%d]->Int32Value();\n", indent, p, p);
+        fprintf(f, "\t%sif( a%d < -127 || a%d > 128 )\n", indent, p, p );
+        fprintf(f, "\t%s{\n", indent );
+        fprintf(f, "\t%s\tNan::ThrowError(\"char value out of bounds.\");\n", indent );
+        fprintf(f, "\t%s\treturn;\n", indent );
+        fprintf(f, "\t%s}\n", indent );
+        }
+ 
+      break;
+ 
+    case VTK_PARSE_OBJECT :
+      fprintf(f,
+        "\t%s%c%sWrap *a%d = ObjectWrap::Unwrap<%c%sWrap>(info[%d]->ToObject());\n",
+        indent,
+        toupper(*vinfo->Class),
+        vinfo->Class + 1,
+        p,
+        toupper(*vinfo->Class),
+        vinfo->Class + 1,
+        p
+        );
+      break;
+    }
+}
+
+/* -------------------------------------------------------------------- */
+/* Writes a parameter value getter for the handlers native call. */
+
+static void writeHandlerParameterValue(
+   FILE *f,
+   char const *indent,
+   int p,
+   ValueInfo *vinfo,
+   int nop
+)
+{
+  unsigned int baseType = (vinfo->Type & VTK_PARSE_BASE_TYPE);
+ 
+  switch(baseType)
+    {
+    case VTK_PARSE_DOUBLE :
+   
+      fprintf(f,
+        "\t%s\tinfo[%d]->NumberValue()%s\n",
+        indent,
+        p,
+        p + 1 < nop ? "," : ""
+        );
+      break;
+   
+    case VTK_PARSE_INT :
+   
+      fprintf(f,
+        "\t%s\tinfo[%d]->Int32Value()%s\n",
+        indent,
+        p,
+        p + 1 < nop ? "," : ""
+        );
+      break;
+   
+    case VTK_PARSE_CHAR :
+      
+      if(vtkWrap_IsPointer(vinfo))
+        {
+        fprintf(f,
+          "\t%s\t*a%d%s\n",
+          indent,
+          p,
+          p + 1 < nop ? "," : ""
+          );
+        }
+        else
+        {
+        fprintf(f,
+          "\t%s\ta%d%s\n",
+          indent,
+          p,
+          p + 1 < nop ? "," : ""
+          );
+        }
+        
+      break;
+   
+    case VTK_PARSE_OBJECT :
+      
+      fprintf(f,
+        "\t%s\t(%s *) a%d->native.GetPointer()%s\n",
+        indent,
+        vinfo->Class,
+        p,
+        p + 1 < nop ? "," : ""
+        );
+        
+      break;
+ 
+    default :
+   
+     fprintf(stderr, "Unexpected parameter type.\n");
+     exit(1);
+    }
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Writes the return value parameter if needed. . */
+
+static void writeHandlerReturnVar(
+   FILE *f,
+   char const *indent,
+   ValueInfo *rinfo
+)
+{
+  unsigned int rBaseType; 
+
+  rBaseType = (rinfo->Type & VTK_PARSE_BASE_TYPE);
+  
+  switch( rBaseType )
+    {
+    case VTK_PARSE_VOID :
+      break;
+  
+    case VTK_PARSE_DOUBLE :
+      fprintf(f, "\t%sdouble r;\n", indent);
+      break;
+  
+    case VTK_PARSE_INT :
+      fprintf(f, "\t%sint r;\n", indent);
+      break;
+  
+    case VTK_PARSE_CHAR :
+      if (vtkWrap_IsPointer(rinfo))
+        {
+        fprintf(f, "\t%schar const * r;\n", indent);
+        }
+      else
+        {
+        fprintf(f, "\t%schar r;\n", indent);
+        }
+      break;
+  
+    case VTK_PARSE_OBJECT :
+      fprintf(f, "\t%s%s * r;\n", indent, rinfo->Class);
+      break;
+  
+    default :
+      fprintf(stderr, "Unexpected parameter type %d for return value.\n", rBaseType );
+      exit(1);
+    }
+}
+    
+
+/* -------------------------------------------------------------------- */
+/* Writes the return value setter, if needed. . */
+
+static void writeHandlerReturnSetter(
+   FILE *f,
+   char const *indent,
+   ValueInfo *rinfo
+)
+{
+  unsigned int rBaseType = (rinfo->Type & VTK_PARSE_BASE_TYPE);
+
+  switch( rBaseType )
+    {
+    case VTK_PARSE_VOID :
+      break;
+ 
+    case VTK_PARSE_INT :
+    case VTK_PARSE_DOUBLE :
+      fprintf(f, "\t%sinfo.GetReturnValue().Set(Nan::New(r));\n", indent);
+      break;
+ 
+    case VTK_PARSE_CHAR :
+      if (vtkWrap_IsPointer(rinfo))
+        {
+        fprintf(f, "\t%sinfo.GetReturnValue().Set(Nan::New(r).ToLocalChecked());\n", indent);
+        }
+        else
+        {
+        fprintf(f, "\t%sinfo.GetReturnValue().Set(Nan::New(r));\n", indent);
+        }
+      break;
+ 
+    case VTK_PARSE_OBJECT :
+      fprintf(f,
+        "\t%s\t%c%sWrap::InitPtpl();\n",
+        indent,
+        toupper(*rinfo->Class),
+        rinfo->Class + 1
+        );
+      fprintf(f, "\t%sv8::Local<v8::Value> argv[1] =\n", indent );
+      fprintf(f, "\t%s\t{ Nan::New(vtkNodeJsNoWrap) };\n", indent);
+      fprintf(f, "\t%sv8::Local<v8::Function> cons =\n", indent );
+      fprintf(f,
+        "\t%s\tNan::New<v8::FunctionTemplate>(%c%sWrap::ptpl)->GetFunction();\n",
+        indent,
+        toupper(*rinfo->Class),
+        rinfo->Class + 1
+        );
+      fprintf(f, "\t%sv8::Local<v8::Object> wo = cons->NewInstance(1, argv);\n", indent );
+      fprintf(f,
+        "\t%s%c%sWrap *w = new %c%sWrap();\n",
+        indent, 
+        toupper(*rinfo->Class),
+        rinfo->Class + 1,
+        toupper(*rinfo->Class),
+        rinfo->Class + 1
+        );
+      fprintf(f, "\t%sw->native = r;\n", indent );
+      fprintf(f, "\t%sw->Wrap(wo);\n", indent);
+      fprintf(f, "\t%sinfo.GetReturnValue().Set(wo);\n", indent);
+      break;
+ 
+    default :
+      fprintf(stderr, "Unexpected parameter type %d for return value.\n", rBaseType);
+      exit(1);
+    }
+}
+
+/* -------------------------------------------------------------------- */
+/* TODO */
+
+static int parameterEqualInOverload(
+  ValueInfo *p1info,
+  ValueInfo *p2info
+)
+{
+  if( p1info->Type == p2info->Type ) return 1;
+
+  if( p1info->Type != VTK_PARSE_OBJECT ) return 0;
+
+  return !strcmp(p1info->Class, p2info->Class );
+}
+
+/* -------------------------------------------------------------------- */
+/* Writes a function handler */
+
+static void writeFunctionHandler(
+  FILE *f,
+  char const *name,
+  char const *wrapperName,
+  int overloadCount,
+  FunctionInfo **minfo,
+  ClassInfo *cinfo,
+  HierarchyInfo *hinfo
+)
+{
+  int nop;
+  int p, pd;
+  char indent[255];
+  unsigned int rBaseType = VTK_PARSE_VOID; 
+  ValueInfo *rinfo;
+  FunctionInfo *finfo = *minfo;
+  int overload;
+  int writeElse;
+
+  fprintf(f,
+    "void %s::%s(const Nan::FunctionCallbackInfo<v8::Value>& info)\n",
+    wrapperName,
+    finfo->Name
+    );
+
+  fprintf(f, "{\n");
+
+  fprintf(f,
+    "\t%s *wrapper = ObjectWrap::Unwrap<%s>(info.Holder());\n",
+    wrapperName,
+    wrapperName
+    );
+
+  fprintf(f,
+    "\t%s *native = (%s *)wrapper->native.GetPointer();\n",
+    name,
+    name
+    );
+
+  /* Argument checking */
+
+  *indent = 0;
+  p = 0;
+  writeElse = 0;
+
+  for (overload = 0; overload < overloadCount; overload++)
+    {
+    finfo = minfo[overload];
+    nop = finfo->NumberOfParameters;
+
+    for (; p < nop; p++)
+      {
+      ValueInfo *vinfo = finfo->Parameters[p];
+      unsigned int baseType = (vinfo->Type & VTK_PARSE_BASE_TYPE);
+      const char *sname;
+
+      if( baseType != VTK_PARSE_OBJECT )
+        {
+        fprintf(f,
+          "\t%s%sif(info.Length() > %d && info[%d]->%s())\n",
+          indent,
+          writeElse ? "else " : "",
+          p,
+          p,
+          v8ParameterTestFuncName(vinfo)
+          );
+        }
+        else
+        {
+        sname = vinfo->Class;
+
+        fprintf(f,
+          "\t%s%sif(info.Length() > %d && info[%d]->IsObject() && "
+          "(Nan::New(%c%sWrap::ptpl))->HasInstance(info[%d]))\n",
+          indent,
+          writeElse ? "else " : "",
+          p,
+          p,
+          toupper(*sname),
+          sname + 1,
+          p
+          );
+        }
+
+      writeElse = 0;
+ 
+      fprintf(f, "\t%s{\n", indent);
+      strcat(indent, "\t");
+      writeHandlerParameterVar(f, indent, p, vinfo );
+      }
+
+    rinfo = finfo->ReturnValue;
+    if(rinfo)
+      {
+      rBaseType = (rinfo->Type & VTK_PARSE_BASE_TYPE);
+      writeHandlerReturnVar(f, indent, rinfo);
+      }
+
+    fprintf(f, "\t%sif(info.Length() != %u)\n", indent, nop);
+    fprintf(f, "\t%s{\n", indent);
+    fprintf(f, "\t%s\tNan::ThrowError(\"Too many parameters.\");\n", indent);
+    fprintf(f, "\t%s\treturn;\n", indent);
+    fprintf(f, "\t%s}\n", indent);
+
+    /* writes the native call */
+    fprintf(f,
+      "\t%s%snative->%s(",
+      indent,
+      rBaseType != VTK_PARSE_VOID ? "r = " : "",
+      finfo->Name
+      );
+ 
+    if( nop > 0 )
+      {
+      fprintf(f, "\n");
+ 
+      for(p = 0; p < nop; p++)
+        {
+        writeHandlerParameterValue(f, indent, p, finfo->Parameters[p], nop);
+        }
+    
+      fprintf(f, "\t%s);\n", indent);
+      }
+    else
+      {
+      fprintf(f, ");\n");
+      }
+
+    /* sets the return value */
+    if (rinfo)
+      {
+      writeHandlerReturnSetter(f, indent, rinfo);
+      }
+ 
+    /* if one overload takes zero parameter, */
+    /* it will be the last in the chain */
+    if (nop > 0)
+      {
+      fprintf(f, "\t%sreturn;\n", indent);
+      }
+
+    /* figures out after how many parameters */
+    /* the overload differs */
+    for(;;)
+      {
+      if (overload + 1 < overloadCount)
+        {
+        /* the next overloading function */
+        /* it has less or equal amount of parameters */
+        FunctionInfo *foinfo = minfo[ overload + 1];
+     
+        for (pd = 0; pd < foinfo->NumberOfParameters; pd++)
+          {
+          if (!parameterEqualInOverload(
+            finfo->Parameters[pd],
+            foinfo->Parameters[pd]))
+            {
+            break;
+            }
+          }
+     
+        if (foinfo->NumberOfParameters == finfo->NumberOfParameters
+          && pd >= foinfo->NumberOfParameters)
+          {
+          fprintf(stderr,
+            "WARN: Cannot distinguish overloads for method \"%s\"\n",
+            finfo->Name
+          );
+          //exit(1);
+          overload++;
+          continue;
+          }
+     
+        for (; p > pd; p--)
+          {
+          indent[strlen(indent)-1] = 0;
+          fprintf(f, "\t%s}\n", indent);
+          writeElse = 1;
+          }
+        }
+        break;
+      }
+    }
+
+  while (*indent)
+    {
+    indent[strlen(indent)-1] = 0;
+    fprintf(f, "\t%s}\n", indent);
+    }
+
+  if (nop > 0)
+    {
+    fprintf(f, "\tNan::ThrowError(\"Parameter mismatch\");\n" );
+    }
+
+  fprintf(f, "}\n");
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Returns 1 if needle is in hay */
+
+static int needleInHay(
+   char const * const * hay,
+   int count,
+   char const * needle
+)
+{
+  int i;
+  for (i = 0; i < count; i++)
+    {
+    if(!strcmp(hay[i],needle)) return 1;
+    }
+  return 0;
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Writes a class inclusion. */
+
+static void writeClassInclude(
+  FILE *f,
+  const char *name
+)
+{
+  fprintf(f, "#include \"" );
+  while(*name && *name != '<' )
+    {
+    fprintf(f, "%c", *name );
+    name++;
+    }
+  fprintf(f, "Wrap.h\"\n");
+}
+
+/* -------------------------------------------------------------------- */
+/* Writes the header for the wrapped object class */
+
+static void writeHeader(
+  char const *name,
+  char const *wrapperName,
+  ClassInfo *cinfo,
+  FunctionInfo **minfo,
+  HierarchyInfo *hinfo,
+  HierarchyEntry *he,
+  OptionInfo *options
+)
+{
+  char *c;
+  char *cxxFilename;
+  char *hFilename;
+  char *upperName;
+  char const *sname;
+  char const *lastName;
+  int k, cxxFilenameLen;
+  int a;
+  FILE * f;
+  FunctionInfo **m;
+
+  cxxFilename = options->OutputFileName; 
+  cxxFilenameLen = strlen(cxxFilename);
+
+  for (k = cxxFilenameLen; k > 0 && cxxFilename[ k ] != '.'; k--);
+
+  if (k == 0)
+    {
+    fprintf(stderr, "Output filename \"%s\" has no extension", options->OutputFileName);
+    exit(1);
+    }
+
+  hFilename = (char *) calloc(cxxFilenameLen + 3, sizeof(char));
+  strncpy(hFilename, cxxFilename, k);
+  strcat(hFilename, ".h");
+
+  f = fopen( hFilename, "w" );
+
+  if (!f)
+    {
+    fprintf(stderr, "Error opening output header file %s\n", hFilename);
+    exit(1);
+    }
+
+  upperName = strdup( name );
+  for(c = upperName; *c; c++) *c = toupper(*c);
+  
+  fprintf(f, "/* this file has been autogenerated by vtkNodeJsWrap */\n");
+  fprintf(f, "/* editing this might proof futile */\n");
+  fprintf(f, "\n" );
+  fprintf(f, "#ifndef NATIVE_EXTENSION_VTK_%sWRAP_H\n", upperName);
+  fprintf(f, "#define NATIVE_EXTENSION_VTK_%sWRAP_H\n", upperName);
+  fprintf(f, "\n");
+  fprintf(f, "#include <nan.h>\n");
+  fprintf(f, "\n");
+  fprintf(f, "#include <vtkSmartPointer.h>\n");
+  fprintf(f, "#include <%s.h>\n", name);
+  fprintf(f, "\n");
+
+  for (a = 0; a < he->NumberOfSuperClasses; a++)
+    {
+    sname = he->SuperClasses[ a ];
+    writeClassInclude(f, sname);
+    }
+
+  fprintf(f, "\n");
+
+  if( he->NumberOfSuperClasses )
+    {
+    fprintf(f, "class %s :", wrapperName);
+    for(a = 0; a < he->NumberOfSuperClasses; a++)
+      {
+      if( a ) fprintf(f, ",");
+      sname = he->SuperClasses[ a ];
+      fprintf(f, " public %c%sWrap", toupper(*sname), sname + 1);
+      }
+    fprintf(f, "\n");
+    }
+  else
+    {
+    fprintf(f, "class %s : public Nan::ObjectWrap\n", wrapperName);
+    }
+
+  fprintf(f, "{\n");
+  fprintf(f, "\tpublic:\n");
+  fprintf(f, "\t\tusing Nan::ObjectWrap::Wrap;\n");
+  fprintf(f, "\t\tstatic void Init(v8::Local<v8::Object> exports);\n");
+  fprintf(f, "\t\tstatic void InitPtpl();\n");
+  fprintf(f, "\t\tstatic void ConstructorGetter(\n");
+  fprintf(f, "\t\t\tv8::Local<v8::String> property,\n");
+  fprintf(f, "\t\t\tconst Nan::PropertyCallbackInfo<v8::Value>& info);\n");
+  fprintf(f, "\n");
+
+  if(!he->NumberOfSuperClasses)
+    {
+    fprintf(f, "\t\tvtkSmartPointer<%s> native;\n", name);
+    fprintf(f, "\n");
+    }
+
+  fprintf(f, "\t\t%s(vtkSmartPointer<%s>);\n", wrapperName, name);
+  fprintf(f, "\t\t%s();\n", wrapperName);
+  fprintf(f, "\t\t~%s( );\n", wrapperName);
+  fprintf(f, "\t\tstatic Nan::Persistent<v8::FunctionTemplate> ptpl;\n");
+  fprintf(f, "\n");
+  fprintf(f, "\tprivate:\n");
+  fprintf(f, "\t\tstatic void New(const Nan::FunctionCallbackInfo<v8::Value>& info);\n");
+  fprintf(f, "\n");
+
+  lastName = 0;
+  for (m = minfo; *m; m++)
+    {
+    if (lastName && !strcmp(lastName, (*m)->Name)) continue;
+    lastName = (*m)->Name;
+
+    fprintf(
+      f,
+      "\t\tstatic void %s(const Nan::FunctionCallbackInfo<v8::Value>& info);\n",
+      (*m)->Name
+      );
+    }
+
+  fprintf(f, "};\n");
+  fprintf(f, "\n");
+  fprintf(f, "#endif\n");
+
+  fclose(f);
+
+  free(hFilename);
+  free(upperName);
+}
+
+
+/* -------------------------------------------------------------------- */
+/* Writes the c++ code for the wrapped object class */
+
+static void writeCC(
+  const char *name,
+  const char *wrapperName,
+  ClassInfo *cinfo,
+  FunctionInfo **minfo,
+  HierarchyInfo *hinfo,
+  HierarchyEntry *he,
+  OptionInfo *options
+)
+{
+  FILE *f;
+  int a, b;
+  char const *included[MAX_WRAPPED_CLASSES + 1];
+  int incCount = 0;
+  char const *sname;
+  FunctionInfo **m;
+  int oc;
+  
+  /* get the output file */
+  f = fopen(options->OutputFileName, "w");
+  
+  fprintf(f, "/* this file has been autogenerated by vtkNodeJsWrap */\n");
+  fprintf(f, "/* editing this might proof futile */\n");
+  fprintf(f, "\n" );
+
+  if (!f)
+    {
+    fprintf(stderr, "Error opening output file %s\n", options->OutputFileName);
+    exit(1);
+    }
+
+  /* the VTK_WRAPPING_CXX tells header files where they're included from */
+  fprintf(f, "#define VTK_WRAPPING_CXX\n" );
+
+  /* unless this is vtkObjectBase.h, define VTK_STREAMS_FWD_ONLY */
+  if (strcmp("vtkObjectBase", name) != 0)
+    {
+    /* Block inclusion of full streams.  */
+    fprintf(f, "#define VTK_STREAMS_FWD_ONLY\n");
+    }
+
+  fprintf(f, "#include <nan.h>\n");
+  fprintf(f, "\n");
+//  fprintf(f, "#include <vtkSmartPointer.h>\n" );
+//  fprintf(f, "#include <%s.h>\n", name );
+  fprintf(f, "\n");
+
+  for (a = 0; a < he->NumberOfSuperClasses; a++)
+    {
+    sname = he->SuperClasses[ a ];
+    if (needleInHay(included, incCount, sname)) continue;
+    writeClassInclude(f, sname);
+    included[incCount++] = sname;
+    if (incCount >= MAX_WRAPPED_CLASSES)
+      {
+      fprintf(stderr, "MAX_WRAPPED_CLASSES exceeded\n" );
+      exit(1);
+      }
+    }
+
+  if(!needleInHay(included, incCount, name))
+    {
+    fprintf(f, "#include \"%sWrap.h\"\n", name);
+    included[incCount++] = name;
+    if (incCount >= MAX_WRAPPED_CLASSES)
+      {
+      fprintf(stderr, "MAX_WRAPPED_CLASSES exceeded\n" );
+      exit(1);
+      }
+    }
+  
+  /* includes wrappers for returned classes. */
+  for (a = 0; a < cinfo->NumberOfFunctions; a++)
+    {
+    FunctionInfo *finfo = cinfo->Functions[a];
+    // FIXME use minfo
+    if (!vtkWrapNodeJs_MethodCheck(finfo, hinfo)) continue;
+    if (finfo->ReturnValue && vtkWrap_IsVTKObject(finfo->ReturnValue))
+      {
+      sname = finfo->ReturnValue->Class;
+      if (!needleInHay(included, incCount, sname))
+        {
+        fprintf(f, "#include \"%sWrap.h\"\n", sname);
+        included[incCount++] = sname;
+        if (incCount >= MAX_WRAPPED_CLASSES)
+          {
+          fprintf(stderr, "MAX_WRAPPED_CLASSES exceeded\n" );
+          exit(1);
+          }
+        }
+      }
+    for (b = 0; b < finfo->NumberOfParameters; b++)
+      {
+      ValueInfo *vinfo = finfo->Parameters[b];
+      if (!vtkWrap_IsVTKObject(vinfo)) continue;
+      sname = vinfo->Class;
+      if (needleInHay(included, incCount, sname)) continue;
+      fprintf(f, "#include \"%sWrap.h\"\n", sname);
+      included[incCount++] = sname;
+      if (incCount >= MAX_WRAPPED_CLASSES)
+        {
+        fprintf(stderr, "MAX_WRAPPED_CLASSES exceeded\n" );
+        exit(1);
+        }
+      }
+    }
+
+  fprintf(f, "\n");
+  fprintf(f, "using namespace v8;\n" );
+  fprintf(f, "\n");
+
+  fprintf(f, "extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;");
+  fprintf(f, "\n");
+
+  fprintf(f, "Nan::Persistent<v8::FunctionTemplate> %s::ptpl;\n", wrapperName);
+  fprintf(f, "\n");
+  
+  fprintf(f, "%s::%s()\n", wrapperName, wrapperName);
+  fprintf(f, "{ }\n");
+  fprintf(f, "\n");
+
+  fprintf(f, "%s::%s(vtkSmartPointer<%s> _native)\n", wrapperName, wrapperName, name);
+  fprintf(f, "{ native = _native; }\n");
+  fprintf(f, "\n");
+
+  fprintf(f, "%s::~%s()\n", wrapperName, wrapperName);
+  fprintf(f, "{ }\n");
+  fprintf(f, "\n");
+
+  writeInit(f, name, wrapperName, cinfo, minfo, hinfo, he);
+  
+  fprintf(f, "\n");
+  
+  writeNew(f, name, wrapperName, cinfo );
+  
+  fprintf(f, "\n");
+
+  for (m = minfo; *m; m += oc)
+    {
+    oc = 1; /* overload count */
+    while(m[oc] && !strcmp(m[0]->Name,m[oc]->Name)) oc++;
+    writeFunctionHandler(f, name, wrapperName, oc, m, cinfo, hinfo);
+    fprintf(f, "\n");
+    }
+}
+
+
+/* -------------------------------------------------------------------- */
+/* This is the main entry point. */
+int main(int argc, char *argv[])
+{
+  OptionInfo *options = 0;
+  HierarchyInfo *hinfo = 0;
+  FileInfo *file_info = 0;
+  char const *name = 0;
+  char *name_from_file = 0;
+  char *wrapperName = 0;
+  HierarchyEntry *he = 0;
+  ClassInfo *cinfo;
+  FunctionInfo **minfo;
+  int k, m;
+  char const * const *cpp;
+  
+  /* get command-line args and parse the header file */
+  file_info = vtkParse_Main(argc, argv);
+
+  /* get the command-line options */
+  options = vtkParse_GetCommandLineOptions();
+
+  /* get the hierarchy info for accurate typing */
+  if (options->HierarchyFileName)
+    {
+    hinfo = vtkParseHierarchy_ReadFile(options->HierarchyFileName);
+    }
+
+  /* get the filename without the extension */
+  name = file_info->FileName;
+  m = strlen(name);
+  for (k = m; k > 0; k--)
+    {
+    if (name[k] == '.') { break; }
+    }
+
+  if (k > 0) { m = k; }
+
+  for (k = m; k > 0; k--)
+    {
+    if (!((name[k-1] >= 'a' && name[k-1] <= 'z') ||
+          (name[k-1] >= 'A' && name[k-1] <= 'Z') ||
+          (name[k-1] >= '0' && name[k-1] <= '9') ||
+          name[k-1] == '_')) { break; }
+    }
+  name_from_file = (char *)calloc(m - k + 1, sizeof( char ));
+
+  strncpy(name_from_file, name + k, m - k);
+
+  wrapperName = (char *)calloc(strlen(name_from_file) + 5, sizeof( char ));
+
+  strcpy(wrapperName, name_from_file);
+
+  strcat(wrapperName, "Wrap");
+
+  *wrapperName = toupper(*wrapperName);
+
+  /* finds the hierarchy info of the mainClass */
+  he = vtkParseHierarchy_FindEntry(hinfo, name_from_file);
+  if (!he )
+    {
+    fprintf(stderr, "Cannot find hierarchy info!\n");
+    exit(0);
+    }
+  
+  if (vtkParseHierarchy_GetProperty(he, "WRAP_EXCLUDE")) return 0;
+
+#ifndef DO_WHITELIST
+  for(cpp = blacklist; *cpp; cpp++)
+    {
+    if(!strcmp(*cpp, name_from_file )) return 0;
+    }
+#else
+  for(cpp = whitelist; *cpp; cpp++)
+    {
+    if(!strcmp(*cpp, name_from_file )) break;
+    }
+  if (!*cpp) return 0;
+#endif
+
+  cinfo = file_info->MainClass;
+
+  if (!cinfo) return 0;
+
+  if (cinfo->Template)
+    {
+    fprintf(stderr, "WARN: Cannot yet do templates.\n");
+    return 0; 
+    }
+
+  minfo = getMethodsInfo(cinfo, hinfo);
+
+  writeHeader(name_from_file, wrapperName, cinfo, minfo, hinfo, he, options);
+
+  writeCC(name_from_file, wrapperName, cinfo, minfo, hinfo, he, options);
+
+  free(minfo);
+
+  free(name_from_file);
+
+  free(wrapperName);
+
+  vtkParse_Free(file_info);
+
+  return 0;
+}
+
+
+// vim:set ts=2 sw=2 expandtab:
diff -urBN VTK-6.2.0-org/Wrapping/Tools/vtkWrapNodeJsInit.c VTK-6.2.0/Wrapping/Tools/vtkWrapNodeJsInit.c
--- VTK-6.2.0-org/Wrapping/Tools/vtkWrapNodeJsInit.c	1970-01-01 01:00:00.000000000 +0100
+++ VTK-6.2.0/Wrapping/Tools/vtkWrapNodeJsInit.c	2016-01-27 13:23:57.869290102 +0100
@@ -0,0 +1,146 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "vtkParseHierarchy.h"
+#include "vtkWrapNodeJsSupport.c"
+
+static int isBlacklisted(
+  const char *name
+)
+{
+  char const * const *e;
+
+#ifndef DO_WHITELIST
+  for (e = blacklist; *e; e++)
+    {
+    if (!strcmp(*e, name) ) return 1;
+    }
+  return 0;
+#else
+  for (e = whitelist; *e; e++)
+    {
+    if (!strcmp(*e, name) ) return 0;
+    }
+  return 1;
+#endif
+}
+
+
+static void createInitFile(
+  FILE *f,
+  char ** entries,
+  HierarchyInfo *hinfo
+)
+{
+  HierarchyEntry *he;
+  char **e;
+
+  fprintf(f,"/* this file has been autogenerated by vtkNodeJsWrapInit */\n");
+  fprintf(f,"/* editing this might proof futile */\n");
+  fprintf(f,"\n");
+  fprintf(f,"#include <nan.h>\n");
+  fprintf(f,"\n");
+
+  for(e = entries + 1; *e; e++)
+    {
+    if (isBlacklisted(*e)) continue;
+
+    he = vtkParseHierarchy_FindEntry(hinfo, *e);
+    if (!he || vtkParseHierarchy_GetProperty(he, "WRAP_EXCLUDE")) continue;
+
+    fprintf(f, "#include \"%sWrap.h\"\n", *e );
+    }
+
+  fprintf(f,"\n");
+  fprintf(f,"using namespace v8;\n");
+  fprintf(f,"\n");
+  fprintf(f,"extern void %sInit( v8::Local<v8::Object> exports )\n", entries[ 0 ] );
+  fprintf(f,"{\n");
+
+  for(e = entries + 1; *e; e++)
+    {
+    if (isBlacklisted(*e)) continue;
+
+    he = vtkParseHierarchy_FindEntry(hinfo, *e);
+    if (!he || vtkParseHierarchy_GetProperty(he, "WRAP_EXCLUDE")) continue;
+
+    fprintf(f, "\t%c%sWrap::Init( exports );\n", toupper(**e), *e + 1 );
+    }
+  fprintf(f,"}\n");
+  fprintf(f,"\n");
+}
+
+#define MAXENTRIES 4000
+
+int main(int argc,char *argv[])
+{
+  char b[512];
+  char b2[2];
+  char *cp;
+  size_t z;
+  FILE *f;
+  FILE *of;
+  char libName[512];
+  char *entries[MAXENTRIES];
+  int nEntries = 0;
+  HierarchyInfo *hinfo;
+
+  if (argc < 3)
+    {
+    fprintf(stderr,"Usage: %s data_list_file init_file\n",argv[0]);
+    return 1;
+    }
+  
+  hinfo = vtkParseHierarchy_ReadFile(argv[1]);
+
+  f = fopen(argv[2],"r");
+  if (!f)
+    {
+    fprintf(stderr,"Input file %s could not be opened\n",argv[2]);
+    return 1;
+    }
+  
+  for(;;)
+    {
+    cp = fgets(b, sizeof(b), f);
+    if (!cp) break;
+    z = strlen( b );
+    if (z == 0 || b[z - 1]!='\n')
+      {
+      cp = fgets(b2, sizeof(b2), f);
+      if (cp)
+        {
+        fprintf(stderr, "Filename \"%s\".. too long\"\n", b);
+        return 1;
+        }
+      }
+
+    /* removes the newline */
+    b[ z - 1] = 0;
+
+    if (nEntries+2>=MAXENTRIES)
+      {
+      fprintf(stderr, "Too many entries!\"\n");
+      return 1;
+      }
+    entries[nEntries++] = strdup( b );
+    }
+ 
+  entries[nEntries] = 0;
+
+  of = fopen(argv[3],"w");
+  if (!of)
+    {
+    fprintf(stderr, "Cannot open %s for writing\n", argv[3]);
+    return 1;
+    }
+
+  createInitFile(of, entries, hinfo);
+  fclose(of);
+
+  return 0;
+}
+
+// vim:set ts=2 sw=2 expandtab:
+
diff -urBN VTK-6.2.0-org/Wrapping/Tools/vtkWrapNodeJsSupport.c VTK-6.2.0/Wrapping/Tools/vtkWrapNodeJsSupport.c
--- VTK-6.2.0-org/Wrapping/Tools/vtkWrapNodeJsSupport.c	1970-01-01 01:00:00.000000000 +0100
+++ VTK-6.2.0/Wrapping/Tools/vtkWrapNodeJsSupport.c	2016-01-27 13:23:57.869290102 +0100
@@ -0,0 +1,47 @@
+
+/* used for development for a minimal vtk lib wrapper */
+/* to quickly test stuff out */
+/* #define DO_WHITELIST */
+
+/* TODO REMOVE */
+char const *whitelist[] =
+  {
+  "vtkViewport",
+  "vtkInteractorStyle",
+  "vtkInteractorStyleTrackballCamera",
+  "vtkInteractorObserver",
+  "vtkRenderer",
+  "vtkRenderWindow",
+  "vtkRenderWindowInteractor",
+  "vtkWindow",
+  "vtkActor",
+  "vtkProp3D",
+  "vtkProp",
+  "vtkObjectBase",
+  "vtkObject",
+  "vtkAbstractMapper",
+  "vtkAbstractMapper3D",
+  "vtkAlgorithm",
+  "vtkAlgorithmOutput",
+  "vtkPolyDataAlgorithm",
+  "vtkPolyDataMapper",
+  "vtkMapper",
+  "vtkConeSource",
+  "vtkCubeSource",
+  0,
+  };
+
+char const *blacklist[] =
+  {
+  "vtkTimeStamp",          // no vtkObjectDerivate
+  "vtkTDxMotionEventInfo", // no vtkObjectDerivate
+  "vtkVolumeRayCastDynamicInfo",
+  "vtkShadowMapBakerPassTextures",
+  "vtkShadowMapBakerPassLightCameras",
+  "vtkImageComplex",
+  "vtkVolumeRayCastStaticInfo",
+  "vtkShaderProgram2",
+  0,
+  };
+
+// vim:set ts=2 sw=2 expandtab:
