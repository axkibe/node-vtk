/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkLocatorWrap.h"
#include "vtkKdTreeWrap.h"
#include "vtkObjectWrap.h"
#include "vtkBSPCutsWrap.h"
#include "vtkDataSetWrap.h"
#include "vtkDataSetCollectionWrap.h"
#include "vtkIdListWrap.h"
#include "vtkPointSetWrap.h"
#include "vtkPointsWrap.h"
#include "vtkIdTypeArrayWrap.h"
#include "vtkPolyDataWrap.h"
#include "vtkKdNodeWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::Function> VtkKdTreeWrap::constructor;
Nan::Persistent<v8::FunctionTemplate> VtkKdTreeWrap::ptpl;

VtkKdTreeWrap::VtkKdTreeWrap()
{ }

VtkKdTreeWrap::VtkKdTreeWrap(vtkSmartPointer<vtkKdTree> _native)
{ native = _native; }

VtkKdTreeWrap::~VtkKdTreeWrap()
{ }

void VtkKdTreeWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkKdTree").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("KdTree").ToLocalChecked(), ConstructorGetter);
}

void VtkKdTreeWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkKdTreeWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkLocatorWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkLocatorWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkKdTreeWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AddDataSet", AddDataSet);
	Nan::SetPrototypeMethod(tpl, "addDataSet", AddDataSet);

	Nan::SetPrototypeMethod(tpl, "BuildLocator", BuildLocator);
	Nan::SetPrototypeMethod(tpl, "buildLocator", BuildLocator);

	Nan::SetPrototypeMethod(tpl, "BuildLocatorFromPoints", BuildLocatorFromPoints);
	Nan::SetPrototypeMethod(tpl, "buildLocatorFromPoints", BuildLocatorFromPoints);

	Nan::SetPrototypeMethod(tpl, "CopyTree", CopyTree);
	Nan::SetPrototypeMethod(tpl, "copyTree", CopyTree);

	Nan::SetPrototypeMethod(tpl, "CreateCellLists", CreateCellLists);
	Nan::SetPrototypeMethod(tpl, "createCellLists", CreateCellLists);

	Nan::SetPrototypeMethod(tpl, "DeleteCellLists", DeleteCellLists);
	Nan::SetPrototypeMethod(tpl, "deleteCellLists", DeleteCellLists);

	Nan::SetPrototypeMethod(tpl, "FreeSearchStructure", FreeSearchStructure);
	Nan::SetPrototypeMethod(tpl, "freeSearchStructure", FreeSearchStructure);

	Nan::SetPrototypeMethod(tpl, "GenerateRepresentation", GenerateRepresentation);
	Nan::SetPrototypeMethod(tpl, "generateRepresentation", GenerateRepresentation);

	Nan::SetPrototypeMethod(tpl, "GenerateRepresentationUsingDataBoundsOff", GenerateRepresentationUsingDataBoundsOff);
	Nan::SetPrototypeMethod(tpl, "generateRepresentationUsingDataBoundsOff", GenerateRepresentationUsingDataBoundsOff);

	Nan::SetPrototypeMethod(tpl, "GenerateRepresentationUsingDataBoundsOn", GenerateRepresentationUsingDataBoundsOn);
	Nan::SetPrototypeMethod(tpl, "generateRepresentationUsingDataBoundsOn", GenerateRepresentationUsingDataBoundsOn);

	Nan::SetPrototypeMethod(tpl, "GetBoundaryCellList", GetBoundaryCellList);
	Nan::SetPrototypeMethod(tpl, "getBoundaryCellList", GetBoundaryCellList);

	Nan::SetPrototypeMethod(tpl, "GetCellList", GetCellList);
	Nan::SetPrototypeMethod(tpl, "getCellList", GetCellList);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetCuts", GetCuts);
	Nan::SetPrototypeMethod(tpl, "getCuts", GetCuts);

	Nan::SetPrototypeMethod(tpl, "GetDataSet", GetDataSet);
	Nan::SetPrototypeMethod(tpl, "getDataSet", GetDataSet);

	Nan::SetPrototypeMethod(tpl, "GetDataSetIndex", GetDataSetIndex);
	Nan::SetPrototypeMethod(tpl, "getDataSetIndex", GetDataSetIndex);

	Nan::SetPrototypeMethod(tpl, "GetDataSets", GetDataSets);
	Nan::SetPrototypeMethod(tpl, "getDataSets", GetDataSets);

	Nan::SetPrototypeMethod(tpl, "GetFudgeFactor", GetFudgeFactor);
	Nan::SetPrototypeMethod(tpl, "getFudgeFactor", GetFudgeFactor);

	Nan::SetPrototypeMethod(tpl, "GetGenerateRepresentationUsingDataBounds", GetGenerateRepresentationUsingDataBounds);
	Nan::SetPrototypeMethod(tpl, "getGenerateRepresentationUsingDataBounds", GetGenerateRepresentationUsingDataBounds);

	Nan::SetPrototypeMethod(tpl, "GetIncludeRegionBoundaryCells", GetIncludeRegionBoundaryCells);
	Nan::SetPrototypeMethod(tpl, "getIncludeRegionBoundaryCells", GetIncludeRegionBoundaryCells);

	Nan::SetPrototypeMethod(tpl, "GetMinCells", GetMinCells);
	Nan::SetPrototypeMethod(tpl, "getMinCells", GetMinCells);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfDataSets", GetNumberOfDataSets);
	Nan::SetPrototypeMethod(tpl, "getNumberOfDataSets", GetNumberOfDataSets);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfRegions", GetNumberOfRegions);
	Nan::SetPrototypeMethod(tpl, "getNumberOfRegions", GetNumberOfRegions);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfRegionsOrLess", GetNumberOfRegionsOrLess);
	Nan::SetPrototypeMethod(tpl, "getNumberOfRegionsOrLess", GetNumberOfRegionsOrLess);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfRegionsOrMore", GetNumberOfRegionsOrMore);
	Nan::SetPrototypeMethod(tpl, "getNumberOfRegionsOrMore", GetNumberOfRegionsOrMore);

	Nan::SetPrototypeMethod(tpl, "GetPointsInRegion", GetPointsInRegion);
	Nan::SetPrototypeMethod(tpl, "getPointsInRegion", GetPointsInRegion);

	Nan::SetPrototypeMethod(tpl, "GetRegionContainingPoint", GetRegionContainingPoint);
	Nan::SetPrototypeMethod(tpl, "getRegionContainingPoint", GetRegionContainingPoint);

	Nan::SetPrototypeMethod(tpl, "GetTiming", GetTiming);
	Nan::SetPrototypeMethod(tpl, "getTiming", GetTiming);

	Nan::SetPrototypeMethod(tpl, "IncludeRegionBoundaryCellsOff", IncludeRegionBoundaryCellsOff);
	Nan::SetPrototypeMethod(tpl, "includeRegionBoundaryCellsOff", IncludeRegionBoundaryCellsOff);

	Nan::SetPrototypeMethod(tpl, "IncludeRegionBoundaryCellsOn", IncludeRegionBoundaryCellsOn);
	Nan::SetPrototypeMethod(tpl, "includeRegionBoundaryCellsOn", IncludeRegionBoundaryCellsOn);

	Nan::SetPrototypeMethod(tpl, "InvalidateGeometry", InvalidateGeometry);
	Nan::SetPrototypeMethod(tpl, "invalidateGeometry", InvalidateGeometry);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewGeometry", NewGeometry);
	Nan::SetPrototypeMethod(tpl, "newGeometry", NewGeometry);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "OmitNoPartitioning", OmitNoPartitioning);
	Nan::SetPrototypeMethod(tpl, "omitNoPartitioning", OmitNoPartitioning);

	Nan::SetPrototypeMethod(tpl, "OmitXPartitioning", OmitXPartitioning);
	Nan::SetPrototypeMethod(tpl, "omitXPartitioning", OmitXPartitioning);

	Nan::SetPrototypeMethod(tpl, "OmitXYPartitioning", OmitXYPartitioning);
	Nan::SetPrototypeMethod(tpl, "omitXYPartitioning", OmitXYPartitioning);

	Nan::SetPrototypeMethod(tpl, "OmitYPartitioning", OmitYPartitioning);
	Nan::SetPrototypeMethod(tpl, "omitYPartitioning", OmitYPartitioning);

	Nan::SetPrototypeMethod(tpl, "OmitYZPartitioning", OmitYZPartitioning);
	Nan::SetPrototypeMethod(tpl, "omitYZPartitioning", OmitYZPartitioning);

	Nan::SetPrototypeMethod(tpl, "OmitZPartitioning", OmitZPartitioning);
	Nan::SetPrototypeMethod(tpl, "omitZPartitioning", OmitZPartitioning);

	Nan::SetPrototypeMethod(tpl, "OmitZXPartitioning", OmitZXPartitioning);
	Nan::SetPrototypeMethod(tpl, "omitZXPartitioning", OmitZXPartitioning);

	Nan::SetPrototypeMethod(tpl, "PrintRegion", PrintRegion);
	Nan::SetPrototypeMethod(tpl, "printRegion", PrintRegion);

	Nan::SetPrototypeMethod(tpl, "PrintTree", PrintTree);
	Nan::SetPrototypeMethod(tpl, "printTree", PrintTree);

	Nan::SetPrototypeMethod(tpl, "PrintVerboseTree", PrintVerboseTree);
	Nan::SetPrototypeMethod(tpl, "printVerboseTree", PrintVerboseTree);

	Nan::SetPrototypeMethod(tpl, "RemoveAllDataSets", RemoveAllDataSets);
	Nan::SetPrototypeMethod(tpl, "removeAllDataSets", RemoveAllDataSets);

	Nan::SetPrototypeMethod(tpl, "RemoveDataSet", RemoveDataSet);
	Nan::SetPrototypeMethod(tpl, "removeDataSet", RemoveDataSet);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetCuts", SetCuts);
	Nan::SetPrototypeMethod(tpl, "setCuts", SetCuts);

	Nan::SetPrototypeMethod(tpl, "SetDataSet", SetDataSet);
	Nan::SetPrototypeMethod(tpl, "setDataSet", SetDataSet);

	Nan::SetPrototypeMethod(tpl, "SetFudgeFactor", SetFudgeFactor);
	Nan::SetPrototypeMethod(tpl, "setFudgeFactor", SetFudgeFactor);

	Nan::SetPrototypeMethod(tpl, "SetGenerateRepresentationUsingDataBounds", SetGenerateRepresentationUsingDataBounds);
	Nan::SetPrototypeMethod(tpl, "setGenerateRepresentationUsingDataBounds", SetGenerateRepresentationUsingDataBounds);

	Nan::SetPrototypeMethod(tpl, "SetIncludeRegionBoundaryCells", SetIncludeRegionBoundaryCells);
	Nan::SetPrototypeMethod(tpl, "setIncludeRegionBoundaryCells", SetIncludeRegionBoundaryCells);

	Nan::SetPrototypeMethod(tpl, "SetMinCells", SetMinCells);
	Nan::SetPrototypeMethod(tpl, "setMinCells", SetMinCells);

	Nan::SetPrototypeMethod(tpl, "SetNumberOfRegionsOrLess", SetNumberOfRegionsOrLess);
	Nan::SetPrototypeMethod(tpl, "setNumberOfRegionsOrLess", SetNumberOfRegionsOrLess);

	Nan::SetPrototypeMethod(tpl, "SetNumberOfRegionsOrMore", SetNumberOfRegionsOrMore);
	Nan::SetPrototypeMethod(tpl, "setNumberOfRegionsOrMore", SetNumberOfRegionsOrMore);

	Nan::SetPrototypeMethod(tpl, "SetTiming", SetTiming);
	Nan::SetPrototypeMethod(tpl, "setTiming", SetTiming);

	Nan::SetPrototypeMethod(tpl, "TimingOff", TimingOff);
	Nan::SetPrototypeMethod(tpl, "timingOff", TimingOff);

	Nan::SetPrototypeMethod(tpl, "TimingOn", TimingOn);
	Nan::SetPrototypeMethod(tpl, "timingOn", TimingOn);

	constructor.Reset( tpl->GetFunction() );
	ptpl.Reset( tpl );
}

void VtkKdTreeWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkKdTree> native = vtkSmartPointer<vtkKdTree>::New();
		VtkKdTreeWrap* obj = new VtkKdTreeWrap(native);		obj->Wrap(info.This());
	}
	else
	{
		Nan::Utf8String s(info[0]);
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkKdTreeWrap::AddDataSet(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataSetWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataSetWrap *a0 = ObjectWrap::Unwrap<VtkDataSetWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->AddDataSet(
			(vtkDataSet *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::BuildLocator(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BuildLocator();
}

void VtkKdTreeWrap::BuildLocatorFromPoints(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPointSetWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPointSetWrap *a0 = ObjectWrap::Unwrap<VtkPointSetWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->BuildLocatorFromPoints(
			(vtkPointSet *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::CopyTree(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkKdNodeWrap::ptpl))->HasInstance(info[0]))
	{
		VtkKdNodeWrap *a0 = ObjectWrap::Unwrap<VtkKdNodeWrap>(info[0]->ToObject());
		vtkKdNode * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->CopyTree(
			(vtkKdNode *) a0->native.GetPointer()
		);
			VtkKdNodeWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkKdNodeWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkKdNodeWrap *w = new VtkKdNodeWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::CreateCellLists(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CreateCellLists();
}

void VtkKdTreeWrap::DeleteCellLists(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DeleteCellLists();
}

void VtkKdTreeWrap::FreeSearchStructure(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FreeSearchStructure();
}

void VtkKdTreeWrap::GenerateRepresentation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkPolyDataWrap::ptpl))->HasInstance(info[1]))
		{
			VtkPolyDataWrap *a1 = ObjectWrap::Unwrap<VtkPolyDataWrap>(info[1]->ToObject());
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->GenerateRepresentation(
				info[0]->Int32Value(),
				(vtkPolyData *) a1->native.GetPointer()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::GenerateRepresentationUsingDataBoundsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateRepresentationUsingDataBoundsOff();
}

void VtkKdTreeWrap::GenerateRepresentationUsingDataBoundsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateRepresentationUsingDataBoundsOn();
}

void VtkKdTreeWrap::GetBoundaryCellList(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkIdList * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetBoundaryCellList(
			info[0]->Int32Value()
		);
			VtkIdListWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkIdListWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkIdListWrap *w = new VtkIdListWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::GetCellList(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkIdList * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetCellList(
			info[0]->Int32Value()
		);
			VtkIdListWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkIdListWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkIdListWrap *w = new VtkIdListWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkKdTreeWrap::GetCuts(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	vtkBSPCuts * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCuts();
		VtkBSPCutsWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkBSPCutsWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkBSPCutsWrap *w = new VtkBSPCutsWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkKdTreeWrap::GetDataSet(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkDataSet * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetDataSet(
			info[0]->Int32Value()
		);
			VtkDataSetWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkDataSetWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataSetWrap *w = new VtkDataSetWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkDataSet * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDataSet();
		VtkDataSetWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkDataSetWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataSetWrap *w = new VtkDataSetWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkKdTreeWrap::GetDataSetIndex(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataSetWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataSetWrap *a0 = ObjectWrap::Unwrap<VtkDataSetWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetDataSetIndex(
			(vtkDataSet *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::GetDataSets(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	vtkDataSetCollection * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDataSets();
		VtkDataSetCollectionWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkDataSetCollectionWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataSetCollectionWrap *w = new VtkDataSetCollectionWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkKdTreeWrap::GetFudgeFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFudgeFactor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::GetGenerateRepresentationUsingDataBounds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateRepresentationUsingDataBounds();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::GetIncludeRegionBoundaryCells(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIncludeRegionBoundaryCells();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::GetMinCells(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMinCells();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::GetNumberOfDataSets(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfDataSets();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::GetNumberOfRegions(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfRegions();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::GetNumberOfRegionsOrLess(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfRegionsOrLess();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::GetNumberOfRegionsOrMore(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfRegionsOrMore();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::GetPointsInRegion(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkIdTypeArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetPointsInRegion(
			info[0]->Int32Value()
		);
			VtkIdTypeArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkIdTypeArrayWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkIdTypeArrayWrap *w = new VtkIdTypeArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::GetRegionContainingPoint(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				int r;
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				r = native->GetRegionContainingPoint(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				info.GetReturnValue().Set(Nan::New(r));
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::GetTiming(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTiming();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::IncludeRegionBoundaryCellsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->IncludeRegionBoundaryCellsOff();
}

void VtkKdTreeWrap::IncludeRegionBoundaryCellsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->IncludeRegionBoundaryCellsOn();
}

void VtkKdTreeWrap::InvalidateGeometry(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->InvalidateGeometry();
}

void VtkKdTreeWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::NewGeometry(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewGeometry();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkKdTreeWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	vtkKdTree * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkKdTreeWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkKdTreeWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkKdTreeWrap *w = new VtkKdTreeWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkKdTreeWrap::OmitNoPartitioning(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OmitNoPartitioning();
}

void VtkKdTreeWrap::OmitXPartitioning(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OmitXPartitioning();
}

void VtkKdTreeWrap::OmitXYPartitioning(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OmitXYPartitioning();
}

void VtkKdTreeWrap::OmitYPartitioning(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OmitYPartitioning();
}

void VtkKdTreeWrap::OmitYZPartitioning(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OmitYZPartitioning();
}

void VtkKdTreeWrap::OmitZPartitioning(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OmitZPartitioning();
}

void VtkKdTreeWrap::OmitZXPartitioning(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OmitZXPartitioning();
}

void VtkKdTreeWrap::PrintRegion(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->PrintRegion(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::PrintTree(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PrintTree();
}

void VtkKdTreeWrap::PrintVerboseTree(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PrintVerboseTree();
}

void VtkKdTreeWrap::RemoveAllDataSets(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->RemoveAllDataSets();
}

void VtkKdTreeWrap::RemoveDataSet(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataSetWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataSetWrap *a0 = ObjectWrap::Unwrap<VtkDataSetWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->RemoveDataSet(
			(vtkDataSet *) a0->native.GetPointer()
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->RemoveDataSet(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkKdTree * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkKdTreeWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkKdTreeWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkKdTreeWrap *w = new VtkKdTreeWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetCuts(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkBSPCutsWrap::ptpl))->HasInstance(info[0]))
	{
		VtkBSPCutsWrap *a0 = ObjectWrap::Unwrap<VtkBSPCutsWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetCuts(
			(vtkBSPCuts *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetDataSet(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataSetWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataSetWrap *a0 = ObjectWrap::Unwrap<VtkDataSetWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDataSet(
			(vtkDataSet *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetFudgeFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFudgeFactor(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetGenerateRepresentationUsingDataBounds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateRepresentationUsingDataBounds(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetIncludeRegionBoundaryCells(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIncludeRegionBoundaryCells(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetMinCells(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMinCells(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetNumberOfRegionsOrLess(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetNumberOfRegionsOrLess(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetNumberOfRegionsOrMore(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetNumberOfRegionsOrMore(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::SetTiming(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTiming(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkKdTreeWrap::TimingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TimingOff();
}

void VtkKdTreeWrap::TimingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkKdTreeWrap *wrapper = ObjectWrap::Unwrap<VtkKdTreeWrap>(info.Holder());
	vtkKdTree *native = (vtkKdTree *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TimingOn();
}

