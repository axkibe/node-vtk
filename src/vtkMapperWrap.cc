/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include <vtkSmartPointer.h>
#include <vtkMapper.h>

#include "vtkAbstractMapper3DWrap.h"
#include "vtkMapperWrap.h"
#include "vtkObjectWrap.h"
#include "vtkAbstractMapperWrap.h"

using namespace v8;

Nan::Persistent<v8::Function> VtkMapperWrap::constructor;

VtkMapperWrap::VtkMapperWrap()
{ }

VtkMapperWrap::VtkMapperWrap(vtkSmartPointer<vtkMapper> _native)
{ native = _native; }

VtkMapperWrap::~VtkMapperWrap()
{ }

void VtkMapperWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::HandleScope scope;

	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	tpl->SetClassName(Nan::New("VtkMapperWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	VtkObjectBaseWrap::InitTpl(tpl);
	VtkObjectWrap::InitTpl(tpl);
	VtkAlgorithmWrap::InitTpl(tpl);
	VtkAbstractMapperWrap::InitTpl(tpl);
	VtkAbstractMapper3DWrap::InitTpl(tpl);
	InitTpl(tpl);

	constructor.Reset( tpl->GetFunction() );

	exports->Set(Nan::New("vtkMapper").ToLocalChecked(),tpl->GetFunction());
	exports->Set(Nan::New("mapper").ToLocalChecked(),tpl->GetFunction());
}

void VtkMapperWrap::InitTpl(v8::Local<v8::FunctionTemplate> tpl)
{
	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "ShallowCopy", ShallowCopy);
	Nan::SetPrototypeMethod(tpl, "shallowCopy", ShallowCopy);

	Nan::SetPrototypeMethod(tpl, "CreateDefaultLookupTable", CreateDefaultLookupTable);
	Nan::SetPrototypeMethod(tpl, "createDefaultLookupTable", CreateDefaultLookupTable);

	Nan::SetPrototypeMethod(tpl, "SetScalarVisibility", SetScalarVisibility);
	Nan::SetPrototypeMethod(tpl, "setScalarVisibility", SetScalarVisibility);

	Nan::SetPrototypeMethod(tpl, "GetScalarVisibility", GetScalarVisibility);
	Nan::SetPrototypeMethod(tpl, "getScalarVisibility", GetScalarVisibility);

	Nan::SetPrototypeMethod(tpl, "ScalarVisibilityOn", ScalarVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "scalarVisibilityOn", ScalarVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "ScalarVisibilityOff", ScalarVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "scalarVisibilityOff", ScalarVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "SetStatic", SetStatic);
	Nan::SetPrototypeMethod(tpl, "setStatic", SetStatic);

	Nan::SetPrototypeMethod(tpl, "GetStatic", GetStatic);
	Nan::SetPrototypeMethod(tpl, "getStatic", GetStatic);

	Nan::SetPrototypeMethod(tpl, "StaticOn", StaticOn);
	Nan::SetPrototypeMethod(tpl, "staticOn", StaticOn);

	Nan::SetPrototypeMethod(tpl, "StaticOff", StaticOff);
	Nan::SetPrototypeMethod(tpl, "staticOff", StaticOff);

	Nan::SetPrototypeMethod(tpl, "SetColorMode", SetColorMode);
	Nan::SetPrototypeMethod(tpl, "setColorMode", SetColorMode);

	Nan::SetPrototypeMethod(tpl, "GetColorMode", GetColorMode);
	Nan::SetPrototypeMethod(tpl, "getColorMode", GetColorMode);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToDefault", SetColorModeToDefault);
	Nan::SetPrototypeMethod(tpl, "setColorModeToDefault", SetColorModeToDefault);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToMapScalars", SetColorModeToMapScalars);
	Nan::SetPrototypeMethod(tpl, "setColorModeToMapScalars", SetColorModeToMapScalars);

	Nan::SetPrototypeMethod(tpl, "GetColorModeAsString", GetColorModeAsString);
	Nan::SetPrototypeMethod(tpl, "getColorModeAsString", GetColorModeAsString);

	Nan::SetPrototypeMethod(tpl, "SetInterpolateScalarsBeforeMapping", SetInterpolateScalarsBeforeMapping);
	Nan::SetPrototypeMethod(tpl, "setInterpolateScalarsBeforeMapping", SetInterpolateScalarsBeforeMapping);

	Nan::SetPrototypeMethod(tpl, "GetInterpolateScalarsBeforeMapping", GetInterpolateScalarsBeforeMapping);
	Nan::SetPrototypeMethod(tpl, "getInterpolateScalarsBeforeMapping", GetInterpolateScalarsBeforeMapping);

	Nan::SetPrototypeMethod(tpl, "InterpolateScalarsBeforeMappingOn", InterpolateScalarsBeforeMappingOn);
	Nan::SetPrototypeMethod(tpl, "interpolateScalarsBeforeMappingOn", InterpolateScalarsBeforeMappingOn);

	Nan::SetPrototypeMethod(tpl, "InterpolateScalarsBeforeMappingOff", InterpolateScalarsBeforeMappingOff);
	Nan::SetPrototypeMethod(tpl, "interpolateScalarsBeforeMappingOff", InterpolateScalarsBeforeMappingOff);

	Nan::SetPrototypeMethod(tpl, "SetUseLookupTableScalarRange", SetUseLookupTableScalarRange);
	Nan::SetPrototypeMethod(tpl, "setUseLookupTableScalarRange", SetUseLookupTableScalarRange);

	Nan::SetPrototypeMethod(tpl, "GetUseLookupTableScalarRange", GetUseLookupTableScalarRange);
	Nan::SetPrototypeMethod(tpl, "getUseLookupTableScalarRange", GetUseLookupTableScalarRange);

	Nan::SetPrototypeMethod(tpl, "UseLookupTableScalarRangeOn", UseLookupTableScalarRangeOn);
	Nan::SetPrototypeMethod(tpl, "useLookupTableScalarRangeOn", UseLookupTableScalarRangeOn);

	Nan::SetPrototypeMethod(tpl, "UseLookupTableScalarRangeOff", UseLookupTableScalarRangeOff);
	Nan::SetPrototypeMethod(tpl, "useLookupTableScalarRangeOff", UseLookupTableScalarRangeOff);

	Nan::SetPrototypeMethod(tpl, "SetScalarRange", SetScalarRange);
	Nan::SetPrototypeMethod(tpl, "setScalarRange", SetScalarRange);

	Nan::SetPrototypeMethod(tpl, "SetImmediateModeRendering", SetImmediateModeRendering);
	Nan::SetPrototypeMethod(tpl, "setImmediateModeRendering", SetImmediateModeRendering);

	Nan::SetPrototypeMethod(tpl, "GetImmediateModeRendering", GetImmediateModeRendering);
	Nan::SetPrototypeMethod(tpl, "getImmediateModeRendering", GetImmediateModeRendering);

	Nan::SetPrototypeMethod(tpl, "ImmediateModeRenderingOn", ImmediateModeRenderingOn);
	Nan::SetPrototypeMethod(tpl, "immediateModeRenderingOn", ImmediateModeRenderingOn);

	Nan::SetPrototypeMethod(tpl, "ImmediateModeRenderingOff", ImmediateModeRenderingOff);
	Nan::SetPrototypeMethod(tpl, "immediateModeRenderingOff", ImmediateModeRenderingOff);

	Nan::SetPrototypeMethod(tpl, "SetGlobalImmediateModeRendering", SetGlobalImmediateModeRendering);
	Nan::SetPrototypeMethod(tpl, "setGlobalImmediateModeRendering", SetGlobalImmediateModeRendering);

	Nan::SetPrototypeMethod(tpl, "GlobalImmediateModeRenderingOn", GlobalImmediateModeRenderingOn);
	Nan::SetPrototypeMethod(tpl, "globalImmediateModeRenderingOn", GlobalImmediateModeRenderingOn);

	Nan::SetPrototypeMethod(tpl, "GlobalImmediateModeRenderingOff", GlobalImmediateModeRenderingOff);
	Nan::SetPrototypeMethod(tpl, "globalImmediateModeRenderingOff", GlobalImmediateModeRenderingOff);

	Nan::SetPrototypeMethod(tpl, "GetGlobalImmediateModeRendering", GetGlobalImmediateModeRendering);
	Nan::SetPrototypeMethod(tpl, "getGlobalImmediateModeRendering", GetGlobalImmediateModeRendering);

	Nan::SetPrototypeMethod(tpl, "GetForceCompileOnly", GetForceCompileOnly);
	Nan::SetPrototypeMethod(tpl, "getForceCompileOnly", GetForceCompileOnly);

	Nan::SetPrototypeMethod(tpl, "SetForceCompileOnly", SetForceCompileOnly);
	Nan::SetPrototypeMethod(tpl, "setForceCompileOnly", SetForceCompileOnly);

	Nan::SetPrototypeMethod(tpl, "SetScalarMode", SetScalarMode);
	Nan::SetPrototypeMethod(tpl, "setScalarMode", SetScalarMode);

	Nan::SetPrototypeMethod(tpl, "GetScalarMode", GetScalarMode);
	Nan::SetPrototypeMethod(tpl, "getScalarMode", GetScalarMode);

	Nan::SetPrototypeMethod(tpl, "SetScalarModeToDefault", SetScalarModeToDefault);
	Nan::SetPrototypeMethod(tpl, "setScalarModeToDefault", SetScalarModeToDefault);

	Nan::SetPrototypeMethod(tpl, "SetScalarModeToUsePointData", SetScalarModeToUsePointData);
	Nan::SetPrototypeMethod(tpl, "setScalarModeToUsePointData", SetScalarModeToUsePointData);

	Nan::SetPrototypeMethod(tpl, "SetScalarModeToUseCellData", SetScalarModeToUseCellData);
	Nan::SetPrototypeMethod(tpl, "setScalarModeToUseCellData", SetScalarModeToUseCellData);

	Nan::SetPrototypeMethod(tpl, "SetScalarModeToUsePointFieldData", SetScalarModeToUsePointFieldData);
	Nan::SetPrototypeMethod(tpl, "setScalarModeToUsePointFieldData", SetScalarModeToUsePointFieldData);

	Nan::SetPrototypeMethod(tpl, "SetScalarModeToUseCellFieldData", SetScalarModeToUseCellFieldData);
	Nan::SetPrototypeMethod(tpl, "setScalarModeToUseCellFieldData", SetScalarModeToUseCellFieldData);

	Nan::SetPrototypeMethod(tpl, "SetScalarModeToUseFieldData", SetScalarModeToUseFieldData);
	Nan::SetPrototypeMethod(tpl, "setScalarModeToUseFieldData", SetScalarModeToUseFieldData);

	Nan::SetPrototypeMethod(tpl, "SelectColorArray", SelectColorArray);
	Nan::SetPrototypeMethod(tpl, "selectColorArray", SelectColorArray);

	Nan::SetPrototypeMethod(tpl, "SelectColorArray", SelectColorArray);
	Nan::SetPrototypeMethod(tpl, "selectColorArray", SelectColorArray);

	Nan::SetPrototypeMethod(tpl, "ColorByArrayComponent", ColorByArrayComponent);
	Nan::SetPrototypeMethod(tpl, "colorByArrayComponent", ColorByArrayComponent);

	Nan::SetPrototypeMethod(tpl, "ColorByArrayComponent", ColorByArrayComponent);
	Nan::SetPrototypeMethod(tpl, "colorByArrayComponent", ColorByArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetArrayName", GetArrayName);
	Nan::SetPrototypeMethod(tpl, "getArrayName", GetArrayName);

	Nan::SetPrototypeMethod(tpl, "GetArrayId", GetArrayId);
	Nan::SetPrototypeMethod(tpl, "getArrayId", GetArrayId);

	Nan::SetPrototypeMethod(tpl, "GetArrayAccessMode", GetArrayAccessMode);
	Nan::SetPrototypeMethod(tpl, "getArrayAccessMode", GetArrayAccessMode);

	Nan::SetPrototypeMethod(tpl, "GetArrayComponent", GetArrayComponent);
	Nan::SetPrototypeMethod(tpl, "getArrayComponent", GetArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetScalarModeAsString", GetScalarModeAsString);
	Nan::SetPrototypeMethod(tpl, "getScalarModeAsString", GetScalarModeAsString);

	Nan::SetPrototypeMethod(tpl, "SetResolveCoincidentTopology", SetResolveCoincidentTopology);
	Nan::SetPrototypeMethod(tpl, "setResolveCoincidentTopology", SetResolveCoincidentTopology);

	Nan::SetPrototypeMethod(tpl, "GetResolveCoincidentTopology", GetResolveCoincidentTopology);
	Nan::SetPrototypeMethod(tpl, "getResolveCoincidentTopology", GetResolveCoincidentTopology);

	Nan::SetPrototypeMethod(tpl, "SetResolveCoincidentTopologyToDefault", SetResolveCoincidentTopologyToDefault);
	Nan::SetPrototypeMethod(tpl, "setResolveCoincidentTopologyToDefault", SetResolveCoincidentTopologyToDefault);

	Nan::SetPrototypeMethod(tpl, "SetResolveCoincidentTopologyToOff", SetResolveCoincidentTopologyToOff);
	Nan::SetPrototypeMethod(tpl, "setResolveCoincidentTopologyToOff", SetResolveCoincidentTopologyToOff);

	Nan::SetPrototypeMethod(tpl, "SetResolveCoincidentTopologyToPolygonOffset", SetResolveCoincidentTopologyToPolygonOffset);
	Nan::SetPrototypeMethod(tpl, "setResolveCoincidentTopologyToPolygonOffset", SetResolveCoincidentTopologyToPolygonOffset);

	Nan::SetPrototypeMethod(tpl, "SetResolveCoincidentTopologyToShiftZBuffer", SetResolveCoincidentTopologyToShiftZBuffer);
	Nan::SetPrototypeMethod(tpl, "setResolveCoincidentTopologyToShiftZBuffer", SetResolveCoincidentTopologyToShiftZBuffer);

	Nan::SetPrototypeMethod(tpl, "SetResolveCoincidentTopologyPolygonOffsetParameters", SetResolveCoincidentTopologyPolygonOffsetParameters);
	Nan::SetPrototypeMethod(tpl, "setResolveCoincidentTopologyPolygonOffsetParameters", SetResolveCoincidentTopologyPolygonOffsetParameters);

	Nan::SetPrototypeMethod(tpl, "SetResolveCoincidentTopologyPolygonOffsetFaces", SetResolveCoincidentTopologyPolygonOffsetFaces);
	Nan::SetPrototypeMethod(tpl, "setResolveCoincidentTopologyPolygonOffsetFaces", SetResolveCoincidentTopologyPolygonOffsetFaces);

	Nan::SetPrototypeMethod(tpl, "GetResolveCoincidentTopologyPolygonOffsetFaces", GetResolveCoincidentTopologyPolygonOffsetFaces);
	Nan::SetPrototypeMethod(tpl, "getResolveCoincidentTopologyPolygonOffsetFaces", GetResolveCoincidentTopologyPolygonOffsetFaces);

	Nan::SetPrototypeMethod(tpl, "SetResolveCoincidentTopologyZShift", SetResolveCoincidentTopologyZShift);
	Nan::SetPrototypeMethod(tpl, "setResolveCoincidentTopologyZShift", SetResolveCoincidentTopologyZShift);

	Nan::SetPrototypeMethod(tpl, "GetResolveCoincidentTopologyZShift", GetResolveCoincidentTopologyZShift);
	Nan::SetPrototypeMethod(tpl, "getResolveCoincidentTopologyZShift", GetResolveCoincidentTopologyZShift);

	Nan::SetPrototypeMethod(tpl, "SetRenderTime", SetRenderTime);
	Nan::SetPrototypeMethod(tpl, "setRenderTime", SetRenderTime);

	Nan::SetPrototypeMethod(tpl, "GetRenderTime", GetRenderTime);
	Nan::SetPrototypeMethod(tpl, "getRenderTime", GetRenderTime);

	Nan::SetPrototypeMethod(tpl, "SetScalarMaterialMode", SetScalarMaterialMode);
	Nan::SetPrototypeMethod(tpl, "setScalarMaterialMode", SetScalarMaterialMode);

	Nan::SetPrototypeMethod(tpl, "GetScalarMaterialMode", GetScalarMaterialMode);
	Nan::SetPrototypeMethod(tpl, "getScalarMaterialMode", GetScalarMaterialMode);

	Nan::SetPrototypeMethod(tpl, "SetScalarMaterialModeToDefault", SetScalarMaterialModeToDefault);
	Nan::SetPrototypeMethod(tpl, "setScalarMaterialModeToDefault", SetScalarMaterialModeToDefault);

	Nan::SetPrototypeMethod(tpl, "SetScalarMaterialModeToAmbient", SetScalarMaterialModeToAmbient);
	Nan::SetPrototypeMethod(tpl, "setScalarMaterialModeToAmbient", SetScalarMaterialModeToAmbient);

	Nan::SetPrototypeMethod(tpl, "SetScalarMaterialModeToDiffuse", SetScalarMaterialModeToDiffuse);
	Nan::SetPrototypeMethod(tpl, "setScalarMaterialModeToDiffuse", SetScalarMaterialModeToDiffuse);

	Nan::SetPrototypeMethod(tpl, "SetScalarMaterialModeToAmbientAndDiffuse", SetScalarMaterialModeToAmbientAndDiffuse);
	Nan::SetPrototypeMethod(tpl, "setScalarMaterialModeToAmbientAndDiffuse", SetScalarMaterialModeToAmbientAndDiffuse);

	Nan::SetPrototypeMethod(tpl, "GetScalarMaterialModeAsString", GetScalarMaterialModeAsString);
	Nan::SetPrototypeMethod(tpl, "getScalarMaterialModeAsString", GetScalarMaterialModeAsString);

}

void VtkMapperWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		Nan::ThrowError("Cannot create instance of abstract class.");
		return;
	}
	else
	{
		Nan::Utf8String s(info[0]);
		if(strcmp(*s, "__nowrap" ))
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkMapperWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkMapperWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	vtkMapper * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	const int argc = 1;
	v8::Local<v8::Value> argv[argc] =
		{ Nan::New("__nowrap").ToLocalChecked() };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkMapperWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(argc, argv);
	VtkMapperWrap *w = new VtkMapperWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkMapperWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject())
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkMapper * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
		const int argc = 1;
		v8::Local<v8::Value> argv[argc] =
			{ Nan::New("__nowrap").ToLocalChecked() };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkMapperWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(argc, argv);
		VtkMapperWrap *w = new VtkMapperWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::ShallowCopy(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject())
	{
		VtkAbstractMapperWrap *a0 = ObjectWrap::Unwrap<VtkAbstractMapperWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->ShallowCopy(
			(vtkAbstractMapper *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::CreateDefaultLookupTable(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CreateDefaultLookupTable();
}

void VtkMapperWrap::SetScalarVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScalarVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetScalarVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalarVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::ScalarVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ScalarVisibilityOn();
}

void VtkMapperWrap::ScalarVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ScalarVisibilityOff();
}

void VtkMapperWrap::SetStatic(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStatic(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetStatic(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStatic();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::StaticOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StaticOn();
}

void VtkMapperWrap::StaticOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StaticOff();
}

void VtkMapperWrap::SetColorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetColorMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetColorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::SetColorModeToDefault(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToDefault();
}

void VtkMapperWrap::SetColorModeToMapScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToMapScalars();
}

void VtkMapperWrap::GetColorModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkMapperWrap::SetInterpolateScalarsBeforeMapping(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInterpolateScalarsBeforeMapping(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetInterpolateScalarsBeforeMapping(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInterpolateScalarsBeforeMapping();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::InterpolateScalarsBeforeMappingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->InterpolateScalarsBeforeMappingOn();
}

void VtkMapperWrap::InterpolateScalarsBeforeMappingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->InterpolateScalarsBeforeMappingOff();
}

void VtkMapperWrap::SetUseLookupTableScalarRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseLookupTableScalarRange(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetUseLookupTableScalarRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseLookupTableScalarRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::UseLookupTableScalarRangeOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseLookupTableScalarRangeOn();
}

void VtkMapperWrap::UseLookupTableScalarRangeOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseLookupTableScalarRangeOff();
}

void VtkMapperWrap::SetScalarRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetScalarRange(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::SetImmediateModeRendering(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetImmediateModeRendering(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetImmediateModeRendering(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetImmediateModeRendering();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::ImmediateModeRenderingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ImmediateModeRenderingOn();
}

void VtkMapperWrap::ImmediateModeRenderingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ImmediateModeRenderingOff();
}

void VtkMapperWrap::SetGlobalImmediateModeRendering(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGlobalImmediateModeRendering(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GlobalImmediateModeRenderingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GlobalImmediateModeRenderingOn();
}

void VtkMapperWrap::GlobalImmediateModeRenderingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GlobalImmediateModeRenderingOff();
}

void VtkMapperWrap::GetGlobalImmediateModeRendering(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGlobalImmediateModeRendering();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::GetForceCompileOnly(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetForceCompileOnly();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::SetForceCompileOnly(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetForceCompileOnly(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::SetScalarMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScalarMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetScalarMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalarMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::SetScalarModeToDefault(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarModeToDefault();
}

void VtkMapperWrap::SetScalarModeToUsePointData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarModeToUsePointData();
}

void VtkMapperWrap::SetScalarModeToUseCellData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarModeToUseCellData();
}

void VtkMapperWrap::SetScalarModeToUsePointFieldData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarModeToUsePointFieldData();
}

void VtkMapperWrap::SetScalarModeToUseCellFieldData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarModeToUseCellFieldData();
}

void VtkMapperWrap::SetScalarModeToUseFieldData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarModeToUseFieldData();
}

void VtkMapperWrap::SelectColorArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SelectColorArray(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::ColorByArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->ColorByArrayComponent(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkMapperWrap::GetArrayId(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetArrayId();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::GetArrayAccessMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetArrayAccessMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::GetArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetArrayComponent();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::GetScalarModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalarModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkMapperWrap::SetResolveCoincidentTopology(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResolveCoincidentTopology(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetResolveCoincidentTopology(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetResolveCoincidentTopology();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::SetResolveCoincidentTopologyToDefault(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetResolveCoincidentTopologyToDefault();
}

void VtkMapperWrap::SetResolveCoincidentTopologyToOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetResolveCoincidentTopologyToOff();
}

void VtkMapperWrap::SetResolveCoincidentTopologyToPolygonOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetResolveCoincidentTopologyToPolygonOffset();
}

void VtkMapperWrap::SetResolveCoincidentTopologyToShiftZBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetResolveCoincidentTopologyToShiftZBuffer();
}

void VtkMapperWrap::SetResolveCoincidentTopologyPolygonOffsetParameters(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetResolveCoincidentTopologyPolygonOffsetParameters(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::SetResolveCoincidentTopologyPolygonOffsetFaces(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResolveCoincidentTopologyPolygonOffsetFaces(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetResolveCoincidentTopologyPolygonOffsetFaces(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetResolveCoincidentTopologyPolygonOffsetFaces();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::SetResolveCoincidentTopologyZShift(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResolveCoincidentTopologyZShift(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetResolveCoincidentTopologyZShift(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetResolveCoincidentTopologyZShift();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::SetRenderTime(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetRenderTime(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetRenderTime(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRenderTime();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::SetScalarMaterialMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScalarMaterialMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkMapperWrap::GetScalarMaterialMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalarMaterialMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkMapperWrap::SetScalarMaterialModeToDefault(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarMaterialModeToDefault();
}

void VtkMapperWrap::SetScalarMaterialModeToAmbient(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarMaterialModeToAmbient();
}

void VtkMapperWrap::SetScalarMaterialModeToDiffuse(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarMaterialModeToDiffuse();
}

void VtkMapperWrap::SetScalarMaterialModeToAmbientAndDiffuse(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScalarMaterialModeToAmbientAndDiffuse();
}

void VtkMapperWrap::GetScalarMaterialModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkMapperWrap *wrapper = ObjectWrap::Unwrap<VtkMapperWrap>(info.Holder());
	vtkMapper *native = (vtkMapper *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalarMaterialModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

