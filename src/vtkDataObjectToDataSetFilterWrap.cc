/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkDataSetAlgorithmWrap.h"
#include "vtkDataObjectToDataSetFilterWrap.h"
#include "vtkObjectWrap.h"
#include "vtkDataObjectWrap.h"
#include "vtkDataSetWrap.h"
#include "vtkPolyDataWrap.h"
#include "vtkStructuredPointsWrap.h"
#include "vtkStructuredGridWrap.h"
#include "vtkUnstructuredGridWrap.h"
#include "vtkRectilinearGridWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::Function> VtkDataObjectToDataSetFilterWrap::constructor;
Nan::Persistent<v8::FunctionTemplate> VtkDataObjectToDataSetFilterWrap::ptpl;

VtkDataObjectToDataSetFilterWrap::VtkDataObjectToDataSetFilterWrap()
{ }

VtkDataObjectToDataSetFilterWrap::VtkDataObjectToDataSetFilterWrap(vtkSmartPointer<vtkDataObjectToDataSetFilter> _native)
{ native = _native; }

VtkDataObjectToDataSetFilterWrap::~VtkDataObjectToDataSetFilterWrap()
{ }

void VtkDataObjectToDataSetFilterWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkDataObjectToDataSetFilter").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("DataObjectToDataSetFilter").ToLocalChecked(), ConstructorGetter);
}

void VtkDataObjectToDataSetFilterWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkDataObjectToDataSetFilterWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkDataSetAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkDataSetAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkDataObjectToDataSetFilterWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "DefaultNormalizeOff", DefaultNormalizeOff);
	Nan::SetPrototypeMethod(tpl, "defaultNormalizeOff", DefaultNormalizeOff);

	Nan::SetPrototypeMethod(tpl, "DefaultNormalizeOn", DefaultNormalizeOn);
	Nan::SetPrototypeMethod(tpl, "defaultNormalizeOn", DefaultNormalizeOn);

	Nan::SetPrototypeMethod(tpl, "GetCellConnectivityComponentArrayComponent", GetCellConnectivityComponentArrayComponent);
	Nan::SetPrototypeMethod(tpl, "getCellConnectivityComponentArrayComponent", GetCellConnectivityComponentArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetCellConnectivityComponentArrayName", GetCellConnectivityComponentArrayName);
	Nan::SetPrototypeMethod(tpl, "getCellConnectivityComponentArrayName", GetCellConnectivityComponentArrayName);

	Nan::SetPrototypeMethod(tpl, "GetCellConnectivityComponentMaxRange", GetCellConnectivityComponentMaxRange);
	Nan::SetPrototypeMethod(tpl, "getCellConnectivityComponentMaxRange", GetCellConnectivityComponentMaxRange);

	Nan::SetPrototypeMethod(tpl, "GetCellConnectivityComponentMinRange", GetCellConnectivityComponentMinRange);
	Nan::SetPrototypeMethod(tpl, "getCellConnectivityComponentMinRange", GetCellConnectivityComponentMinRange);

	Nan::SetPrototypeMethod(tpl, "GetCellTypeComponentArrayComponent", GetCellTypeComponentArrayComponent);
	Nan::SetPrototypeMethod(tpl, "getCellTypeComponentArrayComponent", GetCellTypeComponentArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetCellTypeComponentArrayName", GetCellTypeComponentArrayName);
	Nan::SetPrototypeMethod(tpl, "getCellTypeComponentArrayName", GetCellTypeComponentArrayName);

	Nan::SetPrototypeMethod(tpl, "GetCellTypeComponentMaxRange", GetCellTypeComponentMaxRange);
	Nan::SetPrototypeMethod(tpl, "getCellTypeComponentMaxRange", GetCellTypeComponentMaxRange);

	Nan::SetPrototypeMethod(tpl, "GetCellTypeComponentMinRange", GetCellTypeComponentMinRange);
	Nan::SetPrototypeMethod(tpl, "getCellTypeComponentMinRange", GetCellTypeComponentMinRange);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetDataSetType", GetDataSetType);
	Nan::SetPrototypeMethod(tpl, "getDataSetType", GetDataSetType);

	Nan::SetPrototypeMethod(tpl, "GetDefaultNormalize", GetDefaultNormalize);
	Nan::SetPrototypeMethod(tpl, "getDefaultNormalize", GetDefaultNormalize);

	Nan::SetPrototypeMethod(tpl, "GetInput", GetInput);
	Nan::SetPrototypeMethod(tpl, "getInput", GetInput);

	Nan::SetPrototypeMethod(tpl, "GetLinesComponentArrayComponent", GetLinesComponentArrayComponent);
	Nan::SetPrototypeMethod(tpl, "getLinesComponentArrayComponent", GetLinesComponentArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetLinesComponentArrayName", GetLinesComponentArrayName);
	Nan::SetPrototypeMethod(tpl, "getLinesComponentArrayName", GetLinesComponentArrayName);

	Nan::SetPrototypeMethod(tpl, "GetLinesComponentMaxRange", GetLinesComponentMaxRange);
	Nan::SetPrototypeMethod(tpl, "getLinesComponentMaxRange", GetLinesComponentMaxRange);

	Nan::SetPrototypeMethod(tpl, "GetLinesComponentMinRange", GetLinesComponentMinRange);
	Nan::SetPrototypeMethod(tpl, "getLinesComponentMinRange", GetLinesComponentMinRange);

	Nan::SetPrototypeMethod(tpl, "GetOutput", GetOutput);
	Nan::SetPrototypeMethod(tpl, "getOutput", GetOutput);

	Nan::SetPrototypeMethod(tpl, "GetPointComponentArrayComponent", GetPointComponentArrayComponent);
	Nan::SetPrototypeMethod(tpl, "getPointComponentArrayComponent", GetPointComponentArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetPointComponentArrayName", GetPointComponentArrayName);
	Nan::SetPrototypeMethod(tpl, "getPointComponentArrayName", GetPointComponentArrayName);

	Nan::SetPrototypeMethod(tpl, "GetPointComponentMaxRange", GetPointComponentMaxRange);
	Nan::SetPrototypeMethod(tpl, "getPointComponentMaxRange", GetPointComponentMaxRange);

	Nan::SetPrototypeMethod(tpl, "GetPointComponentMinRange", GetPointComponentMinRange);
	Nan::SetPrototypeMethod(tpl, "getPointComponentMinRange", GetPointComponentMinRange);

	Nan::SetPrototypeMethod(tpl, "GetPointComponentNormailzeFlag", GetPointComponentNormailzeFlag);
	Nan::SetPrototypeMethod(tpl, "getPointComponentNormailzeFlag", GetPointComponentNormailzeFlag);

	Nan::SetPrototypeMethod(tpl, "GetPolyDataOutput", GetPolyDataOutput);
	Nan::SetPrototypeMethod(tpl, "getPolyDataOutput", GetPolyDataOutput);

	Nan::SetPrototypeMethod(tpl, "GetPolysComponentArrayComponent", GetPolysComponentArrayComponent);
	Nan::SetPrototypeMethod(tpl, "getPolysComponentArrayComponent", GetPolysComponentArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetPolysComponentArrayName", GetPolysComponentArrayName);
	Nan::SetPrototypeMethod(tpl, "getPolysComponentArrayName", GetPolysComponentArrayName);

	Nan::SetPrototypeMethod(tpl, "GetPolysComponentMaxRange", GetPolysComponentMaxRange);
	Nan::SetPrototypeMethod(tpl, "getPolysComponentMaxRange", GetPolysComponentMaxRange);

	Nan::SetPrototypeMethod(tpl, "GetPolysComponentMinRange", GetPolysComponentMinRange);
	Nan::SetPrototypeMethod(tpl, "getPolysComponentMinRange", GetPolysComponentMinRange);

	Nan::SetPrototypeMethod(tpl, "GetRectilinearGridOutput", GetRectilinearGridOutput);
	Nan::SetPrototypeMethod(tpl, "getRectilinearGridOutput", GetRectilinearGridOutput);

	Nan::SetPrototypeMethod(tpl, "GetStripsComponentArrayComponent", GetStripsComponentArrayComponent);
	Nan::SetPrototypeMethod(tpl, "getStripsComponentArrayComponent", GetStripsComponentArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetStripsComponentArrayName", GetStripsComponentArrayName);
	Nan::SetPrototypeMethod(tpl, "getStripsComponentArrayName", GetStripsComponentArrayName);

	Nan::SetPrototypeMethod(tpl, "GetStripsComponentMaxRange", GetStripsComponentMaxRange);
	Nan::SetPrototypeMethod(tpl, "getStripsComponentMaxRange", GetStripsComponentMaxRange);

	Nan::SetPrototypeMethod(tpl, "GetStripsComponentMinRange", GetStripsComponentMinRange);
	Nan::SetPrototypeMethod(tpl, "getStripsComponentMinRange", GetStripsComponentMinRange);

	Nan::SetPrototypeMethod(tpl, "GetStructuredGridOutput", GetStructuredGridOutput);
	Nan::SetPrototypeMethod(tpl, "getStructuredGridOutput", GetStructuredGridOutput);

	Nan::SetPrototypeMethod(tpl, "GetStructuredPointsOutput", GetStructuredPointsOutput);
	Nan::SetPrototypeMethod(tpl, "getStructuredPointsOutput", GetStructuredPointsOutput);

	Nan::SetPrototypeMethod(tpl, "GetUnstructuredGridOutput", GetUnstructuredGridOutput);
	Nan::SetPrototypeMethod(tpl, "getUnstructuredGridOutput", GetUnstructuredGridOutput);

	Nan::SetPrototypeMethod(tpl, "GetVertsComponentArrayComponent", GetVertsComponentArrayComponent);
	Nan::SetPrototypeMethod(tpl, "getVertsComponentArrayComponent", GetVertsComponentArrayComponent);

	Nan::SetPrototypeMethod(tpl, "GetVertsComponentArrayName", GetVertsComponentArrayName);
	Nan::SetPrototypeMethod(tpl, "getVertsComponentArrayName", GetVertsComponentArrayName);

	Nan::SetPrototypeMethod(tpl, "GetVertsComponentMaxRange", GetVertsComponentMaxRange);
	Nan::SetPrototypeMethod(tpl, "getVertsComponentMaxRange", GetVertsComponentMaxRange);

	Nan::SetPrototypeMethod(tpl, "GetVertsComponentMinRange", GetVertsComponentMinRange);
	Nan::SetPrototypeMethod(tpl, "getVertsComponentMinRange", GetVertsComponentMinRange);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetCellConnectivityComponent", SetCellConnectivityComponent);
	Nan::SetPrototypeMethod(tpl, "setCellConnectivityComponent", SetCellConnectivityComponent);

	Nan::SetPrototypeMethod(tpl, "SetCellTypeComponent", SetCellTypeComponent);
	Nan::SetPrototypeMethod(tpl, "setCellTypeComponent", SetCellTypeComponent);

	Nan::SetPrototypeMethod(tpl, "SetDataSetType", SetDataSetType);
	Nan::SetPrototypeMethod(tpl, "setDataSetType", SetDataSetType);

	Nan::SetPrototypeMethod(tpl, "SetDataSetTypeToPolyData", SetDataSetTypeToPolyData);
	Nan::SetPrototypeMethod(tpl, "setDataSetTypeToPolyData", SetDataSetTypeToPolyData);

	Nan::SetPrototypeMethod(tpl, "SetDataSetTypeToRectilinearGrid", SetDataSetTypeToRectilinearGrid);
	Nan::SetPrototypeMethod(tpl, "setDataSetTypeToRectilinearGrid", SetDataSetTypeToRectilinearGrid);

	Nan::SetPrototypeMethod(tpl, "SetDataSetTypeToStructuredGrid", SetDataSetTypeToStructuredGrid);
	Nan::SetPrototypeMethod(tpl, "setDataSetTypeToStructuredGrid", SetDataSetTypeToStructuredGrid);

	Nan::SetPrototypeMethod(tpl, "SetDataSetTypeToStructuredPoints", SetDataSetTypeToStructuredPoints);
	Nan::SetPrototypeMethod(tpl, "setDataSetTypeToStructuredPoints", SetDataSetTypeToStructuredPoints);

	Nan::SetPrototypeMethod(tpl, "SetDataSetTypeToUnstructuredGrid", SetDataSetTypeToUnstructuredGrid);
	Nan::SetPrototypeMethod(tpl, "setDataSetTypeToUnstructuredGrid", SetDataSetTypeToUnstructuredGrid);

	Nan::SetPrototypeMethod(tpl, "SetDefaultNormalize", SetDefaultNormalize);
	Nan::SetPrototypeMethod(tpl, "setDefaultNormalize", SetDefaultNormalize);

	Nan::SetPrototypeMethod(tpl, "SetDimensions", SetDimensions);
	Nan::SetPrototypeMethod(tpl, "setDimensions", SetDimensions);

	Nan::SetPrototypeMethod(tpl, "SetDimensionsComponent", SetDimensionsComponent);
	Nan::SetPrototypeMethod(tpl, "setDimensionsComponent", SetDimensionsComponent);

	Nan::SetPrototypeMethod(tpl, "SetLinesComponent", SetLinesComponent);
	Nan::SetPrototypeMethod(tpl, "setLinesComponent", SetLinesComponent);

	Nan::SetPrototypeMethod(tpl, "SetOrigin", SetOrigin);
	Nan::SetPrototypeMethod(tpl, "setOrigin", SetOrigin);

	Nan::SetPrototypeMethod(tpl, "SetOriginComponent", SetOriginComponent);
	Nan::SetPrototypeMethod(tpl, "setOriginComponent", SetOriginComponent);

	Nan::SetPrototypeMethod(tpl, "SetPointComponent", SetPointComponent);
	Nan::SetPrototypeMethod(tpl, "setPointComponent", SetPointComponent);

	Nan::SetPrototypeMethod(tpl, "SetPolysComponent", SetPolysComponent);
	Nan::SetPrototypeMethod(tpl, "setPolysComponent", SetPolysComponent);

	Nan::SetPrototypeMethod(tpl, "SetSpacing", SetSpacing);
	Nan::SetPrototypeMethod(tpl, "setSpacing", SetSpacing);

	Nan::SetPrototypeMethod(tpl, "SetSpacingComponent", SetSpacingComponent);
	Nan::SetPrototypeMethod(tpl, "setSpacingComponent", SetSpacingComponent);

	Nan::SetPrototypeMethod(tpl, "SetStripsComponent", SetStripsComponent);
	Nan::SetPrototypeMethod(tpl, "setStripsComponent", SetStripsComponent);

	Nan::SetPrototypeMethod(tpl, "SetVertsComponent", SetVertsComponent);
	Nan::SetPrototypeMethod(tpl, "setVertsComponent", SetVertsComponent);

	constructor.Reset( tpl->GetFunction() );
	ptpl.Reset( tpl );
}

void VtkDataObjectToDataSetFilterWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkDataObjectToDataSetFilter> native = vtkSmartPointer<vtkDataObjectToDataSetFilter>::New();
		VtkDataObjectToDataSetFilterWrap* obj = new VtkDataObjectToDataSetFilterWrap(native);		obj->Wrap(info.This());
	}
	else
	{
		Nan::Utf8String s(info[0]);
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkDataObjectToDataSetFilterWrap::DefaultNormalizeOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DefaultNormalizeOff();
}

void VtkDataObjectToDataSetFilterWrap::DefaultNormalizeOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DefaultNormalizeOn();
}

void VtkDataObjectToDataSetFilterWrap::GetCellConnectivityComponentArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellConnectivityComponentArrayComponent();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetCellConnectivityComponentArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellConnectivityComponentArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataObjectToDataSetFilterWrap::GetCellConnectivityComponentMaxRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellConnectivityComponentMaxRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetCellConnectivityComponentMinRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellConnectivityComponentMinRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetCellTypeComponentArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellTypeComponentArrayComponent();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetCellTypeComponentArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellTypeComponentArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataObjectToDataSetFilterWrap::GetCellTypeComponentMaxRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellTypeComponentMaxRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetCellTypeComponentMinRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellTypeComponentMinRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataObjectToDataSetFilterWrap::GetDataSetType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDataSetType();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetDefaultNormalize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDefaultNormalize();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetInput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	vtkDataObject * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInput();
		VtkDataObjectWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkDataObjectWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataObjectWrap *w = new VtkDataObjectWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataObjectToDataSetFilterWrap::GetLinesComponentArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLinesComponentArrayComponent();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetLinesComponentArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLinesComponentArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataObjectToDataSetFilterWrap::GetLinesComponentMaxRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLinesComponentMaxRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetLinesComponentMinRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLinesComponentMinRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkDataSet * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetOutput(
			info[0]->Int32Value()
		);
			VtkDataSetWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkDataSetWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataSetWrap *w = new VtkDataSetWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkDataSet * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOutput();
		VtkDataSetWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkDataSetWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataSetWrap *w = new VtkDataSetWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataObjectToDataSetFilterWrap::GetPointComponentArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetPointComponentArrayComponent(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::GetPointComponentArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetPointComponentArrayName(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::GetPointComponentMaxRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetPointComponentMaxRange(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::GetPointComponentMinRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetPointComponentMinRange(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::GetPointComponentNormailzeFlag(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetPointComponentNormailzeFlag(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::GetPolyDataOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	vtkPolyData * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPolyDataOutput();
		VtkPolyDataWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkPolyDataWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPolyDataWrap *w = new VtkPolyDataWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataObjectToDataSetFilterWrap::GetPolysComponentArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPolysComponentArrayComponent();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetPolysComponentArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPolysComponentArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataObjectToDataSetFilterWrap::GetPolysComponentMaxRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPolysComponentMaxRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetPolysComponentMinRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPolysComponentMinRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetRectilinearGridOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	vtkRectilinearGrid * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRectilinearGridOutput();
		VtkRectilinearGridWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkRectilinearGridWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkRectilinearGridWrap *w = new VtkRectilinearGridWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataObjectToDataSetFilterWrap::GetStripsComponentArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStripsComponentArrayComponent();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetStripsComponentArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStripsComponentArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataObjectToDataSetFilterWrap::GetStripsComponentMaxRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStripsComponentMaxRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetStripsComponentMinRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStripsComponentMinRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetStructuredGridOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	vtkStructuredGrid * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStructuredGridOutput();
		VtkStructuredGridWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkStructuredGridWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkStructuredGridWrap *w = new VtkStructuredGridWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataObjectToDataSetFilterWrap::GetStructuredPointsOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	vtkStructuredPoints * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStructuredPointsOutput();
		VtkStructuredPointsWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkStructuredPointsWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkStructuredPointsWrap *w = new VtkStructuredPointsWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataObjectToDataSetFilterWrap::GetUnstructuredGridOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	vtkUnstructuredGrid * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUnstructuredGridOutput();
		VtkUnstructuredGridWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkUnstructuredGridWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkUnstructuredGridWrap *w = new VtkUnstructuredGridWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataObjectToDataSetFilterWrap::GetVertsComponentArrayComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVertsComponentArrayComponent();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetVertsComponentArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVertsComponentArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataObjectToDataSetFilterWrap::GetVertsComponentMaxRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVertsComponentMaxRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::GetVertsComponentMinRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVertsComponentMinRange();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataObjectToDataSetFilterWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	vtkDataObjectToDataSetFilter * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkDataObjectToDataSetFilterWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkDataObjectToDataSetFilterWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataObjectToDataSetFilterWrap *w = new VtkDataObjectToDataSetFilterWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataObjectToDataSetFilterWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkDataObjectToDataSetFilter * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkDataObjectToDataSetFilterWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkDataObjectToDataSetFilterWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataObjectToDataSetFilterWrap *w = new VtkDataObjectToDataSetFilterWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetCellConnectivityComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetCellConnectivityComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCellConnectivityComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetCellTypeComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetCellTypeComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCellTypeComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetDataSetType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDataSetType(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetDataSetTypeToPolyData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataSetTypeToPolyData();
}

void VtkDataObjectToDataSetFilterWrap::SetDataSetTypeToRectilinearGrid(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataSetTypeToRectilinearGrid();
}

void VtkDataObjectToDataSetFilterWrap::SetDataSetTypeToStructuredGrid(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataSetTypeToStructuredGrid();
}

void VtkDataObjectToDataSetFilterWrap::SetDataSetTypeToStructuredPoints(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataSetTypeToStructuredPoints();
}

void VtkDataObjectToDataSetFilterWrap::SetDataSetTypeToUnstructuredGrid(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataSetTypeToUnstructuredGrid();
}

void VtkDataObjectToDataSetFilterWrap::SetDefaultNormalize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDefaultNormalize(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetDimensions(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetDimensions(
					info[0]->Int32Value(),
					info[1]->Int32Value(),
					info[2]->Int32Value()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetDimensionsComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetDimensionsComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetDimensionsComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetLinesComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetLinesComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetLinesComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetOrigin(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetOriginComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetOriginComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetOriginComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetPointComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			Nan::Utf8String a1(info[1]);
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() > 4 && info[4]->IsInt32())
					{
						if(info.Length() > 5 && info[5]->IsInt32())
						{
							if(info.Length() != 6)
							{
								Nan::ThrowError("Too many parameters.");
								return;
							}
							native->SetPointComponent(
								info[0]->Int32Value(),
								*a1,
								info[2]->Int32Value(),
								info[3]->Int32Value(),
								info[4]->Int32Value(),
								info[5]->Int32Value()
							);
							return;
						}
					}
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetPointComponent(
					info[0]->Int32Value(),
					*a1,
					info[2]->Int32Value()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetPolysComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetPolysComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetPolysComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetSpacing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetSpacing(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetSpacingComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetSpacingComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetSpacingComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetStripsComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetStripsComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetStripsComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataObjectToDataSetFilterWrap::SetVertsComponent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataObjectToDataSetFilterWrap *wrapper = ObjectWrap::Unwrap<VtkDataObjectToDataSetFilterWrap>(info.Holder());
	vtkDataObjectToDataSetFilter *native = (vtkDataObjectToDataSetFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetVertsComponent(
						*a0,
						info[1]->Int32Value(),
						info[2]->Int32Value(),
						info[3]->Int32Value()
					);
					return;
				}
			}
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetVertsComponent(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

