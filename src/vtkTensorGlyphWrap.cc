/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkPolyDataAlgorithmWrap.h"
#include "vtkTensorGlyphWrap.h"
#include "vtkObjectWrap.h"
#include "vtkPolyDataWrap.h"
#include "vtkAlgorithmOutputWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::Function> VtkTensorGlyphWrap::constructor;
Nan::Persistent<v8::FunctionTemplate> VtkTensorGlyphWrap::ptpl;

VtkTensorGlyphWrap::VtkTensorGlyphWrap()
{ }

VtkTensorGlyphWrap::VtkTensorGlyphWrap(vtkSmartPointer<vtkTensorGlyph> _native)
{ native = _native; }

VtkTensorGlyphWrap::~VtkTensorGlyphWrap()
{ }

void VtkTensorGlyphWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkTensorGlyph").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("TensorGlyph").ToLocalChecked(), ConstructorGetter);
}

void VtkTensorGlyphWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkTensorGlyphWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkPolyDataAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkPolyDataAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkTensorGlyphWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "ClampScalingOff", ClampScalingOff);
	Nan::SetPrototypeMethod(tpl, "clampScalingOff", ClampScalingOff);

	Nan::SetPrototypeMethod(tpl, "ClampScalingOn", ClampScalingOn);
	Nan::SetPrototypeMethod(tpl, "clampScalingOn", ClampScalingOn);

	Nan::SetPrototypeMethod(tpl, "ColorGlyphsOff", ColorGlyphsOff);
	Nan::SetPrototypeMethod(tpl, "colorGlyphsOff", ColorGlyphsOff);

	Nan::SetPrototypeMethod(tpl, "ColorGlyphsOn", ColorGlyphsOn);
	Nan::SetPrototypeMethod(tpl, "colorGlyphsOn", ColorGlyphsOn);

	Nan::SetPrototypeMethod(tpl, "ExtractEigenvaluesOff", ExtractEigenvaluesOff);
	Nan::SetPrototypeMethod(tpl, "extractEigenvaluesOff", ExtractEigenvaluesOff);

	Nan::SetPrototypeMethod(tpl, "ExtractEigenvaluesOn", ExtractEigenvaluesOn);
	Nan::SetPrototypeMethod(tpl, "extractEigenvaluesOn", ExtractEigenvaluesOn);

	Nan::SetPrototypeMethod(tpl, "GetClampScaling", GetClampScaling);
	Nan::SetPrototypeMethod(tpl, "getClampScaling", GetClampScaling);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetColorGlyphs", GetColorGlyphs);
	Nan::SetPrototypeMethod(tpl, "getColorGlyphs", GetColorGlyphs);

	Nan::SetPrototypeMethod(tpl, "GetColorMode", GetColorMode);
	Nan::SetPrototypeMethod(tpl, "getColorMode", GetColorMode);

	Nan::SetPrototypeMethod(tpl, "GetColorModeMaxValue", GetColorModeMaxValue);
	Nan::SetPrototypeMethod(tpl, "getColorModeMaxValue", GetColorModeMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetColorModeMinValue", GetColorModeMinValue);
	Nan::SetPrototypeMethod(tpl, "getColorModeMinValue", GetColorModeMinValue);

	Nan::SetPrototypeMethod(tpl, "GetExtractEigenvalues", GetExtractEigenvalues);
	Nan::SetPrototypeMethod(tpl, "getExtractEigenvalues", GetExtractEigenvalues);

	Nan::SetPrototypeMethod(tpl, "GetLength", GetLength);
	Nan::SetPrototypeMethod(tpl, "getLength", GetLength);

	Nan::SetPrototypeMethod(tpl, "GetMaxScaleFactor", GetMaxScaleFactor);
	Nan::SetPrototypeMethod(tpl, "getMaxScaleFactor", GetMaxScaleFactor);

	Nan::SetPrototypeMethod(tpl, "GetScaleFactor", GetScaleFactor);
	Nan::SetPrototypeMethod(tpl, "getScaleFactor", GetScaleFactor);

	Nan::SetPrototypeMethod(tpl, "GetScaling", GetScaling);
	Nan::SetPrototypeMethod(tpl, "getScaling", GetScaling);

	Nan::SetPrototypeMethod(tpl, "GetSource", GetSource);
	Nan::SetPrototypeMethod(tpl, "getSource", GetSource);

	Nan::SetPrototypeMethod(tpl, "GetSymmetric", GetSymmetric);
	Nan::SetPrototypeMethod(tpl, "getSymmetric", GetSymmetric);

	Nan::SetPrototypeMethod(tpl, "GetThreeGlyphs", GetThreeGlyphs);
	Nan::SetPrototypeMethod(tpl, "getThreeGlyphs", GetThreeGlyphs);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "ScalingOff", ScalingOff);
	Nan::SetPrototypeMethod(tpl, "scalingOff", ScalingOff);

	Nan::SetPrototypeMethod(tpl, "ScalingOn", ScalingOn);
	Nan::SetPrototypeMethod(tpl, "scalingOn", ScalingOn);

	Nan::SetPrototypeMethod(tpl, "SetClampScaling", SetClampScaling);
	Nan::SetPrototypeMethod(tpl, "setClampScaling", SetClampScaling);

	Nan::SetPrototypeMethod(tpl, "SetColorGlyphs", SetColorGlyphs);
	Nan::SetPrototypeMethod(tpl, "setColorGlyphs", SetColorGlyphs);

	Nan::SetPrototypeMethod(tpl, "SetColorMode", SetColorMode);
	Nan::SetPrototypeMethod(tpl, "setColorMode", SetColorMode);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToEigenvalues", SetColorModeToEigenvalues);
	Nan::SetPrototypeMethod(tpl, "setColorModeToEigenvalues", SetColorModeToEigenvalues);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToScalars", SetColorModeToScalars);
	Nan::SetPrototypeMethod(tpl, "setColorModeToScalars", SetColorModeToScalars);

	Nan::SetPrototypeMethod(tpl, "SetExtractEigenvalues", SetExtractEigenvalues);
	Nan::SetPrototypeMethod(tpl, "setExtractEigenvalues", SetExtractEigenvalues);

	Nan::SetPrototypeMethod(tpl, "SetLength", SetLength);
	Nan::SetPrototypeMethod(tpl, "setLength", SetLength);

	Nan::SetPrototypeMethod(tpl, "SetMaxScaleFactor", SetMaxScaleFactor);
	Nan::SetPrototypeMethod(tpl, "setMaxScaleFactor", SetMaxScaleFactor);

	Nan::SetPrototypeMethod(tpl, "SetScaleFactor", SetScaleFactor);
	Nan::SetPrototypeMethod(tpl, "setScaleFactor", SetScaleFactor);

	Nan::SetPrototypeMethod(tpl, "SetScaling", SetScaling);
	Nan::SetPrototypeMethod(tpl, "setScaling", SetScaling);

	Nan::SetPrototypeMethod(tpl, "SetSourceConnection", SetSourceConnection);
	Nan::SetPrototypeMethod(tpl, "setSourceConnection", SetSourceConnection);

	Nan::SetPrototypeMethod(tpl, "SetSourceData", SetSourceData);
	Nan::SetPrototypeMethod(tpl, "setSourceData", SetSourceData);

	Nan::SetPrototypeMethod(tpl, "SetSymmetric", SetSymmetric);
	Nan::SetPrototypeMethod(tpl, "setSymmetric", SetSymmetric);

	Nan::SetPrototypeMethod(tpl, "SetThreeGlyphs", SetThreeGlyphs);
	Nan::SetPrototypeMethod(tpl, "setThreeGlyphs", SetThreeGlyphs);

	Nan::SetPrototypeMethod(tpl, "SymmetricOff", SymmetricOff);
	Nan::SetPrototypeMethod(tpl, "symmetricOff", SymmetricOff);

	Nan::SetPrototypeMethod(tpl, "SymmetricOn", SymmetricOn);
	Nan::SetPrototypeMethod(tpl, "symmetricOn", SymmetricOn);

	Nan::SetPrototypeMethod(tpl, "ThreeGlyphsOff", ThreeGlyphsOff);
	Nan::SetPrototypeMethod(tpl, "threeGlyphsOff", ThreeGlyphsOff);

	Nan::SetPrototypeMethod(tpl, "ThreeGlyphsOn", ThreeGlyphsOn);
	Nan::SetPrototypeMethod(tpl, "threeGlyphsOn", ThreeGlyphsOn);

	constructor.Reset( tpl->GetFunction() );
	ptpl.Reset( tpl );
}

void VtkTensorGlyphWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkTensorGlyph> native = vtkSmartPointer<vtkTensorGlyph>::New();
		VtkTensorGlyphWrap* obj = new VtkTensorGlyphWrap(native);		obj->Wrap(info.This());
	}
	else
	{
		Nan::Utf8String s(info[0]);
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkTensorGlyphWrap::ClampScalingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClampScalingOff();
}

void VtkTensorGlyphWrap::ClampScalingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClampScalingOn();
}

void VtkTensorGlyphWrap::ColorGlyphsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ColorGlyphsOff();
}

void VtkTensorGlyphWrap::ColorGlyphsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ColorGlyphsOn();
}

void VtkTensorGlyphWrap::ExtractEigenvaluesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ExtractEigenvaluesOff();
}

void VtkTensorGlyphWrap::ExtractEigenvaluesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ExtractEigenvaluesOn();
}

void VtkTensorGlyphWrap::GetClampScaling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClampScaling();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTensorGlyphWrap::GetColorGlyphs(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorGlyphs();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetColorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetColorModeMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorModeMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetColorModeMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorModeMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetExtractEigenvalues(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetExtractEigenvalues();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetLength(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLength();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetMaxScaleFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMaxScaleFactor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetScaleFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaleFactor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetScaling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaling();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetSource(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	vtkPolyData * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSource();
		VtkPolyDataWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkPolyDataWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPolyDataWrap *w = new VtkPolyDataWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkTensorGlyphWrap::GetSymmetric(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSymmetric();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::GetThreeGlyphs(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetThreeGlyphs();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTensorGlyphWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	vtkTensorGlyph * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkTensorGlyphWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkTensorGlyphWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkTensorGlyphWrap *w = new VtkTensorGlyphWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkTensorGlyphWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkTensorGlyph * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkTensorGlyphWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkTensorGlyphWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkTensorGlyphWrap *w = new VtkTensorGlyphWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::ScalingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ScalingOff();
}

void VtkTensorGlyphWrap::ScalingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ScalingOn();
}

void VtkTensorGlyphWrap::SetClampScaling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetClampScaling(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetColorGlyphs(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetColorGlyphs(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetColorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetColorMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetColorModeToEigenvalues(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToEigenvalues();
}

void VtkTensorGlyphWrap::SetColorModeToScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToScalars();
}

void VtkTensorGlyphWrap::SetExtractEigenvalues(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetExtractEigenvalues(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetLength(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetLength(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetMaxScaleFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMaxScaleFactor(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetScaleFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScaleFactor(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetScaling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScaling(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetSourceConnection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAlgorithmOutputWrap *a0 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceConnection(
			(vtkAlgorithmOutput *) a0->native.GetPointer()
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[1]))
		{
			VtkAlgorithmOutputWrap *a1 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[1]->ToObject());
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetSourceConnection(
				info[0]->Int32Value(),
				(vtkAlgorithmOutput *) a1->native.GetPointer()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetSourceData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPolyDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPolyDataWrap *a0 = ObjectWrap::Unwrap<VtkPolyDataWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceData(
			(vtkPolyData *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetSymmetric(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSymmetric(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SetThreeGlyphs(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetThreeGlyphs(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTensorGlyphWrap::SymmetricOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SymmetricOff();
}

void VtkTensorGlyphWrap::SymmetricOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SymmetricOn();
}

void VtkTensorGlyphWrap::ThreeGlyphsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ThreeGlyphsOff();
}

void VtkTensorGlyphWrap::ThreeGlyphsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTensorGlyphWrap *wrapper = ObjectWrap::Unwrap<VtkTensorGlyphWrap>(info.Holder());
	vtkTensorGlyph *native = (vtkTensorGlyph *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ThreeGlyphsOn();
}

