/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkPolyDataAlgorithmWrap.h"
#include "vtkGenericGlyph3DFilterWrap.h"
#include "vtkObjectWrap.h"
#include "vtkPolyDataWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::Function> VtkGenericGlyph3DFilterWrap::constructor;

VtkGenericGlyph3DFilterWrap::VtkGenericGlyph3DFilterWrap()
{ }

VtkGenericGlyph3DFilterWrap::VtkGenericGlyph3DFilterWrap(vtkSmartPointer<vtkGenericGlyph3DFilter> _native)
{ native = _native; }

VtkGenericGlyph3DFilterWrap::~VtkGenericGlyph3DFilterWrap()
{ }

void VtkGenericGlyph3DFilterWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::HandleScope scope;

	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	tpl->SetClassName(Nan::New("VtkGenericGlyph3DFilterWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	VtkObjectBaseWrap::InitTpl(tpl);
	VtkObjectWrap::InitTpl(tpl);
	VtkAlgorithmWrap::InitTpl(tpl);
	VtkPolyDataAlgorithmWrap::InitTpl(tpl);
	InitTpl(tpl);

	constructor.Reset( tpl->GetFunction() );

	exports->Set(Nan::New("vtkGenericGlyph3DFilter").ToLocalChecked(),tpl->GetFunction());
	exports->Set(Nan::New("GenericGlyph3DFilter").ToLocalChecked(),tpl->GetFunction());
}

void VtkGenericGlyph3DFilterWrap::InitTpl(v8::Local<v8::FunctionTemplate> tpl)
{
	Nan::SetPrototypeMethod(tpl, "ClampingOff", ClampingOff);
	Nan::SetPrototypeMethod(tpl, "clampingOff", ClampingOff);

	Nan::SetPrototypeMethod(tpl, "ClampingOn", ClampingOn);
	Nan::SetPrototypeMethod(tpl, "clampingOn", ClampingOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePointIdsOff", GeneratePointIdsOff);
	Nan::SetPrototypeMethod(tpl, "generatePointIdsOff", GeneratePointIdsOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePointIdsOn", GeneratePointIdsOn);
	Nan::SetPrototypeMethod(tpl, "generatePointIdsOn", GeneratePointIdsOn);

	Nan::SetPrototypeMethod(tpl, "GetClamping", GetClamping);
	Nan::SetPrototypeMethod(tpl, "getClamping", GetClamping);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetColorMode", GetColorMode);
	Nan::SetPrototypeMethod(tpl, "getColorMode", GetColorMode);

	Nan::SetPrototypeMethod(tpl, "GetColorModeAsString", GetColorModeAsString);
	Nan::SetPrototypeMethod(tpl, "getColorModeAsString", GetColorModeAsString);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePointIds", GetGeneratePointIds);
	Nan::SetPrototypeMethod(tpl, "getGeneratePointIds", GetGeneratePointIds);

	Nan::SetPrototypeMethod(tpl, "GetIndexMode", GetIndexMode);
	Nan::SetPrototypeMethod(tpl, "getIndexMode", GetIndexMode);

	Nan::SetPrototypeMethod(tpl, "GetIndexModeAsString", GetIndexModeAsString);
	Nan::SetPrototypeMethod(tpl, "getIndexModeAsString", GetIndexModeAsString);

	Nan::SetPrototypeMethod(tpl, "GetInputNormalsSelection", GetInputNormalsSelection);
	Nan::SetPrototypeMethod(tpl, "getInputNormalsSelection", GetInputNormalsSelection);

	Nan::SetPrototypeMethod(tpl, "GetInputScalarsSelection", GetInputScalarsSelection);
	Nan::SetPrototypeMethod(tpl, "getInputScalarsSelection", GetInputScalarsSelection);

	Nan::SetPrototypeMethod(tpl, "GetInputVectorsSelection", GetInputVectorsSelection);
	Nan::SetPrototypeMethod(tpl, "getInputVectorsSelection", GetInputVectorsSelection);

	Nan::SetPrototypeMethod(tpl, "GetOrient", GetOrient);
	Nan::SetPrototypeMethod(tpl, "getOrient", GetOrient);

	Nan::SetPrototypeMethod(tpl, "GetPointIdsName", GetPointIdsName);
	Nan::SetPrototypeMethod(tpl, "getPointIdsName", GetPointIdsName);

	Nan::SetPrototypeMethod(tpl, "GetScaleFactor", GetScaleFactor);
	Nan::SetPrototypeMethod(tpl, "getScaleFactor", GetScaleFactor);

	Nan::SetPrototypeMethod(tpl, "GetScaleMode", GetScaleMode);
	Nan::SetPrototypeMethod(tpl, "getScaleMode", GetScaleMode);

	Nan::SetPrototypeMethod(tpl, "GetScaleModeAsString", GetScaleModeAsString);
	Nan::SetPrototypeMethod(tpl, "getScaleModeAsString", GetScaleModeAsString);

	Nan::SetPrototypeMethod(tpl, "GetScaling", GetScaling);
	Nan::SetPrototypeMethod(tpl, "getScaling", GetScaling);

	Nan::SetPrototypeMethod(tpl, "GetSource", GetSource);
	Nan::SetPrototypeMethod(tpl, "getSource", GetSource);

	Nan::SetPrototypeMethod(tpl, "GetVectorMode", GetVectorMode);
	Nan::SetPrototypeMethod(tpl, "getVectorMode", GetVectorMode);

	Nan::SetPrototypeMethod(tpl, "GetVectorModeAsString", GetVectorModeAsString);
	Nan::SetPrototypeMethod(tpl, "getVectorModeAsString", GetVectorModeAsString);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "OrientOff", OrientOff);
	Nan::SetPrototypeMethod(tpl, "orientOff", OrientOff);

	Nan::SetPrototypeMethod(tpl, "OrientOn", OrientOn);
	Nan::SetPrototypeMethod(tpl, "orientOn", OrientOn);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "ScalingOff", ScalingOff);
	Nan::SetPrototypeMethod(tpl, "scalingOff", ScalingOff);

	Nan::SetPrototypeMethod(tpl, "ScalingOn", ScalingOn);
	Nan::SetPrototypeMethod(tpl, "scalingOn", ScalingOn);

	Nan::SetPrototypeMethod(tpl, "SelectInputNormals", SelectInputNormals);
	Nan::SetPrototypeMethod(tpl, "selectInputNormals", SelectInputNormals);

	Nan::SetPrototypeMethod(tpl, "SelectInputScalars", SelectInputScalars);
	Nan::SetPrototypeMethod(tpl, "selectInputScalars", SelectInputScalars);

	Nan::SetPrototypeMethod(tpl, "SelectInputVectors", SelectInputVectors);
	Nan::SetPrototypeMethod(tpl, "selectInputVectors", SelectInputVectors);

	Nan::SetPrototypeMethod(tpl, "SetClamping", SetClamping);
	Nan::SetPrototypeMethod(tpl, "setClamping", SetClamping);

	Nan::SetPrototypeMethod(tpl, "SetColorMode", SetColorMode);
	Nan::SetPrototypeMethod(tpl, "setColorMode", SetColorMode);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToColorByScalar", SetColorModeToColorByScalar);
	Nan::SetPrototypeMethod(tpl, "setColorModeToColorByScalar", SetColorModeToColorByScalar);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToColorByScale", SetColorModeToColorByScale);
	Nan::SetPrototypeMethod(tpl, "setColorModeToColorByScale", SetColorModeToColorByScale);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToColorByVector", SetColorModeToColorByVector);
	Nan::SetPrototypeMethod(tpl, "setColorModeToColorByVector", SetColorModeToColorByVector);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePointIds", SetGeneratePointIds);
	Nan::SetPrototypeMethod(tpl, "setGeneratePointIds", SetGeneratePointIds);

	Nan::SetPrototypeMethod(tpl, "SetIndexMode", SetIndexMode);
	Nan::SetPrototypeMethod(tpl, "setIndexMode", SetIndexMode);

	Nan::SetPrototypeMethod(tpl, "SetIndexModeToOff", SetIndexModeToOff);
	Nan::SetPrototypeMethod(tpl, "setIndexModeToOff", SetIndexModeToOff);

	Nan::SetPrototypeMethod(tpl, "SetIndexModeToScalar", SetIndexModeToScalar);
	Nan::SetPrototypeMethod(tpl, "setIndexModeToScalar", SetIndexModeToScalar);

	Nan::SetPrototypeMethod(tpl, "SetIndexModeToVector", SetIndexModeToVector);
	Nan::SetPrototypeMethod(tpl, "setIndexModeToVector", SetIndexModeToVector);

	Nan::SetPrototypeMethod(tpl, "SetOrient", SetOrient);
	Nan::SetPrototypeMethod(tpl, "setOrient", SetOrient);

	Nan::SetPrototypeMethod(tpl, "SetPointIdsName", SetPointIdsName);
	Nan::SetPrototypeMethod(tpl, "setPointIdsName", SetPointIdsName);

	Nan::SetPrototypeMethod(tpl, "SetRange", SetRange);
	Nan::SetPrototypeMethod(tpl, "setRange", SetRange);

	Nan::SetPrototypeMethod(tpl, "SetScaleFactor", SetScaleFactor);
	Nan::SetPrototypeMethod(tpl, "setScaleFactor", SetScaleFactor);

	Nan::SetPrototypeMethod(tpl, "SetScaleMode", SetScaleMode);
	Nan::SetPrototypeMethod(tpl, "setScaleMode", SetScaleMode);

	Nan::SetPrototypeMethod(tpl, "SetScaleModeToDataScalingOff", SetScaleModeToDataScalingOff);
	Nan::SetPrototypeMethod(tpl, "setScaleModeToDataScalingOff", SetScaleModeToDataScalingOff);

	Nan::SetPrototypeMethod(tpl, "SetScaleModeToScaleByScalar", SetScaleModeToScaleByScalar);
	Nan::SetPrototypeMethod(tpl, "setScaleModeToScaleByScalar", SetScaleModeToScaleByScalar);

	Nan::SetPrototypeMethod(tpl, "SetScaleModeToScaleByVector", SetScaleModeToScaleByVector);
	Nan::SetPrototypeMethod(tpl, "setScaleModeToScaleByVector", SetScaleModeToScaleByVector);

	Nan::SetPrototypeMethod(tpl, "SetScaleModeToScaleByVectorComponents", SetScaleModeToScaleByVectorComponents);
	Nan::SetPrototypeMethod(tpl, "setScaleModeToScaleByVectorComponents", SetScaleModeToScaleByVectorComponents);

	Nan::SetPrototypeMethod(tpl, "SetScaling", SetScaling);
	Nan::SetPrototypeMethod(tpl, "setScaling", SetScaling);

	Nan::SetPrototypeMethod(tpl, "SetSourceData", SetSourceData);
	Nan::SetPrototypeMethod(tpl, "setSourceData", SetSourceData);

	Nan::SetPrototypeMethod(tpl, "SetVectorMode", SetVectorMode);
	Nan::SetPrototypeMethod(tpl, "setVectorMode", SetVectorMode);

	Nan::SetPrototypeMethod(tpl, "SetVectorModeToUseNormal", SetVectorModeToUseNormal);
	Nan::SetPrototypeMethod(tpl, "setVectorModeToUseNormal", SetVectorModeToUseNormal);

	Nan::SetPrototypeMethod(tpl, "SetVectorModeToUseVector", SetVectorModeToUseVector);
	Nan::SetPrototypeMethod(tpl, "setVectorModeToUseVector", SetVectorModeToUseVector);

	Nan::SetPrototypeMethod(tpl, "SetVectorModeToVectorRotationOff", SetVectorModeToVectorRotationOff);
	Nan::SetPrototypeMethod(tpl, "setVectorModeToVectorRotationOff", SetVectorModeToVectorRotationOff);

}

void VtkGenericGlyph3DFilterWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkGenericGlyph3DFilter> native = vtkSmartPointer<vtkGenericGlyph3DFilter>::New();
		VtkGenericGlyph3DFilterWrap* obj = new VtkGenericGlyph3DFilterWrap(native);		obj->Wrap(info.This());
	}
	else
	{
		Nan::Utf8String s(info[0]);
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkGenericGlyph3DFilterWrap::ClampingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClampingOff();
}

void VtkGenericGlyph3DFilterWrap::ClampingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClampingOn();
}

void VtkGenericGlyph3DFilterWrap::GeneratePointIdsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointIdsOff();
}

void VtkGenericGlyph3DFilterWrap::GeneratePointIdsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointIdsOn();
}

void VtkGenericGlyph3DFilterWrap::GetClamping(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClamping();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::GetColorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetColorModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::GetGeneratePointIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePointIds();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetIndexMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIndexMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetIndexModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIndexModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::GetInputNormalsSelection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInputNormalsSelection();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::GetInputScalarsSelection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInputScalarsSelection();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::GetInputVectorsSelection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInputVectorsSelection();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::GetOrient(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOrient();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetPointIdsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPointIdsName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::GetScaleFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaleFactor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetScaleMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaleMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetScaleModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaleModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::GetScaling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaling();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetSource(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkPolyData * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetSource(
			info[0]->Int32Value()
		);
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkPolyDataWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkPolyDataWrap *w = new VtkPolyDataWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::GetVectorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVectorMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGenericGlyph3DFilterWrap::GetVectorModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVectorModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGenericGlyph3DFilterWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	vtkGenericGlyph3DFilter * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::Function>(VtkGenericGlyph3DFilterWrap::constructor);
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkGenericGlyph3DFilterWrap *w = new VtkGenericGlyph3DFilterWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkGenericGlyph3DFilterWrap::OrientOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OrientOff();
}

void VtkGenericGlyph3DFilterWrap::OrientOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OrientOn();
}

void VtkGenericGlyph3DFilterWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject())
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkGenericGlyph3DFilter * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::Function>(VtkGenericGlyph3DFilterWrap::constructor);
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkGenericGlyph3DFilterWrap *w = new VtkGenericGlyph3DFilterWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::ScalingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ScalingOff();
}

void VtkGenericGlyph3DFilterWrap::ScalingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ScalingOn();
}

void VtkGenericGlyph3DFilterWrap::SelectInputNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SelectInputNormals(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SelectInputScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SelectInputScalars(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SelectInputVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SelectInputVectors(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetClamping(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetClamping(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetColorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetColorMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetColorModeToColorByScalar(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToColorByScalar();
}

void VtkGenericGlyph3DFilterWrap::SetColorModeToColorByScale(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToColorByScale();
}

void VtkGenericGlyph3DFilterWrap::SetColorModeToColorByVector(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToColorByVector();
}

void VtkGenericGlyph3DFilterWrap::SetGeneratePointIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePointIds(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetIndexMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIndexMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetIndexModeToOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetIndexModeToOff();
}

void VtkGenericGlyph3DFilterWrap::SetIndexModeToScalar(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetIndexModeToScalar();
}

void VtkGenericGlyph3DFilterWrap::SetIndexModeToVector(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetIndexModeToVector();
}

void VtkGenericGlyph3DFilterWrap::SetOrient(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOrient(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetPointIdsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetPointIdsName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetRange(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetScaleFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScaleFactor(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetScaleMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScaleMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetScaleModeToDataScalingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScaleModeToDataScalingOff();
}

void VtkGenericGlyph3DFilterWrap::SetScaleModeToScaleByScalar(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScaleModeToScaleByScalar();
}

void VtkGenericGlyph3DFilterWrap::SetScaleModeToScaleByVector(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScaleModeToScaleByVector();
}

void VtkGenericGlyph3DFilterWrap::SetScaleModeToScaleByVectorComponents(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScaleModeToScaleByVectorComponents();
}

void VtkGenericGlyph3DFilterWrap::SetScaling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScaling(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetSourceData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject())
	{
		VtkPolyDataWrap *a0 = ObjectWrap::Unwrap<VtkPolyDataWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceData(
			(vtkPolyData *) a0->native.GetPointer()
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsObject())
		{
			VtkPolyDataWrap *a1 = ObjectWrap::Unwrap<VtkPolyDataWrap>(info[1]->ToObject());
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetSourceData(
				info[0]->Int32Value(),
				(vtkPolyData *) a1->native.GetPointer()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetVectorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetVectorMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGenericGlyph3DFilterWrap::SetVectorModeToUseNormal(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetVectorModeToUseNormal();
}

void VtkGenericGlyph3DFilterWrap::SetVectorModeToUseVector(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetVectorModeToUseVector();
}

void VtkGenericGlyph3DFilterWrap::SetVectorModeToVectorRotationOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGenericGlyph3DFilterWrap *wrapper = ObjectWrap::Unwrap<VtkGenericGlyph3DFilterWrap>(info.Holder());
	vtkGenericGlyph3DFilter *native = (vtkGenericGlyph3DFilter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetVectorModeToVectorRotationOff();
}

