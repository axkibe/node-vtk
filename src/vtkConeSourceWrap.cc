/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include <vtkSmartPointer.h>
#include <vtkConeSource.h>

#include "vtkConeSourceWrap.h"

using namespace v8;

Nan::Persistent<v8::Function> VtkConeSourceWrap::constructor;

VtkConeSourceWrap::VtkConeSourceWrap(vtkSmartPointer<vtkConeSource> native) :
	native(native)
{ }

VtkConeSourceWrap::~VtkConeSourceWrap()
{
	native = 0;
}

void VtkConeSourceWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::HandleScope scope;

	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	tpl->SetClassName(Nan::New("VtkConeSourceWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "SetHeight", SetHeight);
	Nan::SetPrototypeMethod(tpl, "setHeight", SetHeight);

	Nan::SetPrototypeMethod(tpl, "GetHeightMinValue", GetHeightMinValue);
	Nan::SetPrototypeMethod(tpl, "getHeightMinValue", GetHeightMinValue);

	Nan::SetPrototypeMethod(tpl, "GetHeightMaxValue", GetHeightMaxValue);
	Nan::SetPrototypeMethod(tpl, "getHeightMaxValue", GetHeightMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetHeight", GetHeight);
	Nan::SetPrototypeMethod(tpl, "getHeight", GetHeight);

	Nan::SetPrototypeMethod(tpl, "SetRadius", SetRadius);
	Nan::SetPrototypeMethod(tpl, "setRadius", SetRadius);

	Nan::SetPrototypeMethod(tpl, "GetRadiusMinValue", GetRadiusMinValue);
	Nan::SetPrototypeMethod(tpl, "getRadiusMinValue", GetRadiusMinValue);

	Nan::SetPrototypeMethod(tpl, "GetRadiusMaxValue", GetRadiusMaxValue);
	Nan::SetPrototypeMethod(tpl, "getRadiusMaxValue", GetRadiusMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetRadius", GetRadius);
	Nan::SetPrototypeMethod(tpl, "getRadius", GetRadius);

	Nan::SetPrototypeMethod(tpl, "SetResolution", SetResolution);
	Nan::SetPrototypeMethod(tpl, "setResolution", SetResolution);

	Nan::SetPrototypeMethod(tpl, "GetResolutionMinValue", GetResolutionMinValue);
	Nan::SetPrototypeMethod(tpl, "getResolutionMinValue", GetResolutionMinValue);

	Nan::SetPrototypeMethod(tpl, "GetResolutionMaxValue", GetResolutionMaxValue);
	Nan::SetPrototypeMethod(tpl, "getResolutionMaxValue", GetResolutionMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetResolution", GetResolution);
	Nan::SetPrototypeMethod(tpl, "getResolution", GetResolution);

	Nan::SetPrototypeMethod(tpl, "SetCenter", SetCenter);
	Nan::SetPrototypeMethod(tpl, "setCenter", SetCenter);

	Nan::SetPrototypeMethod(tpl, "SetDirection", SetDirection);
	Nan::SetPrototypeMethod(tpl, "setDirection", SetDirection);

	Nan::SetPrototypeMethod(tpl, "SetAngle", SetAngle);
	Nan::SetPrototypeMethod(tpl, "setAngle", SetAngle);

	Nan::SetPrototypeMethod(tpl, "GetAngle", GetAngle);
	Nan::SetPrototypeMethod(tpl, "getAngle", GetAngle);

	Nan::SetPrototypeMethod(tpl, "SetCapping", SetCapping);
	Nan::SetPrototypeMethod(tpl, "setCapping", SetCapping);

	Nan::SetPrototypeMethod(tpl, "GetCapping", GetCapping);
	Nan::SetPrototypeMethod(tpl, "getCapping", GetCapping);

	Nan::SetPrototypeMethod(tpl, "CappingOn", CappingOn);
	Nan::SetPrototypeMethod(tpl, "cappingOn", CappingOn);

	Nan::SetPrototypeMethod(tpl, "CappingOff", CappingOff);
	Nan::SetPrototypeMethod(tpl, "cappingOff", CappingOff);

	Nan::SetPrototypeMethod(tpl, "SetOutputPointsPrecision", SetOutputPointsPrecision);
	Nan::SetPrototypeMethod(tpl, "setOutputPointsPrecision", SetOutputPointsPrecision);

	Nan::SetPrototypeMethod(tpl, "GetOutputPointsPrecision", GetOutputPointsPrecision);
	Nan::SetPrototypeMethod(tpl, "getOutputPointsPrecision", GetOutputPointsPrecision);

	constructor.Reset( tpl->GetFunction() );

	exports->Set(Nan::New("vtkConeSource").ToLocalChecked(),tpl->GetFunction());
	exports->Set(Nan::New("coneSource").ToLocalChecked(),tpl->GetFunction());
}

void VtkConeSourceWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	vtkSmartPointer<vtkConeSource> native = vtkSmartPointer<vtkConeSource>::New();
	VtkConeSourceWrap* obj = new VtkConeSourceWrap(native);
	obj->Wrap(info.This());
	info.GetReturnValue().Set(info.This());
}

void VtkConeSourceWrap::SetHeight(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		wrapper->native->SetHeight(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkConeSourceWrap::GetHeightMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetHeightMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::GetHeightMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetHeightMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::GetHeight(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetHeight();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::SetRadius(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		wrapper->native->SetRadius(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkConeSourceWrap::GetRadiusMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetRadiusMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::GetRadiusMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetRadiusMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::GetRadius(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetRadius();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::SetResolution(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		wrapper->native->SetResolution(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkConeSourceWrap::GetResolutionMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetResolutionMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::GetResolutionMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetResolutionMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::GetResolution(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetResolution();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::SetCenter(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				wrapper->native->SetCenter(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkConeSourceWrap::SetDirection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				wrapper->native->SetDirection(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkConeSourceWrap::SetAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		wrapper->native->SetAngle(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkConeSourceWrap::GetAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetAngle();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::SetCapping(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		wrapper->native->SetCapping(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkConeSourceWrap::GetCapping(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetCapping();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkConeSourceWrap::CappingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	wrapper->native->CappingOn();
}

void VtkConeSourceWrap::CappingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	wrapper->native->CappingOff();
}

void VtkConeSourceWrap::SetOutputPointsPrecision(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		wrapper->native->SetOutputPointsPrecision(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkConeSourceWrap::GetOutputPointsPrecision(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkConeSourceWrap *wrapper = ObjectWrap::Unwrap<VtkConeSourceWrap>(info.Holder());
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = wrapper->native->GetOutputPointsPrecision();
	info.GetReturnValue().Set(Nan::New(r));
}

