/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkThreadedImageAlgorithmWrap.h"
#include "vtkImageResliceWrap.h"
#include "vtkObjectWrap.h"
#include "vtkMatrix4x4Wrap.h"
#include "vtkAbstractTransformWrap.h"
#include "vtkImageDataWrap.h"
#include "vtkAbstractImageInterpolatorWrap.h"
#include "vtkGarbageCollectorWrap.h"
#include "vtkImageStencilDataWrap.h"
#include "vtkAlgorithmOutputWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkImageResliceWrap::ptpl;

VtkImageResliceWrap::VtkImageResliceWrap()
{ }

VtkImageResliceWrap::VtkImageResliceWrap(vtkSmartPointer<vtkImageReslice> _native)
{ native = _native; }

VtkImageResliceWrap::~VtkImageResliceWrap()
{ }

void VtkImageResliceWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkImageReslice").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("ImageReslice").ToLocalChecked(), ConstructorGetter);
}

void VtkImageResliceWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkImageResliceWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkThreadedImageAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkThreadedImageAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkImageResliceWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AutoCropOutputOff", AutoCropOutputOff);
	Nan::SetPrototypeMethod(tpl, "autoCropOutputOff", AutoCropOutputOff);

	Nan::SetPrototypeMethod(tpl, "AutoCropOutputOn", AutoCropOutputOn);
	Nan::SetPrototypeMethod(tpl, "autoCropOutputOn", AutoCropOutputOn);

	Nan::SetPrototypeMethod(tpl, "BorderOff", BorderOff);
	Nan::SetPrototypeMethod(tpl, "borderOff", BorderOff);

	Nan::SetPrototypeMethod(tpl, "BorderOn", BorderOn);
	Nan::SetPrototypeMethod(tpl, "borderOn", BorderOn);

	Nan::SetPrototypeMethod(tpl, "GenerateStencilOutputOff", GenerateStencilOutputOff);
	Nan::SetPrototypeMethod(tpl, "generateStencilOutputOff", GenerateStencilOutputOff);

	Nan::SetPrototypeMethod(tpl, "GenerateStencilOutputOn", GenerateStencilOutputOn);
	Nan::SetPrototypeMethod(tpl, "generateStencilOutputOn", GenerateStencilOutputOn);

	Nan::SetPrototypeMethod(tpl, "GetAutoCropOutput", GetAutoCropOutput);
	Nan::SetPrototypeMethod(tpl, "getAutoCropOutput", GetAutoCropOutput);

	Nan::SetPrototypeMethod(tpl, "GetBackgroundLevel", GetBackgroundLevel);
	Nan::SetPrototypeMethod(tpl, "getBackgroundLevel", GetBackgroundLevel);

	Nan::SetPrototypeMethod(tpl, "GetBorder", GetBorder);
	Nan::SetPrototypeMethod(tpl, "getBorder", GetBorder);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetGenerateStencilOutput", GetGenerateStencilOutput);
	Nan::SetPrototypeMethod(tpl, "getGenerateStencilOutput", GetGenerateStencilOutput);

	Nan::SetPrototypeMethod(tpl, "GetInformationInput", GetInformationInput);
	Nan::SetPrototypeMethod(tpl, "getInformationInput", GetInformationInput);

	Nan::SetPrototypeMethod(tpl, "GetInterpolate", GetInterpolate);
	Nan::SetPrototypeMethod(tpl, "getInterpolate", GetInterpolate);

	Nan::SetPrototypeMethod(tpl, "GetInterpolationMode", GetInterpolationMode);
	Nan::SetPrototypeMethod(tpl, "getInterpolationMode", GetInterpolationMode);

	Nan::SetPrototypeMethod(tpl, "GetInterpolationModeAsString", GetInterpolationModeAsString);
	Nan::SetPrototypeMethod(tpl, "getInterpolationModeAsString", GetInterpolationModeAsString);

	Nan::SetPrototypeMethod(tpl, "GetInterpolationModeMaxValue", GetInterpolationModeMaxValue);
	Nan::SetPrototypeMethod(tpl, "getInterpolationModeMaxValue", GetInterpolationModeMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetInterpolationModeMinValue", GetInterpolationModeMinValue);
	Nan::SetPrototypeMethod(tpl, "getInterpolationModeMinValue", GetInterpolationModeMinValue);

	Nan::SetPrototypeMethod(tpl, "GetInterpolator", GetInterpolator);
	Nan::SetPrototypeMethod(tpl, "getInterpolator", GetInterpolator);

	Nan::SetPrototypeMethod(tpl, "GetMirror", GetMirror);
	Nan::SetPrototypeMethod(tpl, "getMirror", GetMirror);

	Nan::SetPrototypeMethod(tpl, "GetOptimization", GetOptimization);
	Nan::SetPrototypeMethod(tpl, "getOptimization", GetOptimization);

	Nan::SetPrototypeMethod(tpl, "GetOutputDimensionality", GetOutputDimensionality);
	Nan::SetPrototypeMethod(tpl, "getOutputDimensionality", GetOutputDimensionality);

	Nan::SetPrototypeMethod(tpl, "GetOutputScalarType", GetOutputScalarType);
	Nan::SetPrototypeMethod(tpl, "getOutputScalarType", GetOutputScalarType);

	Nan::SetPrototypeMethod(tpl, "GetResliceAxes", GetResliceAxes);
	Nan::SetPrototypeMethod(tpl, "getResliceAxes", GetResliceAxes);

	Nan::SetPrototypeMethod(tpl, "GetResliceAxesDirectionCosines", GetResliceAxesDirectionCosines);
	Nan::SetPrototypeMethod(tpl, "getResliceAxesDirectionCosines", GetResliceAxesDirectionCosines);

	Nan::SetPrototypeMethod(tpl, "GetResliceAxesOrigin", GetResliceAxesOrigin);
	Nan::SetPrototypeMethod(tpl, "getResliceAxesOrigin", GetResliceAxesOrigin);

	Nan::SetPrototypeMethod(tpl, "GetResliceTransform", GetResliceTransform);
	Nan::SetPrototypeMethod(tpl, "getResliceTransform", GetResliceTransform);

	Nan::SetPrototypeMethod(tpl, "GetScalarScale", GetScalarScale);
	Nan::SetPrototypeMethod(tpl, "getScalarScale", GetScalarScale);

	Nan::SetPrototypeMethod(tpl, "GetScalarShift", GetScalarShift);
	Nan::SetPrototypeMethod(tpl, "getScalarShift", GetScalarShift);

	Nan::SetPrototypeMethod(tpl, "GetSlabMode", GetSlabMode);
	Nan::SetPrototypeMethod(tpl, "getSlabMode", GetSlabMode);

	Nan::SetPrototypeMethod(tpl, "GetSlabModeAsString", GetSlabModeAsString);
	Nan::SetPrototypeMethod(tpl, "getSlabModeAsString", GetSlabModeAsString);

	Nan::SetPrototypeMethod(tpl, "GetSlabModeMaxValue", GetSlabModeMaxValue);
	Nan::SetPrototypeMethod(tpl, "getSlabModeMaxValue", GetSlabModeMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetSlabModeMinValue", GetSlabModeMinValue);
	Nan::SetPrototypeMethod(tpl, "getSlabModeMinValue", GetSlabModeMinValue);

	Nan::SetPrototypeMethod(tpl, "GetSlabNumberOfSlices", GetSlabNumberOfSlices);
	Nan::SetPrototypeMethod(tpl, "getSlabNumberOfSlices", GetSlabNumberOfSlices);

	Nan::SetPrototypeMethod(tpl, "GetSlabSliceSpacingFraction", GetSlabSliceSpacingFraction);
	Nan::SetPrototypeMethod(tpl, "getSlabSliceSpacingFraction", GetSlabSliceSpacingFraction);

	Nan::SetPrototypeMethod(tpl, "GetSlabTrapezoidIntegration", GetSlabTrapezoidIntegration);
	Nan::SetPrototypeMethod(tpl, "getSlabTrapezoidIntegration", GetSlabTrapezoidIntegration);

	Nan::SetPrototypeMethod(tpl, "GetStencil", GetStencil);
	Nan::SetPrototypeMethod(tpl, "getStencil", GetStencil);

	Nan::SetPrototypeMethod(tpl, "GetStencilOutput", GetStencilOutput);
	Nan::SetPrototypeMethod(tpl, "getStencilOutput", GetStencilOutput);

	Nan::SetPrototypeMethod(tpl, "GetStencilOutputPort", GetStencilOutputPort);
	Nan::SetPrototypeMethod(tpl, "getStencilOutputPort", GetStencilOutputPort);

	Nan::SetPrototypeMethod(tpl, "GetTransformInputSampling", GetTransformInputSampling);
	Nan::SetPrototypeMethod(tpl, "getTransformInputSampling", GetTransformInputSampling);

	Nan::SetPrototypeMethod(tpl, "GetWrap", GetWrap);
	Nan::SetPrototypeMethod(tpl, "getWrap", GetWrap);

	Nan::SetPrototypeMethod(tpl, "InterpolateOff", InterpolateOff);
	Nan::SetPrototypeMethod(tpl, "interpolateOff", InterpolateOff);

	Nan::SetPrototypeMethod(tpl, "InterpolateOn", InterpolateOn);
	Nan::SetPrototypeMethod(tpl, "interpolateOn", InterpolateOn);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "MirrorOff", MirrorOff);
	Nan::SetPrototypeMethod(tpl, "mirrorOff", MirrorOff);

	Nan::SetPrototypeMethod(tpl, "MirrorOn", MirrorOn);
	Nan::SetPrototypeMethod(tpl, "mirrorOn", MirrorOn);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "OptimizationOff", OptimizationOff);
	Nan::SetPrototypeMethod(tpl, "optimizationOff", OptimizationOff);

	Nan::SetPrototypeMethod(tpl, "OptimizationOn", OptimizationOn);
	Nan::SetPrototypeMethod(tpl, "optimizationOn", OptimizationOn);

	Nan::SetPrototypeMethod(tpl, "ReportReferences", ReportReferences);
	Nan::SetPrototypeMethod(tpl, "reportReferences", ReportReferences);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetAutoCropOutput", SetAutoCropOutput);
	Nan::SetPrototypeMethod(tpl, "setAutoCropOutput", SetAutoCropOutput);

	Nan::SetPrototypeMethod(tpl, "SetBackgroundColor", SetBackgroundColor);
	Nan::SetPrototypeMethod(tpl, "setBackgroundColor", SetBackgroundColor);

	Nan::SetPrototypeMethod(tpl, "SetBackgroundLevel", SetBackgroundLevel);
	Nan::SetPrototypeMethod(tpl, "setBackgroundLevel", SetBackgroundLevel);

	Nan::SetPrototypeMethod(tpl, "SetBorder", SetBorder);
	Nan::SetPrototypeMethod(tpl, "setBorder", SetBorder);

	Nan::SetPrototypeMethod(tpl, "SetGenerateStencilOutput", SetGenerateStencilOutput);
	Nan::SetPrototypeMethod(tpl, "setGenerateStencilOutput", SetGenerateStencilOutput);

	Nan::SetPrototypeMethod(tpl, "SetInformationInput", SetInformationInput);
	Nan::SetPrototypeMethod(tpl, "setInformationInput", SetInformationInput);

	Nan::SetPrototypeMethod(tpl, "SetInterpolate", SetInterpolate);
	Nan::SetPrototypeMethod(tpl, "setInterpolate", SetInterpolate);

	Nan::SetPrototypeMethod(tpl, "SetInterpolationMode", SetInterpolationMode);
	Nan::SetPrototypeMethod(tpl, "setInterpolationMode", SetInterpolationMode);

	Nan::SetPrototypeMethod(tpl, "SetInterpolationModeToCubic", SetInterpolationModeToCubic);
	Nan::SetPrototypeMethod(tpl, "setInterpolationModeToCubic", SetInterpolationModeToCubic);

	Nan::SetPrototypeMethod(tpl, "SetInterpolationModeToLinear", SetInterpolationModeToLinear);
	Nan::SetPrototypeMethod(tpl, "setInterpolationModeToLinear", SetInterpolationModeToLinear);

	Nan::SetPrototypeMethod(tpl, "SetInterpolationModeToNearestNeighbor", SetInterpolationModeToNearestNeighbor);
	Nan::SetPrototypeMethod(tpl, "setInterpolationModeToNearestNeighbor", SetInterpolationModeToNearestNeighbor);

	Nan::SetPrototypeMethod(tpl, "SetInterpolator", SetInterpolator);
	Nan::SetPrototypeMethod(tpl, "setInterpolator", SetInterpolator);

	Nan::SetPrototypeMethod(tpl, "SetMirror", SetMirror);
	Nan::SetPrototypeMethod(tpl, "setMirror", SetMirror);

	Nan::SetPrototypeMethod(tpl, "SetOptimization", SetOptimization);
	Nan::SetPrototypeMethod(tpl, "setOptimization", SetOptimization);

	Nan::SetPrototypeMethod(tpl, "SetOutputDimensionality", SetOutputDimensionality);
	Nan::SetPrototypeMethod(tpl, "setOutputDimensionality", SetOutputDimensionality);

	Nan::SetPrototypeMethod(tpl, "SetOutputExtent", SetOutputExtent);
	Nan::SetPrototypeMethod(tpl, "setOutputExtent", SetOutputExtent);

	Nan::SetPrototypeMethod(tpl, "SetOutputExtentToDefault", SetOutputExtentToDefault);
	Nan::SetPrototypeMethod(tpl, "setOutputExtentToDefault", SetOutputExtentToDefault);

	Nan::SetPrototypeMethod(tpl, "SetOutputOrigin", SetOutputOrigin);
	Nan::SetPrototypeMethod(tpl, "setOutputOrigin", SetOutputOrigin);

	Nan::SetPrototypeMethod(tpl, "SetOutputOriginToDefault", SetOutputOriginToDefault);
	Nan::SetPrototypeMethod(tpl, "setOutputOriginToDefault", SetOutputOriginToDefault);

	Nan::SetPrototypeMethod(tpl, "SetOutputScalarType", SetOutputScalarType);
	Nan::SetPrototypeMethod(tpl, "setOutputScalarType", SetOutputScalarType);

	Nan::SetPrototypeMethod(tpl, "SetOutputSpacing", SetOutputSpacing);
	Nan::SetPrototypeMethod(tpl, "setOutputSpacing", SetOutputSpacing);

	Nan::SetPrototypeMethod(tpl, "SetOutputSpacingToDefault", SetOutputSpacingToDefault);
	Nan::SetPrototypeMethod(tpl, "setOutputSpacingToDefault", SetOutputSpacingToDefault);

	Nan::SetPrototypeMethod(tpl, "SetResliceAxes", SetResliceAxes);
	Nan::SetPrototypeMethod(tpl, "setResliceAxes", SetResliceAxes);

	Nan::SetPrototypeMethod(tpl, "SetResliceAxesDirectionCosines", SetResliceAxesDirectionCosines);
	Nan::SetPrototypeMethod(tpl, "setResliceAxesDirectionCosines", SetResliceAxesDirectionCosines);

	Nan::SetPrototypeMethod(tpl, "SetResliceAxesOrigin", SetResliceAxesOrigin);
	Nan::SetPrototypeMethod(tpl, "setResliceAxesOrigin", SetResliceAxesOrigin);

	Nan::SetPrototypeMethod(tpl, "SetResliceTransform", SetResliceTransform);
	Nan::SetPrototypeMethod(tpl, "setResliceTransform", SetResliceTransform);

	Nan::SetPrototypeMethod(tpl, "SetScalarScale", SetScalarScale);
	Nan::SetPrototypeMethod(tpl, "setScalarScale", SetScalarScale);

	Nan::SetPrototypeMethod(tpl, "SetScalarShift", SetScalarShift);
	Nan::SetPrototypeMethod(tpl, "setScalarShift", SetScalarShift);

	Nan::SetPrototypeMethod(tpl, "SetSlabMode", SetSlabMode);
	Nan::SetPrototypeMethod(tpl, "setSlabMode", SetSlabMode);

	Nan::SetPrototypeMethod(tpl, "SetSlabModeToMax", SetSlabModeToMax);
	Nan::SetPrototypeMethod(tpl, "setSlabModeToMax", SetSlabModeToMax);

	Nan::SetPrototypeMethod(tpl, "SetSlabModeToMean", SetSlabModeToMean);
	Nan::SetPrototypeMethod(tpl, "setSlabModeToMean", SetSlabModeToMean);

	Nan::SetPrototypeMethod(tpl, "SetSlabModeToMin", SetSlabModeToMin);
	Nan::SetPrototypeMethod(tpl, "setSlabModeToMin", SetSlabModeToMin);

	Nan::SetPrototypeMethod(tpl, "SetSlabModeToSum", SetSlabModeToSum);
	Nan::SetPrototypeMethod(tpl, "setSlabModeToSum", SetSlabModeToSum);

	Nan::SetPrototypeMethod(tpl, "SetSlabNumberOfSlices", SetSlabNumberOfSlices);
	Nan::SetPrototypeMethod(tpl, "setSlabNumberOfSlices", SetSlabNumberOfSlices);

	Nan::SetPrototypeMethod(tpl, "SetSlabSliceSpacingFraction", SetSlabSliceSpacingFraction);
	Nan::SetPrototypeMethod(tpl, "setSlabSliceSpacingFraction", SetSlabSliceSpacingFraction);

	Nan::SetPrototypeMethod(tpl, "SetSlabTrapezoidIntegration", SetSlabTrapezoidIntegration);
	Nan::SetPrototypeMethod(tpl, "setSlabTrapezoidIntegration", SetSlabTrapezoidIntegration);

	Nan::SetPrototypeMethod(tpl, "SetStencilData", SetStencilData);
	Nan::SetPrototypeMethod(tpl, "setStencilData", SetStencilData);

	Nan::SetPrototypeMethod(tpl, "SetStencilOutput", SetStencilOutput);
	Nan::SetPrototypeMethod(tpl, "setStencilOutput", SetStencilOutput);

	Nan::SetPrototypeMethod(tpl, "SetTransformInputSampling", SetTransformInputSampling);
	Nan::SetPrototypeMethod(tpl, "setTransformInputSampling", SetTransformInputSampling);

	Nan::SetPrototypeMethod(tpl, "SetWrap", SetWrap);
	Nan::SetPrototypeMethod(tpl, "setWrap", SetWrap);

	Nan::SetPrototypeMethod(tpl, "SlabTrapezoidIntegrationOff", SlabTrapezoidIntegrationOff);
	Nan::SetPrototypeMethod(tpl, "slabTrapezoidIntegrationOff", SlabTrapezoidIntegrationOff);

	Nan::SetPrototypeMethod(tpl, "SlabTrapezoidIntegrationOn", SlabTrapezoidIntegrationOn);
	Nan::SetPrototypeMethod(tpl, "slabTrapezoidIntegrationOn", SlabTrapezoidIntegrationOn);

	Nan::SetPrototypeMethod(tpl, "TransformInputSamplingOff", TransformInputSamplingOff);
	Nan::SetPrototypeMethod(tpl, "transformInputSamplingOff", TransformInputSamplingOff);

	Nan::SetPrototypeMethod(tpl, "TransformInputSamplingOn", TransformInputSamplingOn);
	Nan::SetPrototypeMethod(tpl, "transformInputSamplingOn", TransformInputSamplingOn);

	Nan::SetPrototypeMethod(tpl, "WrapOff", WrapOff);
	Nan::SetPrototypeMethod(tpl, "wrapOff", WrapOff);

	Nan::SetPrototypeMethod(tpl, "WrapOn", WrapOn);
	Nan::SetPrototypeMethod(tpl, "wrapOn", WrapOn);

	ptpl.Reset( tpl );
}

void VtkImageResliceWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkImageReslice> native = vtkSmartPointer<vtkImageReslice>::New();
		VtkImageResliceWrap* obj = new VtkImageResliceWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkImageResliceWrap::AutoCropOutputOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AutoCropOutputOff();
}

void VtkImageResliceWrap::AutoCropOutputOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AutoCropOutputOn();
}

void VtkImageResliceWrap::BorderOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BorderOff();
}

void VtkImageResliceWrap::BorderOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BorderOn();
}

void VtkImageResliceWrap::GenerateStencilOutputOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateStencilOutputOff();
}

void VtkImageResliceWrap::GenerateStencilOutputOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateStencilOutputOn();
}

void VtkImageResliceWrap::GetAutoCropOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAutoCropOutput();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetBackgroundLevel(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetBackgroundLevel();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetBorder(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetBorder();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkImageResliceWrap::GetGenerateStencilOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateStencilOutput();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetInformationInput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	vtkImageData * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInformationInput();
		VtkImageDataWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkImageDataWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkImageDataWrap *w = new VtkImageDataWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkImageResliceWrap::GetInterpolate(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInterpolate();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetInterpolationMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInterpolationMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetInterpolationModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInterpolationModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkImageResliceWrap::GetInterpolationModeMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInterpolationModeMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetInterpolationModeMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInterpolationModeMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetInterpolator(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	vtkAbstractImageInterpolator * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInterpolator();
		VtkAbstractImageInterpolatorWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkAbstractImageInterpolatorWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkAbstractImageInterpolatorWrap *w = new VtkAbstractImageInterpolatorWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkImageResliceWrap::GetMirror(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMirror();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetOptimization(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOptimization();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetOutputDimensionality(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOutputDimensionality();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetOutputScalarType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOutputScalarType();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetResliceAxes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	vtkMatrix4x4 * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetResliceAxes();
		VtkMatrix4x4Wrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkImageResliceWrap::GetResliceAxesDirectionCosines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() > 1 && info[1]->IsFloat64Array())
		{
			v8::Local<v8::Float64Array>a1(v8::Local<v8::Float64Array>::Cast(info[1]->ToObject()));
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			if(info.Length() > 2 && info[2]->IsFloat64Array())
			{
				v8::Local<v8::Float64Array>a2(v8::Local<v8::Float64Array>::Cast(info[2]->ToObject()));
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->GetResliceAxesDirectionCosines(
					(double *)(a0->Buffer()->GetContents().Data()),
					(double *)(a1->Buffer()->GetContents().Data()),
					(double *)(a2->Buffer()->GetContents().Data())
				);
				return;
			}
			else if(info.Length() > 2 && info[2]->IsArray())
			{
				v8::Local<v8::Array>a2(v8::Local<v8::Array>::Cast(info[2]->ToObject()));
				double b2[3];
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				for( i = 0; i < 3; i++ )
				{
					if( !a2->Get(i)->IsNumber() )
					{
						Nan::ThrowError("Array contents invalid.");
						return;
					}
					b2[i] = a2->Get(i)->NumberValue();
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->GetResliceAxesDirectionCosines(
					(double *)(a0->Buffer()->GetContents().Data()),
					(double *)(a1->Buffer()->GetContents().Data()),
					b2
				);
				return;
			}
		}
		else if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[3];
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 3; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
			if(info.Length() > 2 && info[2]->IsArray())
			{
				v8::Local<v8::Array>a2(v8::Local<v8::Array>::Cast(info[2]->ToObject()));
				double b2[3];
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				for( i = 0; i < 3; i++ )
				{
					if( !a2->Get(i)->IsNumber() )
					{
						Nan::ThrowError("Array contents invalid.");
						return;
					}
					b2[i] = a2->Get(i)->NumberValue();
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->GetResliceAxesDirectionCosines(
					(double *)(a0->Buffer()->GetContents().Data()),
					b1,
					b2
				);
				return;
			}
		}
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[3];
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 3; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
			if(info.Length() > 2 && info[2]->IsArray())
			{
				v8::Local<v8::Array>a2(v8::Local<v8::Array>::Cast(info[2]->ToObject()));
				double b2[3];
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				for( i = 0; i < 3; i++ )
				{
					if( !a2->Get(i)->IsNumber() )
					{
						Nan::ThrowError("Array contents invalid.");
						return;
					}
					b2[i] = a2->Get(i)->NumberValue();
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->GetResliceAxesDirectionCosines(
					b0,
					b1,
					b2
				);
				return;
			}
		}
		else if(info.Length() > 1 && info[1]->IsFloat64Array())
		{
			v8::Local<v8::Float64Array>a1(v8::Local<v8::Float64Array>::Cast(info[1]->ToObject()));
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			if(info.Length() > 2 && info[2]->IsArray())
			{
				v8::Local<v8::Array>a2(v8::Local<v8::Array>::Cast(info[2]->ToObject()));
				double b2[3];
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				for( i = 0; i < 3; i++ )
				{
					if( !a2->Get(i)->IsNumber() )
					{
						Nan::ThrowError("Array contents invalid.");
						return;
					}
					b2[i] = a2->Get(i)->NumberValue();
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->GetResliceAxesDirectionCosines(
					b0,
					(double *)(a1->Buffer()->GetContents().Data()),
					b2
				);
				return;
			}
		}
	}
	else if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[3];
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 3; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
			if(info.Length() > 2 && info[2]->IsFloat64Array())
			{
				v8::Local<v8::Float64Array>a2(v8::Local<v8::Float64Array>::Cast(info[2]->ToObject()));
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->GetResliceAxesDirectionCosines(
					(double *)(a0->Buffer()->GetContents().Data()),
					b1,
					(double *)(a2->Buffer()->GetContents().Data())
				);
				return;
			}
		}
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[3];
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 3; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
			if(info.Length() > 2 && info[2]->IsFloat64Array())
			{
				v8::Local<v8::Float64Array>a2(v8::Local<v8::Float64Array>::Cast(info[2]->ToObject()));
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->GetResliceAxesDirectionCosines(
					b0,
					b1,
					(double *)(a2->Buffer()->GetContents().Data())
				);
				return;
			}
		}
		else if(info.Length() > 1 && info[1]->IsFloat64Array())
		{
			v8::Local<v8::Float64Array>a1(v8::Local<v8::Float64Array>::Cast(info[1]->ToObject()));
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			if(info.Length() > 2 && info[2]->IsFloat64Array())
			{
				v8::Local<v8::Float64Array>a2(v8::Local<v8::Float64Array>::Cast(info[2]->ToObject()));
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->GetResliceAxesDirectionCosines(
					b0,
					(double *)(a1->Buffer()->GetContents().Data()),
					(double *)(a2->Buffer()->GetContents().Data())
				);
				return;
			}
		}
	}
	else if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 9 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->GetResliceAxesDirectionCosines(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[9];
		if( a0->Length() < 9 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 9; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->GetResliceAxesDirectionCosines(
			b0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::GetResliceAxesOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->GetResliceAxesOrigin(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->GetResliceAxesOrigin(
			b0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::GetResliceTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	vtkAbstractTransform * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetResliceTransform();
		VtkAbstractTransformWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkAbstractTransformWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkAbstractTransformWrap *w = new VtkAbstractTransformWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkImageResliceWrap::GetScalarScale(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalarScale();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetScalarShift(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalarShift();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetSlabMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSlabMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetSlabModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSlabModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkImageResliceWrap::GetSlabModeMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSlabModeMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetSlabModeMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSlabModeMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetSlabNumberOfSlices(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSlabNumberOfSlices();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetSlabSliceSpacingFraction(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSlabSliceSpacingFraction();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetSlabTrapezoidIntegration(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSlabTrapezoidIntegration();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetStencil(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	vtkImageStencilData * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStencil();
		VtkImageStencilDataWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkImageStencilDataWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkImageStencilDataWrap *w = new VtkImageStencilDataWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkImageResliceWrap::GetStencilOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	vtkImageStencilData * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStencilOutput();
		VtkImageStencilDataWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkImageStencilDataWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkImageStencilDataWrap *w = new VtkImageStencilDataWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkImageResliceWrap::GetStencilOutputPort(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	vtkAlgorithmOutput * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStencilOutputPort();
		VtkAlgorithmOutputWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkAlgorithmOutputWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkAlgorithmOutputWrap *w = new VtkAlgorithmOutputWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkImageResliceWrap::GetTransformInputSampling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTransformInputSampling();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::GetWrap(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetWrap();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkImageResliceWrap::InterpolateOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->InterpolateOff();
}

void VtkImageResliceWrap::InterpolateOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->InterpolateOn();
}

void VtkImageResliceWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::MirrorOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->MirrorOff();
}

void VtkImageResliceWrap::MirrorOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->MirrorOn();
}

void VtkImageResliceWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	vtkImageReslice * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkImageResliceWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkImageResliceWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkImageResliceWrap *w = new VtkImageResliceWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkImageResliceWrap::OptimizationOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OptimizationOff();
}

void VtkImageResliceWrap::OptimizationOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OptimizationOn();
}

void VtkImageResliceWrap::ReportReferences(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkGarbageCollectorWrap::ptpl))->HasInstance(info[0]))
	{
		VtkGarbageCollectorWrap *a0 = ObjectWrap::Unwrap<VtkGarbageCollectorWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->ReportReferences(
			(vtkGarbageCollector *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkImageReslice * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkImageResliceWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkImageResliceWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkImageResliceWrap *w = new VtkImageResliceWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetAutoCropOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAutoCropOutput(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetBackgroundColor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 4 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetBackgroundColor(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[4];
		if( a0->Length() < 4 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 4; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetBackgroundColor(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() > 3 && info[3]->IsNumber())
				{
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->SetBackgroundColor(
						info[0]->NumberValue(),
						info[1]->NumberValue(),
						info[2]->NumberValue(),
						info[3]->NumberValue()
					);
					return;
				}
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetBackgroundLevel(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetBackgroundLevel(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetBorder(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetBorder(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetGenerateStencilOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateStencilOutput(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetInformationInput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkImageDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkImageDataWrap *a0 = ObjectWrap::Unwrap<VtkImageDataWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInformationInput(
			(vtkImageData *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetInterpolate(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInterpolate(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetInterpolationMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInterpolationMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetInterpolationModeToCubic(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetInterpolationModeToCubic();
}

void VtkImageResliceWrap::SetInterpolationModeToLinear(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetInterpolationModeToLinear();
}

void VtkImageResliceWrap::SetInterpolationModeToNearestNeighbor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetInterpolationModeToNearestNeighbor();
}

void VtkImageResliceWrap::SetInterpolator(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAbstractImageInterpolatorWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAbstractImageInterpolatorWrap *a0 = ObjectWrap::Unwrap<VtkAbstractImageInterpolatorWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInterpolator(
			(vtkAbstractImageInterpolator *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetMirror(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMirror(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetOptimization(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOptimization(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetOutputDimensionality(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputDimensionality(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetOutputExtent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsInt32Array())
	{
		v8::Local<v8::Int32Array>a0(v8::Local<v8::Int32Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 6 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputExtent(
			(int *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		int b0[6];
		if( a0->Length() < 6 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 6; i++ )
		{
			if( !a0->Get(i)->IsInt32() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->Int32Value();
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputExtent(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() > 3 && info[3]->IsInt32())
				{
					if(info.Length() > 4 && info[4]->IsInt32())
					{
						if(info.Length() > 5 && info[5]->IsInt32())
						{
							if(info.Length() != 6)
							{
								Nan::ThrowError("Too many parameters.");
								return;
							}
							native->SetOutputExtent(
								info[0]->Int32Value(),
								info[1]->Int32Value(),
								info[2]->Int32Value(),
								info[3]->Int32Value(),
								info[4]->Int32Value(),
								info[5]->Int32Value()
							);
							return;
						}
					}
				}
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetOutputExtentToDefault(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetOutputExtentToDefault();
}

void VtkImageResliceWrap::SetOutputOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputOrigin(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputOrigin(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetOutputOrigin(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetOutputOriginToDefault(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetOutputOriginToDefault();
}

void VtkImageResliceWrap::SetOutputScalarType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputScalarType(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetOutputSpacing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputSpacing(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputSpacing(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetOutputSpacing(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetOutputSpacingToDefault(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetOutputSpacingToDefault();
}

void VtkImageResliceWrap::SetResliceAxes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkMatrix4x4Wrap::ptpl))->HasInstance(info[0]))
	{
		VtkMatrix4x4Wrap *a0 = ObjectWrap::Unwrap<VtkMatrix4x4Wrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResliceAxes(
			(vtkMatrix4x4 *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetResliceAxesDirectionCosines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() > 1 && info[1]->IsFloat64Array())
		{
			v8::Local<v8::Float64Array>a1(v8::Local<v8::Float64Array>::Cast(info[1]->ToObject()));
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			if(info.Length() > 2 && info[2]->IsFloat64Array())
			{
				v8::Local<v8::Float64Array>a2(v8::Local<v8::Float64Array>::Cast(info[2]->ToObject()));
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesDirectionCosines(
					(double *)(a0->Buffer()->GetContents().Data()),
					(double *)(a1->Buffer()->GetContents().Data()),
					(double *)(a2->Buffer()->GetContents().Data())
				);
				return;
			}
			else if(info.Length() > 2 && info[2]->IsArray())
			{
				v8::Local<v8::Array>a2(v8::Local<v8::Array>::Cast(info[2]->ToObject()));
				double b2[3];
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				for( i = 0; i < 3; i++ )
				{
					if( !a2->Get(i)->IsNumber() )
					{
						Nan::ThrowError("Array contents invalid.");
						return;
					}
					b2[i] = a2->Get(i)->NumberValue();
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesDirectionCosines(
					(double *)(a0->Buffer()->GetContents().Data()),
					(double *)(a1->Buffer()->GetContents().Data()),
					b2
				);
				return;
			}
		}
		else if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[3];
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 3; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
			if(info.Length() > 2 && info[2]->IsArray())
			{
				v8::Local<v8::Array>a2(v8::Local<v8::Array>::Cast(info[2]->ToObject()));
				double b2[3];
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				for( i = 0; i < 3; i++ )
				{
					if( !a2->Get(i)->IsNumber() )
					{
						Nan::ThrowError("Array contents invalid.");
						return;
					}
					b2[i] = a2->Get(i)->NumberValue();
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesDirectionCosines(
					(double *)(a0->Buffer()->GetContents().Data()),
					b1,
					b2
				);
				return;
			}
		}
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[3];
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 3; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
			if(info.Length() > 2 && info[2]->IsArray())
			{
				v8::Local<v8::Array>a2(v8::Local<v8::Array>::Cast(info[2]->ToObject()));
				double b2[3];
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				for( i = 0; i < 3; i++ )
				{
					if( !a2->Get(i)->IsNumber() )
					{
						Nan::ThrowError("Array contents invalid.");
						return;
					}
					b2[i] = a2->Get(i)->NumberValue();
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesDirectionCosines(
					b0,
					b1,
					b2
				);
				return;
			}
		}
		else if(info.Length() > 1 && info[1]->IsFloat64Array())
		{
			v8::Local<v8::Float64Array>a1(v8::Local<v8::Float64Array>::Cast(info[1]->ToObject()));
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			if(info.Length() > 2 && info[2]->IsArray())
			{
				v8::Local<v8::Array>a2(v8::Local<v8::Array>::Cast(info[2]->ToObject()));
				double b2[3];
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				for( i = 0; i < 3; i++ )
				{
					if( !a2->Get(i)->IsNumber() )
					{
						Nan::ThrowError("Array contents invalid.");
						return;
					}
					b2[i] = a2->Get(i)->NumberValue();
				}
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesDirectionCosines(
					b0,
					(double *)(a1->Buffer()->GetContents().Data()),
					b2
				);
				return;
			}
		}
	}
	else if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[3];
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 3; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
			if(info.Length() > 2 && info[2]->IsFloat64Array())
			{
				v8::Local<v8::Float64Array>a2(v8::Local<v8::Float64Array>::Cast(info[2]->ToObject()));
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesDirectionCosines(
					(double *)(a0->Buffer()->GetContents().Data()),
					b1,
					(double *)(a2->Buffer()->GetContents().Data())
				);
				return;
			}
		}
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[3];
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 3; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
			if(info.Length() > 2 && info[2]->IsFloat64Array())
			{
				v8::Local<v8::Float64Array>a2(v8::Local<v8::Float64Array>::Cast(info[2]->ToObject()));
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesDirectionCosines(
					b0,
					b1,
					(double *)(a2->Buffer()->GetContents().Data())
				);
				return;
			}
		}
		else if(info.Length() > 1 && info[1]->IsFloat64Array())
		{
			v8::Local<v8::Float64Array>a1(v8::Local<v8::Float64Array>::Cast(info[1]->ToObject()));
			if( a1->Length() < 3 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			if(info.Length() > 2 && info[2]->IsFloat64Array())
			{
				v8::Local<v8::Float64Array>a2(v8::Local<v8::Float64Array>::Cast(info[2]->ToObject()));
				if( a2->Length() < 3 )
				{
					Nan::ThrowError("Array too short.");
					return;
				}

				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesDirectionCosines(
					b0,
					(double *)(a1->Buffer()->GetContents().Data()),
					(double *)(a2->Buffer()->GetContents().Data())
				);
				return;
			}
		}
	}
	else if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 9 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResliceAxesDirectionCosines(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[9];
		if( a0->Length() < 9 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 9; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResliceAxesDirectionCosines(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() > 3 && info[3]->IsNumber())
				{
					if(info.Length() > 4 && info[4]->IsNumber())
					{
						if(info.Length() > 5 && info[5]->IsNumber())
						{
							if(info.Length() > 6 && info[6]->IsNumber())
							{
								if(info.Length() > 7 && info[7]->IsNumber())
								{
									if(info.Length() > 8 && info[8]->IsNumber())
									{
										if(info.Length() != 9)
										{
											Nan::ThrowError("Too many parameters.");
											return;
										}
										native->SetResliceAxesDirectionCosines(
											info[0]->NumberValue(),
											info[1]->NumberValue(),
											info[2]->NumberValue(),
											info[3]->NumberValue(),
											info[4]->NumberValue(),
											info[5]->NumberValue(),
											info[6]->NumberValue(),
											info[7]->NumberValue(),
											info[8]->NumberValue()
										);
										return;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetResliceAxesOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResliceAxesOrigin(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResliceAxesOrigin(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetResliceAxesOrigin(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetResliceTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAbstractTransformWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAbstractTransformWrap *a0 = ObjectWrap::Unwrap<VtkAbstractTransformWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetResliceTransform(
			(vtkAbstractTransform *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetScalarScale(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScalarScale(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetScalarShift(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScalarShift(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetSlabMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSlabMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetSlabModeToMax(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetSlabModeToMax();
}

void VtkImageResliceWrap::SetSlabModeToMean(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetSlabModeToMean();
}

void VtkImageResliceWrap::SetSlabModeToMin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetSlabModeToMin();
}

void VtkImageResliceWrap::SetSlabModeToSum(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetSlabModeToSum();
}

void VtkImageResliceWrap::SetSlabNumberOfSlices(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSlabNumberOfSlices(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetSlabSliceSpacingFraction(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSlabSliceSpacingFraction(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetSlabTrapezoidIntegration(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSlabTrapezoidIntegration(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetStencilData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkImageStencilDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkImageStencilDataWrap *a0 = ObjectWrap::Unwrap<VtkImageStencilDataWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStencilData(
			(vtkImageStencilData *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetStencilOutput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkImageStencilDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkImageStencilDataWrap *a0 = ObjectWrap::Unwrap<VtkImageStencilDataWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStencilOutput(
			(vtkImageStencilData *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetTransformInputSampling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTransformInputSampling(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SetWrap(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetWrap(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkImageResliceWrap::SlabTrapezoidIntegrationOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SlabTrapezoidIntegrationOff();
}

void VtkImageResliceWrap::SlabTrapezoidIntegrationOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SlabTrapezoidIntegrationOn();
}

void VtkImageResliceWrap::TransformInputSamplingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TransformInputSamplingOff();
}

void VtkImageResliceWrap::TransformInputSamplingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TransformInputSamplingOn();
}

void VtkImageResliceWrap::WrapOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->WrapOff();
}

void VtkImageResliceWrap::WrapOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkImageResliceWrap *wrapper = ObjectWrap::Unwrap<VtkImageResliceWrap>(info.Holder());
	vtkImageReslice *native = (vtkImageReslice *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->WrapOn();
}

