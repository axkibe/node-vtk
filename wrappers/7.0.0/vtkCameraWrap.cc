/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include "vtkObjectWrap.h"
#include "vtkCameraWrap.h"
#include "vtkTransformWrap.h"
#include "vtkMatrix4x4Wrap.h"
#include "vtkPerspectiveTransformWrap.h"
#include "vtkRendererWrap.h"
#include "vtkHomogeneousTransformWrap.h"
#include "../../plus/plus.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkCameraWrap::ptpl;

VtkCameraWrap::VtkCameraWrap()
{ }

VtkCameraWrap::VtkCameraWrap(vtkSmartPointer<vtkCamera> _native)
{ native = _native; }

VtkCameraWrap::~VtkCameraWrap()
{ }

void VtkCameraWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkCamera").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("Camera").ToLocalChecked(), ConstructorGetter);
}

void VtkCameraWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkCameraWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkObjectWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkObjectWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkCameraWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "ApplyTransform", ApplyTransform);
	Nan::SetPrototypeMethod(tpl, "applyTransform", ApplyTransform);

	Nan::SetPrototypeMethod(tpl, "Azimuth", Azimuth);
	Nan::SetPrototypeMethod(tpl, "azimuth", Azimuth);

	Nan::SetPrototypeMethod(tpl, "ComputeViewPlaneNormal", ComputeViewPlaneNormal);
	Nan::SetPrototypeMethod(tpl, "computeViewPlaneNormal", ComputeViewPlaneNormal);

	Nan::SetPrototypeMethod(tpl, "DeepCopy", DeepCopy);
	Nan::SetPrototypeMethod(tpl, "deepCopy", DeepCopy);

	Nan::SetPrototypeMethod(tpl, "Dolly", Dolly);
	Nan::SetPrototypeMethod(tpl, "dolly", Dolly);

	Nan::SetPrototypeMethod(tpl, "Elevation", Elevation);
	Nan::SetPrototypeMethod(tpl, "elevation", Elevation);

	Nan::SetPrototypeMethod(tpl, "GetCameraLightTransformMatrix", GetCameraLightTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "getCameraLightTransformMatrix", GetCameraLightTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetClippingRange", GetClippingRange);
	Nan::SetPrototypeMethod(tpl, "getClippingRange", GetClippingRange);

	Nan::SetPrototypeMethod(tpl, "GetCompositeProjectionTransformMatrix", GetCompositeProjectionTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "getCompositeProjectionTransformMatrix", GetCompositeProjectionTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "GetDirectionOfProjection", GetDirectionOfProjection);
	Nan::SetPrototypeMethod(tpl, "getDirectionOfProjection", GetDirectionOfProjection);

	Nan::SetPrototypeMethod(tpl, "GetDistance", GetDistance);
	Nan::SetPrototypeMethod(tpl, "getDistance", GetDistance);

	Nan::SetPrototypeMethod(tpl, "GetEyeAngle", GetEyeAngle);
	Nan::SetPrototypeMethod(tpl, "getEyeAngle", GetEyeAngle);

	Nan::SetPrototypeMethod(tpl, "GetEyePlaneNormal", GetEyePlaneNormal);
	Nan::SetPrototypeMethod(tpl, "getEyePlaneNormal", GetEyePlaneNormal);

	Nan::SetPrototypeMethod(tpl, "GetEyePosition", GetEyePosition);
	Nan::SetPrototypeMethod(tpl, "getEyePosition", GetEyePosition);

	Nan::SetPrototypeMethod(tpl, "GetEyeSeparation", GetEyeSeparation);
	Nan::SetPrototypeMethod(tpl, "getEyeSeparation", GetEyeSeparation);

	Nan::SetPrototypeMethod(tpl, "GetEyeTransformMatrix", GetEyeTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "getEyeTransformMatrix", GetEyeTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "GetFocalDisk", GetFocalDisk);
	Nan::SetPrototypeMethod(tpl, "getFocalDisk", GetFocalDisk);

	Nan::SetPrototypeMethod(tpl, "GetFocalPoint", GetFocalPoint);
	Nan::SetPrototypeMethod(tpl, "getFocalPoint", GetFocalPoint);

	Nan::SetPrototypeMethod(tpl, "GetFreezeFocalPoint", GetFreezeFocalPoint);
	Nan::SetPrototypeMethod(tpl, "getFreezeFocalPoint", GetFreezeFocalPoint);

	Nan::SetPrototypeMethod(tpl, "GetFrustumPlanes", GetFrustumPlanes);
	Nan::SetPrototypeMethod(tpl, "getFrustumPlanes", GetFrustumPlanes);

	Nan::SetPrototypeMethod(tpl, "GetLeftEye", GetLeftEye);
	Nan::SetPrototypeMethod(tpl, "getLeftEye", GetLeftEye);

	Nan::SetPrototypeMethod(tpl, "GetModelTransformMatrix", GetModelTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "getModelTransformMatrix", GetModelTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "GetModelViewTransformMatrix", GetModelViewTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "getModelViewTransformMatrix", GetModelViewTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "GetModelViewTransformObject", GetModelViewTransformObject);
	Nan::SetPrototypeMethod(tpl, "getModelViewTransformObject", GetModelViewTransformObject);

	Nan::SetPrototypeMethod(tpl, "GetOrientation", GetOrientation);
	Nan::SetPrototypeMethod(tpl, "getOrientation", GetOrientation);

	Nan::SetPrototypeMethod(tpl, "GetOrientationWXYZ", GetOrientationWXYZ);
	Nan::SetPrototypeMethod(tpl, "getOrientationWXYZ", GetOrientationWXYZ);

	Nan::SetPrototypeMethod(tpl, "GetParallelProjection", GetParallelProjection);
	Nan::SetPrototypeMethod(tpl, "getParallelProjection", GetParallelProjection);

	Nan::SetPrototypeMethod(tpl, "GetParallelScale", GetParallelScale);
	Nan::SetPrototypeMethod(tpl, "getParallelScale", GetParallelScale);

	Nan::SetPrototypeMethod(tpl, "GetPosition", GetPosition);
	Nan::SetPrototypeMethod(tpl, "getPosition", GetPosition);

	Nan::SetPrototypeMethod(tpl, "GetProjectionTransformMatrix", GetProjectionTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "getProjectionTransformMatrix", GetProjectionTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "GetProjectionTransformObject", GetProjectionTransformObject);
	Nan::SetPrototypeMethod(tpl, "getProjectionTransformObject", GetProjectionTransformObject);

	Nan::SetPrototypeMethod(tpl, "GetRoll", GetRoll);
	Nan::SetPrototypeMethod(tpl, "getRoll", GetRoll);

	Nan::SetPrototypeMethod(tpl, "GetScreenBottomLeft", GetScreenBottomLeft);
	Nan::SetPrototypeMethod(tpl, "getScreenBottomLeft", GetScreenBottomLeft);

	Nan::SetPrototypeMethod(tpl, "GetScreenBottomRight", GetScreenBottomRight);
	Nan::SetPrototypeMethod(tpl, "getScreenBottomRight", GetScreenBottomRight);

	Nan::SetPrototypeMethod(tpl, "GetScreenTopRight", GetScreenTopRight);
	Nan::SetPrototypeMethod(tpl, "getScreenTopRight", GetScreenTopRight);

	Nan::SetPrototypeMethod(tpl, "GetThickness", GetThickness);
	Nan::SetPrototypeMethod(tpl, "getThickness", GetThickness);

	Nan::SetPrototypeMethod(tpl, "GetUseHorizontalViewAngle", GetUseHorizontalViewAngle);
	Nan::SetPrototypeMethod(tpl, "getUseHorizontalViewAngle", GetUseHorizontalViewAngle);

	Nan::SetPrototypeMethod(tpl, "GetUseOffAxisProjection", GetUseOffAxisProjection);
	Nan::SetPrototypeMethod(tpl, "getUseOffAxisProjection", GetUseOffAxisProjection);

	Nan::SetPrototypeMethod(tpl, "GetUseScissor", GetUseScissor);
	Nan::SetPrototypeMethod(tpl, "getUseScissor", GetUseScissor);

	Nan::SetPrototypeMethod(tpl, "GetUserTransform", GetUserTransform);
	Nan::SetPrototypeMethod(tpl, "getUserTransform", GetUserTransform);

	Nan::SetPrototypeMethod(tpl, "GetUserViewTransform", GetUserViewTransform);
	Nan::SetPrototypeMethod(tpl, "getUserViewTransform", GetUserViewTransform);

	Nan::SetPrototypeMethod(tpl, "GetViewAngle", GetViewAngle);
	Nan::SetPrototypeMethod(tpl, "getViewAngle", GetViewAngle);

	Nan::SetPrototypeMethod(tpl, "GetViewPlaneNormal", GetViewPlaneNormal);
	Nan::SetPrototypeMethod(tpl, "getViewPlaneNormal", GetViewPlaneNormal);

	Nan::SetPrototypeMethod(tpl, "GetViewShear", GetViewShear);
	Nan::SetPrototypeMethod(tpl, "getViewShear", GetViewShear);

	Nan::SetPrototypeMethod(tpl, "GetViewTransformMatrix", GetViewTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "getViewTransformMatrix", GetViewTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "GetViewTransformObject", GetViewTransformObject);
	Nan::SetPrototypeMethod(tpl, "getViewTransformObject", GetViewTransformObject);

	Nan::SetPrototypeMethod(tpl, "GetViewUp", GetViewUp);
	Nan::SetPrototypeMethod(tpl, "getViewUp", GetViewUp);

	Nan::SetPrototypeMethod(tpl, "GetWindowCenter", GetWindowCenter);
	Nan::SetPrototypeMethod(tpl, "getWindowCenter", GetWindowCenter);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "OrthogonalizeViewUp", OrthogonalizeViewUp);
	Nan::SetPrototypeMethod(tpl, "orthogonalizeViewUp", OrthogonalizeViewUp);

	Nan::SetPrototypeMethod(tpl, "ParallelProjectionOff", ParallelProjectionOff);
	Nan::SetPrototypeMethod(tpl, "parallelProjectionOff", ParallelProjectionOff);

	Nan::SetPrototypeMethod(tpl, "ParallelProjectionOn", ParallelProjectionOn);
	Nan::SetPrototypeMethod(tpl, "parallelProjectionOn", ParallelProjectionOn);

	Nan::SetPrototypeMethod(tpl, "Pitch", Pitch);
	Nan::SetPrototypeMethod(tpl, "pitch", Pitch);

	Nan::SetPrototypeMethod(tpl, "Render", Render);
	Nan::SetPrototypeMethod(tpl, "render", Render);

	Nan::SetPrototypeMethod(tpl, "Roll", Roll);
	Nan::SetPrototypeMethod(tpl, "roll", Roll);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetClippingRange", SetClippingRange);
	Nan::SetPrototypeMethod(tpl, "setClippingRange", SetClippingRange);

	Nan::SetPrototypeMethod(tpl, "SetDistance", SetDistance);
	Nan::SetPrototypeMethod(tpl, "setDistance", SetDistance);

	Nan::SetPrototypeMethod(tpl, "SetEyeAngle", SetEyeAngle);
	Nan::SetPrototypeMethod(tpl, "setEyeAngle", SetEyeAngle);

	Nan::SetPrototypeMethod(tpl, "SetEyePosition", SetEyePosition);
	Nan::SetPrototypeMethod(tpl, "setEyePosition", SetEyePosition);

	Nan::SetPrototypeMethod(tpl, "SetEyeSeparation", SetEyeSeparation);
	Nan::SetPrototypeMethod(tpl, "setEyeSeparation", SetEyeSeparation);

	Nan::SetPrototypeMethod(tpl, "SetEyeTransformMatrix", SetEyeTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "setEyeTransformMatrix", SetEyeTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "SetFocalDisk", SetFocalDisk);
	Nan::SetPrototypeMethod(tpl, "setFocalDisk", SetFocalDisk);

	Nan::SetPrototypeMethod(tpl, "SetFocalPoint", SetFocalPoint);
	Nan::SetPrototypeMethod(tpl, "setFocalPoint", SetFocalPoint);

	Nan::SetPrototypeMethod(tpl, "SetFreezeFocalPoint", SetFreezeFocalPoint);
	Nan::SetPrototypeMethod(tpl, "setFreezeFocalPoint", SetFreezeFocalPoint);

	Nan::SetPrototypeMethod(tpl, "SetLeftEye", SetLeftEye);
	Nan::SetPrototypeMethod(tpl, "setLeftEye", SetLeftEye);

	Nan::SetPrototypeMethod(tpl, "SetModelTransformMatrix", SetModelTransformMatrix);
	Nan::SetPrototypeMethod(tpl, "setModelTransformMatrix", SetModelTransformMatrix);

	Nan::SetPrototypeMethod(tpl, "SetObliqueAngles", SetObliqueAngles);
	Nan::SetPrototypeMethod(tpl, "setObliqueAngles", SetObliqueAngles);

	Nan::SetPrototypeMethod(tpl, "SetParallelProjection", SetParallelProjection);
	Nan::SetPrototypeMethod(tpl, "setParallelProjection", SetParallelProjection);

	Nan::SetPrototypeMethod(tpl, "SetParallelScale", SetParallelScale);
	Nan::SetPrototypeMethod(tpl, "setParallelScale", SetParallelScale);

	Nan::SetPrototypeMethod(tpl, "SetPosition", SetPosition);
	Nan::SetPrototypeMethod(tpl, "setPosition", SetPosition);

	Nan::SetPrototypeMethod(tpl, "SetRoll", SetRoll);
	Nan::SetPrototypeMethod(tpl, "setRoll", SetRoll);

	Nan::SetPrototypeMethod(tpl, "SetScreenBottomLeft", SetScreenBottomLeft);
	Nan::SetPrototypeMethod(tpl, "setScreenBottomLeft", SetScreenBottomLeft);

	Nan::SetPrototypeMethod(tpl, "SetScreenBottomRight", SetScreenBottomRight);
	Nan::SetPrototypeMethod(tpl, "setScreenBottomRight", SetScreenBottomRight);

	Nan::SetPrototypeMethod(tpl, "SetScreenTopRight", SetScreenTopRight);
	Nan::SetPrototypeMethod(tpl, "setScreenTopRight", SetScreenTopRight);

	Nan::SetPrototypeMethod(tpl, "SetThickness", SetThickness);
	Nan::SetPrototypeMethod(tpl, "setThickness", SetThickness);

	Nan::SetPrototypeMethod(tpl, "SetUseHorizontalViewAngle", SetUseHorizontalViewAngle);
	Nan::SetPrototypeMethod(tpl, "setUseHorizontalViewAngle", SetUseHorizontalViewAngle);

	Nan::SetPrototypeMethod(tpl, "SetUseOffAxisProjection", SetUseOffAxisProjection);
	Nan::SetPrototypeMethod(tpl, "setUseOffAxisProjection", SetUseOffAxisProjection);

	Nan::SetPrototypeMethod(tpl, "SetUseScissor", SetUseScissor);
	Nan::SetPrototypeMethod(tpl, "setUseScissor", SetUseScissor);

	Nan::SetPrototypeMethod(tpl, "SetUserTransform", SetUserTransform);
	Nan::SetPrototypeMethod(tpl, "setUserTransform", SetUserTransform);

	Nan::SetPrototypeMethod(tpl, "SetUserViewTransform", SetUserViewTransform);
	Nan::SetPrototypeMethod(tpl, "setUserViewTransform", SetUserViewTransform);

	Nan::SetPrototypeMethod(tpl, "SetViewAngle", SetViewAngle);
	Nan::SetPrototypeMethod(tpl, "setViewAngle", SetViewAngle);

	Nan::SetPrototypeMethod(tpl, "SetViewShear", SetViewShear);
	Nan::SetPrototypeMethod(tpl, "setViewShear", SetViewShear);

	Nan::SetPrototypeMethod(tpl, "SetViewUp", SetViewUp);
	Nan::SetPrototypeMethod(tpl, "setViewUp", SetViewUp);

	Nan::SetPrototypeMethod(tpl, "SetWindowCenter", SetWindowCenter);
	Nan::SetPrototypeMethod(tpl, "setWindowCenter", SetWindowCenter);

	Nan::SetPrototypeMethod(tpl, "ShallowCopy", ShallowCopy);
	Nan::SetPrototypeMethod(tpl, "shallowCopy", ShallowCopy);

	Nan::SetPrototypeMethod(tpl, "UpdateViewport", UpdateViewport);
	Nan::SetPrototypeMethod(tpl, "updateViewport", UpdateViewport);

	Nan::SetPrototypeMethod(tpl, "UseHorizontalViewAngleOff", UseHorizontalViewAngleOff);
	Nan::SetPrototypeMethod(tpl, "useHorizontalViewAngleOff", UseHorizontalViewAngleOff);

	Nan::SetPrototypeMethod(tpl, "UseHorizontalViewAngleOn", UseHorizontalViewAngleOn);
	Nan::SetPrototypeMethod(tpl, "useHorizontalViewAngleOn", UseHorizontalViewAngleOn);

	Nan::SetPrototypeMethod(tpl, "UseOffAxisProjectionOff", UseOffAxisProjectionOff);
	Nan::SetPrototypeMethod(tpl, "useOffAxisProjectionOff", UseOffAxisProjectionOff);

	Nan::SetPrototypeMethod(tpl, "UseOffAxisProjectionOn", UseOffAxisProjectionOn);
	Nan::SetPrototypeMethod(tpl, "useOffAxisProjectionOn", UseOffAxisProjectionOn);

	Nan::SetPrototypeMethod(tpl, "ViewingRaysModified", ViewingRaysModified);
	Nan::SetPrototypeMethod(tpl, "viewingRaysModified", ViewingRaysModified);

	Nan::SetPrototypeMethod(tpl, "Yaw", Yaw);
	Nan::SetPrototypeMethod(tpl, "yaw", Yaw);

	Nan::SetPrototypeMethod(tpl, "Zoom", Zoom);
	Nan::SetPrototypeMethod(tpl, "zoom", Zoom);

#ifdef VTK_NODE_PLUS_VTKCAMERAWRAP_INITPTPL
	VTK_NODE_PLUS_VTKCAMERAWRAP_INITPTPL
#endif
	ptpl.Reset( tpl );
}

void VtkCameraWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkCamera> native = vtkSmartPointer<vtkCamera>::New();
		VtkCameraWrap* obj = new VtkCameraWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkCameraWrap::ApplyTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkTransformWrap::ptpl))->HasInstance(info[0]))
	{
		VtkTransformWrap *a0 = ObjectWrap::Unwrap<VtkTransformWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->ApplyTransform(
			(vtkTransform *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::Azimuth(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->Azimuth(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::ComputeViewPlaneNormal(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ComputeViewPlaneNormal();
}

void VtkCameraWrap::DeepCopy(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkCameraWrap::ptpl))->HasInstance(info[0]))
	{
		VtkCameraWrap *a0 = ObjectWrap::Unwrap<VtkCameraWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->DeepCopy(
			(vtkCamera *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::Dolly(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->Dolly(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::Elevation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->Elevation(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::GetCameraLightTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkMatrix4x4 * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCameraLightTransformMatrix();
	VtkMatrix4x4Wrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCameraWrap::GetClippingRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClippingRange();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 2 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 2);
	memcpy(ab->GetContents().Data(), r, 2 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetCompositeProjectionTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				vtkMatrix4x4 * r;
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				r = native->GetCompositeProjectionTransformMatrix(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				VtkMatrix4x4Wrap::InitPtpl();
				v8::Local<v8::Value> argv[1] =
					{ Nan::New(vtkNodeJsNoWrap) };
				v8::Local<v8::Function> cons =
					Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
				v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
				VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
				w->native = r;
				w->Wrap(wo);
				info.GetReturnValue().Set(wo);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::GetDirectionOfProjection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDirectionOfProjection();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetDistance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDistance();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetEyeAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEyeAngle();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetEyePlaneNormal(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->GetEyePlaneNormal(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->GetEyePlaneNormal(
			b0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::GetEyePosition(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->GetEyePosition(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->GetEyePosition(
			b0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::GetEyeSeparation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEyeSeparation();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetEyeTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkMatrix4x4 * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEyeTransformMatrix();
	VtkMatrix4x4Wrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetFocalDisk(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFocalDisk();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetFocalPoint(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFocalPoint();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetFreezeFocalPoint(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFreezeFocalPoint();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetFrustumPlanes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsFloat64Array())
		{
			v8::Local<v8::Float64Array>a1(v8::Local<v8::Float64Array>::Cast(info[1]->ToObject()));
			if( a1->Length() < 24 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->GetFrustumPlanes(
				info[0]->NumberValue(),
				(double *)(a1->Buffer()->GetContents().Data())
			);
			return;
		}
		else if(info.Length() > 1 && info[1]->IsArray())
		{
			v8::Local<v8::Array>a1(v8::Local<v8::Array>::Cast(info[1]->ToObject()));
			double b1[24];
			if( a1->Length() < 24 )
			{
				Nan::ThrowError("Array too short.");
				return;
			}

			for( i = 0; i < 24; i++ )
			{
				if( !a1->Get(i)->IsNumber() )
				{
					Nan::ThrowError("Array contents invalid.");
					return;
				}
				b1[i] = a1->Get(i)->NumberValue();
			}
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->GetFrustumPlanes(
				info[0]->NumberValue(),
				b1
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::GetLeftEye(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLeftEye();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetModelTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkMatrix4x4 * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetModelTransformMatrix();
	VtkMatrix4x4Wrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetModelViewTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkMatrix4x4 * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetModelViewTransformMatrix();
	VtkMatrix4x4Wrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetModelViewTransformObject(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkTransform * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetModelViewTransformObject();
	VtkTransformWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkTransformWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkTransformWrap *w = new VtkTransformWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetOrientation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOrientation();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetOrientationWXYZ(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOrientationWXYZ();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 4 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 4);
	memcpy(ab->GetContents().Data(), r, 4 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetParallelProjection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetParallelProjection();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetParallelScale(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetParallelScale();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetPosition(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPosition();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetProjectionTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkRendererWrap::ptpl))->HasInstance(info[0]))
	{
		VtkRendererWrap *a0 = ObjectWrap::Unwrap<VtkRendererWrap>(info[0]->ToObject());
		vtkMatrix4x4 * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetProjectionTransformMatrix(
			(vtkRenderer *) a0->native.GetPointer()
		);
		VtkMatrix4x4Wrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				vtkMatrix4x4 * r;
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				r = native->GetProjectionTransformMatrix(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				VtkMatrix4x4Wrap::InitPtpl();
				v8::Local<v8::Value> argv[1] =
					{ Nan::New(vtkNodeJsNoWrap) };
				v8::Local<v8::Function> cons =
					Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
				v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
				VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
				w->native = r;
				w->Wrap(wo);
				info.GetReturnValue().Set(wo);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::GetProjectionTransformObject(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				vtkPerspectiveTransform * r;
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				r = native->GetProjectionTransformObject(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				VtkPerspectiveTransformWrap::InitPtpl();
				v8::Local<v8::Value> argv[1] =
					{ Nan::New(vtkNodeJsNoWrap) };
				v8::Local<v8::Function> cons =
					Nan::New<v8::FunctionTemplate>(VtkPerspectiveTransformWrap::ptpl)->GetFunction();
				v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
				VtkPerspectiveTransformWrap *w = new VtkPerspectiveTransformWrap();
				w->native = r;
				w->Wrap(wo);
				info.GetReturnValue().Set(wo);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::GetRoll(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRoll();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetScreenBottomLeft(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScreenBottomLeft();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetScreenBottomRight(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScreenBottomRight();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetScreenTopRight(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScreenTopRight();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetThickness(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetThickness();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetUseHorizontalViewAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseHorizontalViewAngle();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetUseOffAxisProjection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseOffAxisProjection();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetUseScissor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseScissor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetUserTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkHomogeneousTransform * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUserTransform();
	VtkHomogeneousTransformWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkHomogeneousTransformWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkHomogeneousTransformWrap *w = new VtkHomogeneousTransformWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetUserViewTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkHomogeneousTransform * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUserViewTransform();
	VtkHomogeneousTransformWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkHomogeneousTransformWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkHomogeneousTransformWrap *w = new VtkHomogeneousTransformWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetViewAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewAngle();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCameraWrap::GetViewPlaneNormal(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewPlaneNormal();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetViewShear(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewShear();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetViewTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkMatrix4x4 * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewTransformMatrix();
	VtkMatrix4x4Wrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkMatrix4x4Wrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkMatrix4x4Wrap *w = new VtkMatrix4x4Wrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetViewTransformObject(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkTransform * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewTransformObject();
	VtkTransformWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkTransformWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkTransformWrap *w = new VtkTransformWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::GetViewUp(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewUp();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 3 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 3);
	memcpy(ab->GetContents().Data(), r, 3 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::GetWindowCenter(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetWindowCenter();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 2 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 2);
	memcpy(ab->GetContents().Data(), r, 2 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkCameraWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	vtkCamera * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	VtkCameraWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkCameraWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkCameraWrap *w = new VtkCameraWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCameraWrap::OrthogonalizeViewUp(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OrthogonalizeViewUp();
}

void VtkCameraWrap::ParallelProjectionOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ParallelProjectionOff();
}

void VtkCameraWrap::ParallelProjectionOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ParallelProjectionOn();
}

void VtkCameraWrap::Pitch(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->Pitch(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::Render(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkRendererWrap::ptpl))->HasInstance(info[0]))
	{
		VtkRendererWrap *a0 = ObjectWrap::Unwrap<VtkRendererWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->Render(
			(vtkRenderer *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::Roll(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->Roll(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkCamera * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
		VtkCameraWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkCameraWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkCameraWrap *w = new VtkCameraWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetClippingRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 2 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetClippingRange(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[2];
		if( a0->Length() < 2 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 2; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetClippingRange(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetClippingRange(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetDistance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDistance(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetEyeAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEyeAngle(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetEyePosition(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEyePosition(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEyePosition(
			b0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetEyeSeparation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEyeSeparation(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetEyeTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 16 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEyeTransformMatrix(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[16];
		if( a0->Length() < 16 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 16; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEyeTransformMatrix(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkMatrix4x4Wrap::ptpl))->HasInstance(info[0]))
	{
		VtkMatrix4x4Wrap *a0 = ObjectWrap::Unwrap<VtkMatrix4x4Wrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEyeTransformMatrix(
			(vtkMatrix4x4 *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetFocalDisk(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFocalDisk(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetFocalPoint(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFocalPoint(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFocalPoint(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
								if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetFocalPoint(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetFreezeFocalPoint(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFreezeFocalPoint(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetLeftEye(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetLeftEye(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetModelTransformMatrix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 16 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetModelTransformMatrix(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[16];
		if( a0->Length() < 16 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 16; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetModelTransformMatrix(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkMatrix4x4Wrap::ptpl))->HasInstance(info[0]))
	{
		VtkMatrix4x4Wrap *a0 = ObjectWrap::Unwrap<VtkMatrix4x4Wrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetModelTransformMatrix(
			(vtkMatrix4x4 *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetObliqueAngles(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetObliqueAngles(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetParallelProjection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetParallelProjection(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetParallelScale(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetParallelScale(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetPosition(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetPosition(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetPosition(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
								if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetPosition(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetRoll(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetRoll(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetScreenBottomLeft(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScreenBottomLeft(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScreenBottomLeft(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
								if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetScreenBottomLeft(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetScreenBottomRight(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScreenBottomRight(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScreenBottomRight(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
								if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetScreenBottomRight(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetScreenTopRight(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScreenTopRight(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScreenTopRight(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
								if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetScreenTopRight(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetThickness(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetThickness(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetUseHorizontalViewAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseHorizontalViewAngle(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetUseOffAxisProjection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseOffAxisProjection(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetUseScissor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseScissor(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetUserTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkHomogeneousTransformWrap::ptpl))->HasInstance(info[0]))
	{
		VtkHomogeneousTransformWrap *a0 = ObjectWrap::Unwrap<VtkHomogeneousTransformWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUserTransform(
			(vtkHomogeneousTransform *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetUserViewTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkHomogeneousTransformWrap::ptpl))->HasInstance(info[0]))
	{
		VtkHomogeneousTransformWrap *a0 = ObjectWrap::Unwrap<VtkHomogeneousTransformWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUserViewTransform(
			(vtkHomogeneousTransform *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetViewAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetViewAngle(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetViewShear(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetViewShear(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetViewShear(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
								if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetViewShear(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetViewUp(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetViewUp(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[3];
		if( a0->Length() < 3 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 3; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetViewUp(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
								if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetViewUp(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::SetWindowCenter(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetWindowCenter(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::ShallowCopy(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkCameraWrap::ptpl))->HasInstance(info[0]))
	{
		VtkCameraWrap *a0 = ObjectWrap::Unwrap<VtkCameraWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->ShallowCopy(
			(vtkCamera *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::UpdateViewport(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkRendererWrap::ptpl))->HasInstance(info[0]))
	{
		VtkRendererWrap *a0 = ObjectWrap::Unwrap<VtkRendererWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->UpdateViewport(
			(vtkRenderer *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::UseHorizontalViewAngleOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseHorizontalViewAngleOff();
}

void VtkCameraWrap::UseHorizontalViewAngleOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseHorizontalViewAngleOn();
}

void VtkCameraWrap::UseOffAxisProjectionOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseOffAxisProjectionOff();
}

void VtkCameraWrap::UseOffAxisProjectionOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseOffAxisProjectionOn();
}

void VtkCameraWrap::ViewingRaysModified(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ViewingRaysModified();
}

void VtkCameraWrap::Yaw(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->Yaw(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCameraWrap::Zoom(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCameraWrap *wrapper = ObjectWrap::Unwrap<VtkCameraWrap>(info.Holder());
	vtkCamera *native = (vtkCamera *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->Zoom(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

