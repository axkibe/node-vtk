/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include "vtkWindowWrap.h"
#include "vtkRenderWindowWrap.h"
#include "vtkObjectWrap.h"
#include "vtkRendererWrap.h"
#include "vtkRendererCollectionWrap.h"
#include "vtkCollectionWrap.h"
#include "vtkRenderWindowInteractorWrap.h"
#include "vtkPainterDeviceAdapterWrap.h"
#include "../../plus/plus.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkRenderWindowWrap::ptpl;

VtkRenderWindowWrap::VtkRenderWindowWrap()
{ }

VtkRenderWindowWrap::VtkRenderWindowWrap(vtkSmartPointer<vtkRenderWindow> _native)
{ native = _native; }

VtkRenderWindowWrap::~VtkRenderWindowWrap()
{ }

void VtkRenderWindowWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkRenderWindow").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("RenderWindow").ToLocalChecked(), ConstructorGetter);
}

void VtkRenderWindowWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkRenderWindowWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkWindowWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkWindowWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkRenderWindowWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AddRenderer", AddRenderer);
	Nan::SetPrototypeMethod(tpl, "addRenderer", AddRenderer);

	Nan::SetPrototypeMethod(tpl, "AlphaBitPlanesOff", AlphaBitPlanesOff);
	Nan::SetPrototypeMethod(tpl, "alphaBitPlanesOff", AlphaBitPlanesOff);

	Nan::SetPrototypeMethod(tpl, "AlphaBitPlanesOn", AlphaBitPlanesOn);
	Nan::SetPrototypeMethod(tpl, "alphaBitPlanesOn", AlphaBitPlanesOn);

	Nan::SetPrototypeMethod(tpl, "BordersOff", BordersOff);
	Nan::SetPrototypeMethod(tpl, "bordersOff", BordersOff);

	Nan::SetPrototypeMethod(tpl, "BordersOn", BordersOn);
	Nan::SetPrototypeMethod(tpl, "bordersOn", BordersOn);

	Nan::SetPrototypeMethod(tpl, "CaptureGL2PSSpecialProps", CaptureGL2PSSpecialProps);
	Nan::SetPrototypeMethod(tpl, "captureGL2PSSpecialProps", CaptureGL2PSSpecialProps);

	Nan::SetPrototypeMethod(tpl, "CheckAbortStatus", CheckAbortStatus);
	Nan::SetPrototypeMethod(tpl, "checkAbortStatus", CheckAbortStatus);

	Nan::SetPrototypeMethod(tpl, "CheckInRenderStatus", CheckInRenderStatus);
	Nan::SetPrototypeMethod(tpl, "checkInRenderStatus", CheckInRenderStatus);

	Nan::SetPrototypeMethod(tpl, "ClearInRenderStatus", ClearInRenderStatus);
	Nan::SetPrototypeMethod(tpl, "clearInRenderStatus", ClearInRenderStatus);

	Nan::SetPrototypeMethod(tpl, "CopyResultFrame", CopyResultFrame);
	Nan::SetPrototypeMethod(tpl, "copyResultFrame", CopyResultFrame);

	Nan::SetPrototypeMethod(tpl, "FullScreenOff", FullScreenOff);
	Nan::SetPrototypeMethod(tpl, "fullScreenOff", FullScreenOff);

	Nan::SetPrototypeMethod(tpl, "FullScreenOn", FullScreenOn);
	Nan::SetPrototypeMethod(tpl, "fullScreenOn", FullScreenOn);

	Nan::SetPrototypeMethod(tpl, "GetAAFrames", GetAAFrames);
	Nan::SetPrototypeMethod(tpl, "getAAFrames", GetAAFrames);

	Nan::SetPrototypeMethod(tpl, "GetAbortRender", GetAbortRender);
	Nan::SetPrototypeMethod(tpl, "getAbortRender", GetAbortRender);

	Nan::SetPrototypeMethod(tpl, "GetAlphaBitPlanes", GetAlphaBitPlanes);
	Nan::SetPrototypeMethod(tpl, "getAlphaBitPlanes", GetAlphaBitPlanes);

	Nan::SetPrototypeMethod(tpl, "GetAnaglyphColorMask", GetAnaglyphColorMask);
	Nan::SetPrototypeMethod(tpl, "getAnaglyphColorMask", GetAnaglyphColorMask);

	Nan::SetPrototypeMethod(tpl, "GetBorders", GetBorders);
	Nan::SetPrototypeMethod(tpl, "getBorders", GetBorders);

	Nan::SetPrototypeMethod(tpl, "GetCapturingGL2PSSpecialProps", GetCapturingGL2PSSpecialProps);
	Nan::SetPrototypeMethod(tpl, "getCapturingGL2PSSpecialProps", GetCapturingGL2PSSpecialProps);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetCurrentCursor", GetCurrentCursor);
	Nan::SetPrototypeMethod(tpl, "getCurrentCursor", GetCurrentCursor);

	Nan::SetPrototypeMethod(tpl, "GetDesiredUpdateRate", GetDesiredUpdateRate);
	Nan::SetPrototypeMethod(tpl, "getDesiredUpdateRate", GetDesiredUpdateRate);

	Nan::SetPrototypeMethod(tpl, "GetDeviceIndex", GetDeviceIndex);
	Nan::SetPrototypeMethod(tpl, "getDeviceIndex", GetDeviceIndex);

	Nan::SetPrototypeMethod(tpl, "GetFDFrames", GetFDFrames);
	Nan::SetPrototypeMethod(tpl, "getFDFrames", GetFDFrames);

	Nan::SetPrototypeMethod(tpl, "GetFullScreen", GetFullScreen);
	Nan::SetPrototypeMethod(tpl, "getFullScreen", GetFullScreen);

	Nan::SetPrototypeMethod(tpl, "GetInAbortCheck", GetInAbortCheck);
	Nan::SetPrototypeMethod(tpl, "getInAbortCheck", GetInAbortCheck);

	Nan::SetPrototypeMethod(tpl, "GetInteractor", GetInteractor);
	Nan::SetPrototypeMethod(tpl, "getInteractor", GetInteractor);

	Nan::SetPrototypeMethod(tpl, "GetIsPicking", GetIsPicking);
	Nan::SetPrototypeMethod(tpl, "getIsPicking", GetIsPicking);

	Nan::SetPrototypeMethod(tpl, "GetLineSmoothing", GetLineSmoothing);
	Nan::SetPrototypeMethod(tpl, "getLineSmoothing", GetLineSmoothing);

	Nan::SetPrototypeMethod(tpl, "GetMultiSamples", GetMultiSamples);
	Nan::SetPrototypeMethod(tpl, "getMultiSamples", GetMultiSamples);

	Nan::SetPrototypeMethod(tpl, "GetNeverRendered", GetNeverRendered);
	Nan::SetPrototypeMethod(tpl, "getNeverRendered", GetNeverRendered);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfDevices", GetNumberOfDevices);
	Nan::SetPrototypeMethod(tpl, "getNumberOfDevices", GetNumberOfDevices);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfLayers", GetNumberOfLayers);
	Nan::SetPrototypeMethod(tpl, "getNumberOfLayers", GetNumberOfLayers);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfLayersMaxValue", GetNumberOfLayersMaxValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfLayersMaxValue", GetNumberOfLayersMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfLayersMinValue", GetNumberOfLayersMinValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfLayersMinValue", GetNumberOfLayersMinValue);

	Nan::SetPrototypeMethod(tpl, "GetPainterDeviceAdapter", GetPainterDeviceAdapter);
	Nan::SetPrototypeMethod(tpl, "getPainterDeviceAdapter", GetPainterDeviceAdapter);

	Nan::SetPrototypeMethod(tpl, "GetPointSmoothing", GetPointSmoothing);
	Nan::SetPrototypeMethod(tpl, "getPointSmoothing", GetPointSmoothing);

	Nan::SetPrototypeMethod(tpl, "GetPolygonSmoothing", GetPolygonSmoothing);
	Nan::SetPrototypeMethod(tpl, "getPolygonSmoothing", GetPolygonSmoothing);

	Nan::SetPrototypeMethod(tpl, "GetRenderLibrary", GetRenderLibrary);
	Nan::SetPrototypeMethod(tpl, "getRenderLibrary", GetRenderLibrary);

	Nan::SetPrototypeMethod(tpl, "GetRenderers", GetRenderers);
	Nan::SetPrototypeMethod(tpl, "getRenderers", GetRenderers);

	Nan::SetPrototypeMethod(tpl, "GetStencilCapable", GetStencilCapable);
	Nan::SetPrototypeMethod(tpl, "getStencilCapable", GetStencilCapable);

	Nan::SetPrototypeMethod(tpl, "GetStereoCapableWindow", GetStereoCapableWindow);
	Nan::SetPrototypeMethod(tpl, "getStereoCapableWindow", GetStereoCapableWindow);

	Nan::SetPrototypeMethod(tpl, "GetStereoRender", GetStereoRender);
	Nan::SetPrototypeMethod(tpl, "getStereoRender", GetStereoRender);

	Nan::SetPrototypeMethod(tpl, "GetStereoType", GetStereoType);
	Nan::SetPrototypeMethod(tpl, "getStereoType", GetStereoType);

	Nan::SetPrototypeMethod(tpl, "GetStereoTypeAsString", GetStereoTypeAsString);
	Nan::SetPrototypeMethod(tpl, "getStereoTypeAsString", GetStereoTypeAsString);

	Nan::SetPrototypeMethod(tpl, "GetSubFrames", GetSubFrames);
	Nan::SetPrototypeMethod(tpl, "getSubFrames", GetSubFrames);

	Nan::SetPrototypeMethod(tpl, "GetSwapBuffers", GetSwapBuffers);
	Nan::SetPrototypeMethod(tpl, "getSwapBuffers", GetSwapBuffers);

	Nan::SetPrototypeMethod(tpl, "GetUseConstantFDOffsets", GetUseConstantFDOffsets);
	Nan::SetPrototypeMethod(tpl, "getUseConstantFDOffsets", GetUseConstantFDOffsets);

	Nan::SetPrototypeMethod(tpl, "HasRenderer", HasRenderer);
	Nan::SetPrototypeMethod(tpl, "hasRenderer", HasRenderer);

	Nan::SetPrototypeMethod(tpl, "InitializeFromCurrentContext", InitializeFromCurrentContext);
	Nan::SetPrototypeMethod(tpl, "initializeFromCurrentContext", InitializeFromCurrentContext);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "IsDirect", IsDirect);
	Nan::SetPrototypeMethod(tpl, "isDirect", IsDirect);

	Nan::SetPrototypeMethod(tpl, "IsDrawable", IsDrawable);
	Nan::SetPrototypeMethod(tpl, "isDrawable", IsDrawable);

	Nan::SetPrototypeMethod(tpl, "IsPickingOff", IsPickingOff);
	Nan::SetPrototypeMethod(tpl, "isPickingOff", IsPickingOff);

	Nan::SetPrototypeMethod(tpl, "IsPickingOn", IsPickingOn);
	Nan::SetPrototypeMethod(tpl, "isPickingOn", IsPickingOn);

	Nan::SetPrototypeMethod(tpl, "LineSmoothingOff", LineSmoothingOff);
	Nan::SetPrototypeMethod(tpl, "lineSmoothingOff", LineSmoothingOff);

	Nan::SetPrototypeMethod(tpl, "LineSmoothingOn", LineSmoothingOn);
	Nan::SetPrototypeMethod(tpl, "lineSmoothingOn", LineSmoothingOn);

	Nan::SetPrototypeMethod(tpl, "MakeRenderWindowInteractor", MakeRenderWindowInteractor);
	Nan::SetPrototypeMethod(tpl, "makeRenderWindowInteractor", MakeRenderWindowInteractor);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "PointSmoothingOff", PointSmoothingOff);
	Nan::SetPrototypeMethod(tpl, "pointSmoothingOff", PointSmoothingOff);

	Nan::SetPrototypeMethod(tpl, "PointSmoothingOn", PointSmoothingOn);
	Nan::SetPrototypeMethod(tpl, "pointSmoothingOn", PointSmoothingOn);

	Nan::SetPrototypeMethod(tpl, "PolygonSmoothingOff", PolygonSmoothingOff);
	Nan::SetPrototypeMethod(tpl, "polygonSmoothingOff", PolygonSmoothingOff);

	Nan::SetPrototypeMethod(tpl, "PolygonSmoothingOn", PolygonSmoothingOn);
	Nan::SetPrototypeMethod(tpl, "polygonSmoothingOn", PolygonSmoothingOn);

	Nan::SetPrototypeMethod(tpl, "RemoveRenderer", RemoveRenderer);
	Nan::SetPrototypeMethod(tpl, "removeRenderer", RemoveRenderer);

	Nan::SetPrototypeMethod(tpl, "Render", Render);
	Nan::SetPrototypeMethod(tpl, "render", Render);

	Nan::SetPrototypeMethod(tpl, "ReportCapabilities", ReportCapabilities);
	Nan::SetPrototypeMethod(tpl, "reportCapabilities", ReportCapabilities);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetAAFrames", SetAAFrames);
	Nan::SetPrototypeMethod(tpl, "setAAFrames", SetAAFrames);

	Nan::SetPrototypeMethod(tpl, "SetAbortRender", SetAbortRender);
	Nan::SetPrototypeMethod(tpl, "setAbortRender", SetAbortRender);

	Nan::SetPrototypeMethod(tpl, "SetAlphaBitPlanes", SetAlphaBitPlanes);
	Nan::SetPrototypeMethod(tpl, "setAlphaBitPlanes", SetAlphaBitPlanes);

	Nan::SetPrototypeMethod(tpl, "SetAnaglyphColorMask", SetAnaglyphColorMask);
	Nan::SetPrototypeMethod(tpl, "setAnaglyphColorMask", SetAnaglyphColorMask);

	Nan::SetPrototypeMethod(tpl, "SetBorders", SetBorders);
	Nan::SetPrototypeMethod(tpl, "setBorders", SetBorders);

	Nan::SetPrototypeMethod(tpl, "SetCurrentCursor", SetCurrentCursor);
	Nan::SetPrototypeMethod(tpl, "setCurrentCursor", SetCurrentCursor);

	Nan::SetPrototypeMethod(tpl, "SetCursorPosition", SetCursorPosition);
	Nan::SetPrototypeMethod(tpl, "setCursorPosition", SetCursorPosition);

	Nan::SetPrototypeMethod(tpl, "SetDesiredUpdateRate", SetDesiredUpdateRate);
	Nan::SetPrototypeMethod(tpl, "setDesiredUpdateRate", SetDesiredUpdateRate);

	Nan::SetPrototypeMethod(tpl, "SetDeviceIndex", SetDeviceIndex);
	Nan::SetPrototypeMethod(tpl, "setDeviceIndex", SetDeviceIndex);

	Nan::SetPrototypeMethod(tpl, "SetFDFrames", SetFDFrames);
	Nan::SetPrototypeMethod(tpl, "setFDFrames", SetFDFrames);

	Nan::SetPrototypeMethod(tpl, "SetForceMakeCurrent", SetForceMakeCurrent);
	Nan::SetPrototypeMethod(tpl, "setForceMakeCurrent", SetForceMakeCurrent);

	Nan::SetPrototypeMethod(tpl, "SetInAbortCheck", SetInAbortCheck);
	Nan::SetPrototypeMethod(tpl, "setInAbortCheck", SetInAbortCheck);

	Nan::SetPrototypeMethod(tpl, "SetInteractor", SetInteractor);
	Nan::SetPrototypeMethod(tpl, "setInteractor", SetInteractor);

	Nan::SetPrototypeMethod(tpl, "SetIsPicking", SetIsPicking);
	Nan::SetPrototypeMethod(tpl, "setIsPicking", SetIsPicking);

	Nan::SetPrototypeMethod(tpl, "SetLineSmoothing", SetLineSmoothing);
	Nan::SetPrototypeMethod(tpl, "setLineSmoothing", SetLineSmoothing);

	Nan::SetPrototypeMethod(tpl, "SetMultiSamples", SetMultiSamples);
	Nan::SetPrototypeMethod(tpl, "setMultiSamples", SetMultiSamples);

	Nan::SetPrototypeMethod(tpl, "SetNumberOfLayers", SetNumberOfLayers);
	Nan::SetPrototypeMethod(tpl, "setNumberOfLayers", SetNumberOfLayers);

	Nan::SetPrototypeMethod(tpl, "SetPointSmoothing", SetPointSmoothing);
	Nan::SetPrototypeMethod(tpl, "setPointSmoothing", SetPointSmoothing);

	Nan::SetPrototypeMethod(tpl, "SetPolygonSmoothing", SetPolygonSmoothing);
	Nan::SetPrototypeMethod(tpl, "setPolygonSmoothing", SetPolygonSmoothing);

	Nan::SetPrototypeMethod(tpl, "SetStencilCapable", SetStencilCapable);
	Nan::SetPrototypeMethod(tpl, "setStencilCapable", SetStencilCapable);

	Nan::SetPrototypeMethod(tpl, "SetStereoCapableWindow", SetStereoCapableWindow);
	Nan::SetPrototypeMethod(tpl, "setStereoCapableWindow", SetStereoCapableWindow);

	Nan::SetPrototypeMethod(tpl, "SetStereoRender", SetStereoRender);
	Nan::SetPrototypeMethod(tpl, "setStereoRender", SetStereoRender);

	Nan::SetPrototypeMethod(tpl, "SetStereoType", SetStereoType);
	Nan::SetPrototypeMethod(tpl, "setStereoType", SetStereoType);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToAnaglyph", SetStereoTypeToAnaglyph);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToAnaglyph", SetStereoTypeToAnaglyph);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToCheckerboard", SetStereoTypeToCheckerboard);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToCheckerboard", SetStereoTypeToCheckerboard);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToCrystalEyes", SetStereoTypeToCrystalEyes);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToCrystalEyes", SetStereoTypeToCrystalEyes);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToDresden", SetStereoTypeToDresden);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToDresden", SetStereoTypeToDresden);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToFake", SetStereoTypeToFake);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToFake", SetStereoTypeToFake);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToInterlaced", SetStereoTypeToInterlaced);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToInterlaced", SetStereoTypeToInterlaced);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToLeft", SetStereoTypeToLeft);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToLeft", SetStereoTypeToLeft);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToRedBlue", SetStereoTypeToRedBlue);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToRedBlue", SetStereoTypeToRedBlue);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToRight", SetStereoTypeToRight);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToRight", SetStereoTypeToRight);

	Nan::SetPrototypeMethod(tpl, "SetStereoTypeToSplitViewportHorizontal", SetStereoTypeToSplitViewportHorizontal);
	Nan::SetPrototypeMethod(tpl, "setStereoTypeToSplitViewportHorizontal", SetStereoTypeToSplitViewportHorizontal);

	Nan::SetPrototypeMethod(tpl, "SetSubFrames", SetSubFrames);
	Nan::SetPrototypeMethod(tpl, "setSubFrames", SetSubFrames);

	Nan::SetPrototypeMethod(tpl, "SetSwapBuffers", SetSwapBuffers);
	Nan::SetPrototypeMethod(tpl, "setSwapBuffers", SetSwapBuffers);

	Nan::SetPrototypeMethod(tpl, "SetUseConstantFDOffsets", SetUseConstantFDOffsets);
	Nan::SetPrototypeMethod(tpl, "setUseConstantFDOffsets", SetUseConstantFDOffsets);

	Nan::SetPrototypeMethod(tpl, "StencilCapableOff", StencilCapableOff);
	Nan::SetPrototypeMethod(tpl, "stencilCapableOff", StencilCapableOff);

	Nan::SetPrototypeMethod(tpl, "StencilCapableOn", StencilCapableOn);
	Nan::SetPrototypeMethod(tpl, "stencilCapableOn", StencilCapableOn);

	Nan::SetPrototypeMethod(tpl, "StereoCapableWindowOff", StereoCapableWindowOff);
	Nan::SetPrototypeMethod(tpl, "stereoCapableWindowOff", StereoCapableWindowOff);

	Nan::SetPrototypeMethod(tpl, "StereoCapableWindowOn", StereoCapableWindowOn);
	Nan::SetPrototypeMethod(tpl, "stereoCapableWindowOn", StereoCapableWindowOn);

	Nan::SetPrototypeMethod(tpl, "StereoMidpoint", StereoMidpoint);
	Nan::SetPrototypeMethod(tpl, "stereoMidpoint", StereoMidpoint);

	Nan::SetPrototypeMethod(tpl, "StereoRenderComplete", StereoRenderComplete);
	Nan::SetPrototypeMethod(tpl, "stereoRenderComplete", StereoRenderComplete);

	Nan::SetPrototypeMethod(tpl, "StereoRenderOff", StereoRenderOff);
	Nan::SetPrototypeMethod(tpl, "stereoRenderOff", StereoRenderOff);

	Nan::SetPrototypeMethod(tpl, "StereoRenderOn", StereoRenderOn);
	Nan::SetPrototypeMethod(tpl, "stereoRenderOn", StereoRenderOn);

	Nan::SetPrototypeMethod(tpl, "StereoUpdate", StereoUpdate);
	Nan::SetPrototypeMethod(tpl, "stereoUpdate", StereoUpdate);

	Nan::SetPrototypeMethod(tpl, "SupportsOpenGL", SupportsOpenGL);
	Nan::SetPrototypeMethod(tpl, "supportsOpenGL", SupportsOpenGL);

	Nan::SetPrototypeMethod(tpl, "SwapBuffersOff", SwapBuffersOff);
	Nan::SetPrototypeMethod(tpl, "swapBuffersOff", SwapBuffersOff);

	Nan::SetPrototypeMethod(tpl, "SwapBuffersOn", SwapBuffersOn);
	Nan::SetPrototypeMethod(tpl, "swapBuffersOn", SwapBuffersOn);

#ifdef VTK_NODE_PLUS_VTKRENDERWINDOWWRAP_INITPTPL
	VTK_NODE_PLUS_VTKRENDERWINDOWWRAP_INITPTPL
#endif
	ptpl.Reset( tpl );
}

void VtkRenderWindowWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkRenderWindow> native = vtkSmartPointer<vtkRenderWindow>::New();
		VtkRenderWindowWrap* obj = new VtkRenderWindowWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkRenderWindowWrap::AddRenderer(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkRendererWrap::ptpl))->HasInstance(info[0]))
	{
		VtkRendererWrap *a0 = ObjectWrap::Unwrap<VtkRendererWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->AddRenderer(
			(vtkRenderer *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::AlphaBitPlanesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AlphaBitPlanesOff();
}

void VtkRenderWindowWrap::AlphaBitPlanesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AlphaBitPlanesOn();
}

void VtkRenderWindowWrap::BordersOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BordersOff();
}

void VtkRenderWindowWrap::BordersOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BordersOn();
}

void VtkRenderWindowWrap::CaptureGL2PSSpecialProps(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkCollectionWrap::ptpl))->HasInstance(info[0]))
	{
		VtkCollectionWrap *a0 = ObjectWrap::Unwrap<VtkCollectionWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->CaptureGL2PSSpecialProps(
			(vtkCollection *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::CheckAbortStatus(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->CheckAbortStatus();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::CheckInRenderStatus(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->CheckInRenderStatus();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::ClearInRenderStatus(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClearInRenderStatus();
}

void VtkRenderWindowWrap::CopyResultFrame(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyResultFrame();
}

void VtkRenderWindowWrap::FullScreenOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FullScreenOff();
}

void VtkRenderWindowWrap::FullScreenOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FullScreenOn();
}

void VtkRenderWindowWrap::GetAAFrames(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAAFrames();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetAbortRender(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAbortRender();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetAlphaBitPlanes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAlphaBitPlanes();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetAnaglyphColorMask(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAnaglyphColorMask();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 2 * sizeof(int));
	Local<v8::Int32Array> at = v8::Int32Array::New(ab, 0, 2);
	memcpy(ab->GetContents().Data(), r, 2 * sizeof(int));
	info.GetReturnValue().Set(at);
}

void VtkRenderWindowWrap::GetBorders(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetBorders();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetCapturingGL2PSSpecialProps(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCapturingGL2PSSpecialProps();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkRenderWindowWrap::GetCurrentCursor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCurrentCursor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetDesiredUpdateRate(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDesiredUpdateRate();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetDeviceIndex(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDeviceIndex();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetFDFrames(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFDFrames();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetFullScreen(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFullScreen();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetInAbortCheck(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInAbortCheck();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetInteractor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	vtkRenderWindowInteractor * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInteractor();
	VtkRenderWindowInteractorWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkRenderWindowInteractorWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkRenderWindowInteractorWrap *w = new VtkRenderWindowInteractorWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkRenderWindowWrap::GetIsPicking(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIsPicking();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetLineSmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLineSmoothing();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetMultiSamples(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMultiSamples();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetNeverRendered(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNeverRendered();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetNumberOfDevices(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfDevices();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetNumberOfLayers(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfLayers();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetNumberOfLayersMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfLayersMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetNumberOfLayersMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfLayersMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetPainterDeviceAdapter(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	vtkPainterDeviceAdapter * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPainterDeviceAdapter();
	VtkPainterDeviceAdapterWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPainterDeviceAdapterWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPainterDeviceAdapterWrap *w = new VtkPainterDeviceAdapterWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkRenderWindowWrap::GetPointSmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPointSmoothing();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetPolygonSmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPolygonSmoothing();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetRenderLibrary(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRenderLibrary();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkRenderWindowWrap::GetRenderers(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	vtkRendererCollection * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRenderers();
	VtkRendererCollectionWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkRendererCollectionWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkRendererCollectionWrap *w = new VtkRendererCollectionWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkRenderWindowWrap::GetStencilCapable(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStencilCapable();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetStereoCapableWindow(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStereoCapableWindow();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetStereoRender(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStereoRender();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetStereoType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStereoType();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetStereoTypeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStereoTypeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkRenderWindowWrap::GetSubFrames(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSubFrames();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetSwapBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSwapBuffers();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::GetUseConstantFDOffsets(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseConstantFDOffsets();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::HasRenderer(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkRendererWrap::ptpl))->HasInstance(info[0]))
	{
		VtkRendererWrap *a0 = ObjectWrap::Unwrap<VtkRendererWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->HasRenderer(
			(vtkRenderer *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::InitializeFromCurrentContext(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->InitializeFromCurrentContext();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::IsDirect(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->IsDirect();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::IsDrawable(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->IsDrawable();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::IsPickingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->IsPickingOff();
}

void VtkRenderWindowWrap::IsPickingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->IsPickingOn();
}

void VtkRenderWindowWrap::LineSmoothingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->LineSmoothingOff();
}

void VtkRenderWindowWrap::LineSmoothingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->LineSmoothingOn();
}

void VtkRenderWindowWrap::MakeRenderWindowInteractor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	vtkRenderWindowInteractor * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->MakeRenderWindowInteractor();
	VtkRenderWindowInteractorWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkRenderWindowInteractorWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkRenderWindowInteractorWrap *w = new VtkRenderWindowInteractorWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkRenderWindowWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	vtkRenderWindow * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	VtkRenderWindowWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkRenderWindowWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkRenderWindowWrap *w = new VtkRenderWindowWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkRenderWindowWrap::PointSmoothingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PointSmoothingOff();
}

void VtkRenderWindowWrap::PointSmoothingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PointSmoothingOn();
}

void VtkRenderWindowWrap::PolygonSmoothingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PolygonSmoothingOff();
}

void VtkRenderWindowWrap::PolygonSmoothingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PolygonSmoothingOn();
}

void VtkRenderWindowWrap::RemoveRenderer(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkRendererWrap::ptpl))->HasInstance(info[0]))
	{
		VtkRendererWrap *a0 = ObjectWrap::Unwrap<VtkRendererWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->RemoveRenderer(
			(vtkRenderer *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::Render(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->Render();
}

void VtkRenderWindowWrap::ReportCapabilities(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->ReportCapabilities();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkRenderWindowWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkRenderWindow * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
		VtkRenderWindowWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkRenderWindowWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkRenderWindowWrap *w = new VtkRenderWindowWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetAAFrames(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAAFrames(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetAbortRender(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAbortRender(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetAlphaBitPlanes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAlphaBitPlanes(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetAnaglyphColorMask(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsInt32Array())
	{
		v8::Local<v8::Int32Array>a0(v8::Local<v8::Int32Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 2 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAnaglyphColorMask(
			(int *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		int b0[2];
		if( a0->Length() < 2 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 2; i++ )
		{
			if( !a0->Get(i)->IsInt32() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->Int32Value();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAnaglyphColorMask(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetAnaglyphColorMask(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetBorders(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetBorders(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetCurrentCursor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetCurrentCursor(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetCursorPosition(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCursorPosition(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetDesiredUpdateRate(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDesiredUpdateRate(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetDeviceIndex(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDeviceIndex(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetFDFrames(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFDFrames(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetForceMakeCurrent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetForceMakeCurrent();
}

void VtkRenderWindowWrap::SetInAbortCheck(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInAbortCheck(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetInteractor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkRenderWindowInteractorWrap::ptpl))->HasInstance(info[0]))
	{
		VtkRenderWindowInteractorWrap *a0 = ObjectWrap::Unwrap<VtkRenderWindowInteractorWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInteractor(
			(vtkRenderWindowInteractor *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetIsPicking(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIsPicking(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetLineSmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetLineSmoothing(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetMultiSamples(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMultiSamples(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetNumberOfLayers(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetNumberOfLayers(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetPointSmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetPointSmoothing(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetPolygonSmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetPolygonSmoothing(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetStencilCapable(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStencilCapable(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetStereoCapableWindow(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStereoCapableWindow(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetStereoRender(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStereoRender(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetStereoType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStereoType(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetStereoTypeToAnaglyph(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToAnaglyph();
}

void VtkRenderWindowWrap::SetStereoTypeToCheckerboard(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToCheckerboard();
}

void VtkRenderWindowWrap::SetStereoTypeToCrystalEyes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToCrystalEyes();
}

void VtkRenderWindowWrap::SetStereoTypeToDresden(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToDresden();
}

void VtkRenderWindowWrap::SetStereoTypeToFake(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToFake();
}

void VtkRenderWindowWrap::SetStereoTypeToInterlaced(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToInterlaced();
}

void VtkRenderWindowWrap::SetStereoTypeToLeft(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToLeft();
}

void VtkRenderWindowWrap::SetStereoTypeToRedBlue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToRedBlue();
}

void VtkRenderWindowWrap::SetStereoTypeToRight(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToRight();
}

void VtkRenderWindowWrap::SetStereoTypeToSplitViewportHorizontal(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetStereoTypeToSplitViewportHorizontal();
}

void VtkRenderWindowWrap::SetSubFrames(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSubFrames(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetSwapBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSwapBuffers(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::SetUseConstantFDOffsets(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseConstantFDOffsets(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRenderWindowWrap::StencilCapableOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StencilCapableOff();
}

void VtkRenderWindowWrap::StencilCapableOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StencilCapableOn();
}

void VtkRenderWindowWrap::StereoCapableWindowOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StereoCapableWindowOff();
}

void VtkRenderWindowWrap::StereoCapableWindowOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StereoCapableWindowOn();
}

void VtkRenderWindowWrap::StereoMidpoint(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StereoMidpoint();
}

void VtkRenderWindowWrap::StereoRenderComplete(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StereoRenderComplete();
}

void VtkRenderWindowWrap::StereoRenderOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StereoRenderOff();
}

void VtkRenderWindowWrap::StereoRenderOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StereoRenderOn();
}

void VtkRenderWindowWrap::StereoUpdate(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StereoUpdate();
}

void VtkRenderWindowWrap::SupportsOpenGL(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->SupportsOpenGL();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRenderWindowWrap::SwapBuffersOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SwapBuffersOff();
}

void VtkRenderWindowWrap::SwapBuffersOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRenderWindowWrap *wrapper = ObjectWrap::Unwrap<VtkRenderWindowWrap>(info.Holder());
	vtkRenderWindow *native = (vtkRenderWindow *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SwapBuffersOn();
}

