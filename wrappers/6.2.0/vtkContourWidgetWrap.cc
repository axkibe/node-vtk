/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkAbstractWidgetWrap.h"
#include "vtkContourWidgetWrap.h"
#include "vtkObjectWrap.h"
#include "vtkContourRepresentationWrap.h"
#include "vtkPolyDataWrap.h"
#include "vtkIdListWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkContourWidgetWrap::ptpl;

VtkContourWidgetWrap::VtkContourWidgetWrap()
{ }

VtkContourWidgetWrap::VtkContourWidgetWrap(vtkSmartPointer<vtkContourWidget> _native)
{ native = _native; }

VtkContourWidgetWrap::~VtkContourWidgetWrap()
{ }

void VtkContourWidgetWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkContourWidget").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("ContourWidget").ToLocalChecked(), ConstructorGetter);
}

void VtkContourWidgetWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkContourWidgetWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkAbstractWidgetWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkAbstractWidgetWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkContourWidgetWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AllowNodePickingOff", AllowNodePickingOff);
	Nan::SetPrototypeMethod(tpl, "allowNodePickingOff", AllowNodePickingOff);

	Nan::SetPrototypeMethod(tpl, "AllowNodePickingOn", AllowNodePickingOn);
	Nan::SetPrototypeMethod(tpl, "allowNodePickingOn", AllowNodePickingOn);

	Nan::SetPrototypeMethod(tpl, "CloseLoop", CloseLoop);
	Nan::SetPrototypeMethod(tpl, "closeLoop", CloseLoop);

	Nan::SetPrototypeMethod(tpl, "ContinuousDrawOff", ContinuousDrawOff);
	Nan::SetPrototypeMethod(tpl, "continuousDrawOff", ContinuousDrawOff);

	Nan::SetPrototypeMethod(tpl, "ContinuousDrawOn", ContinuousDrawOn);
	Nan::SetPrototypeMethod(tpl, "continuousDrawOn", ContinuousDrawOn);

	Nan::SetPrototypeMethod(tpl, "CreateDefaultRepresentation", CreateDefaultRepresentation);
	Nan::SetPrototypeMethod(tpl, "createDefaultRepresentation", CreateDefaultRepresentation);

	Nan::SetPrototypeMethod(tpl, "FollowCursorOff", FollowCursorOff);
	Nan::SetPrototypeMethod(tpl, "followCursorOff", FollowCursorOff);

	Nan::SetPrototypeMethod(tpl, "FollowCursorOn", FollowCursorOn);
	Nan::SetPrototypeMethod(tpl, "followCursorOn", FollowCursorOn);

	Nan::SetPrototypeMethod(tpl, "GetAllowNodePicking", GetAllowNodePicking);
	Nan::SetPrototypeMethod(tpl, "getAllowNodePicking", GetAllowNodePicking);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetContinuousDraw", GetContinuousDraw);
	Nan::SetPrototypeMethod(tpl, "getContinuousDraw", GetContinuousDraw);

	Nan::SetPrototypeMethod(tpl, "GetContourRepresentation", GetContourRepresentation);
	Nan::SetPrototypeMethod(tpl, "getContourRepresentation", GetContourRepresentation);

	Nan::SetPrototypeMethod(tpl, "GetFollowCursor", GetFollowCursor);
	Nan::SetPrototypeMethod(tpl, "getFollowCursor", GetFollowCursor);

	Nan::SetPrototypeMethod(tpl, "GetWidgetState", GetWidgetState);
	Nan::SetPrototypeMethod(tpl, "getWidgetState", GetWidgetState);

	Nan::SetPrototypeMethod(tpl, "Initialize", Initialize);
	Nan::SetPrototypeMethod(tpl, "initialize", Initialize);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetAllowNodePicking", SetAllowNodePicking);
	Nan::SetPrototypeMethod(tpl, "setAllowNodePicking", SetAllowNodePicking);

	Nan::SetPrototypeMethod(tpl, "SetContinuousDraw", SetContinuousDraw);
	Nan::SetPrototypeMethod(tpl, "setContinuousDraw", SetContinuousDraw);

	Nan::SetPrototypeMethod(tpl, "SetEnabled", SetEnabled);
	Nan::SetPrototypeMethod(tpl, "setEnabled", SetEnabled);

	Nan::SetPrototypeMethod(tpl, "SetFollowCursor", SetFollowCursor);
	Nan::SetPrototypeMethod(tpl, "setFollowCursor", SetFollowCursor);

	Nan::SetPrototypeMethod(tpl, "SetRepresentation", SetRepresentation);
	Nan::SetPrototypeMethod(tpl, "setRepresentation", SetRepresentation);

	Nan::SetPrototypeMethod(tpl, "SetWidgetState", SetWidgetState);
	Nan::SetPrototypeMethod(tpl, "setWidgetState", SetWidgetState);

	ptpl.Reset( tpl );
}

void VtkContourWidgetWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkContourWidget> native = vtkSmartPointer<vtkContourWidget>::New();
		VtkContourWidgetWrap* obj = new VtkContourWidgetWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkContourWidgetWrap::AllowNodePickingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AllowNodePickingOff();
}

void VtkContourWidgetWrap::AllowNodePickingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AllowNodePickingOn();
}

void VtkContourWidgetWrap::CloseLoop(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CloseLoop();
}

void VtkContourWidgetWrap::ContinuousDrawOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ContinuousDrawOff();
}

void VtkContourWidgetWrap::ContinuousDrawOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ContinuousDrawOn();
}

void VtkContourWidgetWrap::CreateDefaultRepresentation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CreateDefaultRepresentation();
}

void VtkContourWidgetWrap::FollowCursorOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FollowCursorOff();
}

void VtkContourWidgetWrap::FollowCursorOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FollowCursorOn();
}

void VtkContourWidgetWrap::GetAllowNodePicking(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAllowNodePicking();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkContourWidgetWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkContourWidgetWrap::GetContinuousDraw(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetContinuousDraw();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkContourWidgetWrap::GetContourRepresentation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	vtkContourRepresentation * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetContourRepresentation();
	VtkContourRepresentationWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkContourRepresentationWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkContourRepresentationWrap *w = new VtkContourRepresentationWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkContourWidgetWrap::GetFollowCursor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFollowCursor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkContourWidgetWrap::GetWidgetState(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetWidgetState();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkContourWidgetWrap::Initialize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPolyDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPolyDataWrap *a0 = ObjectWrap::Unwrap<VtkPolyDataWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsObject() && (Nan::New(VtkIdListWrap::ptpl))->HasInstance(info[2]))
			{
				VtkIdListWrap *a2 = ObjectWrap::Unwrap<VtkIdListWrap>(info[2]->ToObject());
								if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->Initialize(
					(vtkPolyData *) a0->native.GetPointer(),
					info[1]->Int32Value(),
					(vtkIdList *) a2->native.GetPointer()
				);
				return;
			}
		}
	}
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->Initialize();
}

void VtkContourWidgetWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkContourWidgetWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	vtkContourWidget * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	VtkContourWidgetWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkContourWidgetWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkContourWidgetWrap *w = new VtkContourWidgetWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkContourWidgetWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkContourWidget * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
		VtkContourWidgetWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkContourWidgetWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkContourWidgetWrap *w = new VtkContourWidgetWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkContourWidgetWrap::SetAllowNodePicking(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAllowNodePicking(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkContourWidgetWrap::SetContinuousDraw(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetContinuousDraw(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkContourWidgetWrap::SetEnabled(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEnabled(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkContourWidgetWrap::SetFollowCursor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFollowCursor(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkContourWidgetWrap::SetRepresentation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkContourRepresentationWrap::ptpl))->HasInstance(info[0]))
	{
		VtkContourRepresentationWrap *a0 = ObjectWrap::Unwrap<VtkContourRepresentationWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetRepresentation(
			(vtkContourRepresentation *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkContourWidgetWrap::SetWidgetState(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkContourWidgetWrap *wrapper = ObjectWrap::Unwrap<VtkContourWidgetWrap>(info.Holder());
	vtkContourWidget *native = (vtkContourWidget *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetWidgetState(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

