/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkPassInputTypeAlgorithmWrap.h"
#include "vtkRandomAttributeGeneratorWrap.h"
#include "vtkObjectWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkRandomAttributeGeneratorWrap::ptpl;

VtkRandomAttributeGeneratorWrap::VtkRandomAttributeGeneratorWrap()
{ }

VtkRandomAttributeGeneratorWrap::VtkRandomAttributeGeneratorWrap(vtkSmartPointer<vtkRandomAttributeGenerator> _native)
{ native = _native; }

VtkRandomAttributeGeneratorWrap::~VtkRandomAttributeGeneratorWrap()
{ }

void VtkRandomAttributeGeneratorWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkRandomAttributeGenerator").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("RandomAttributeGenerator").ToLocalChecked(), ConstructorGetter);
}

void VtkRandomAttributeGeneratorWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkRandomAttributeGeneratorWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkPassInputTypeAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkPassInputTypeAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkRandomAttributeGeneratorWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AttributesConstantPerBlockOff", AttributesConstantPerBlockOff);
	Nan::SetPrototypeMethod(tpl, "attributesConstantPerBlockOff", AttributesConstantPerBlockOff);

	Nan::SetPrototypeMethod(tpl, "AttributesConstantPerBlockOn", AttributesConstantPerBlockOn);
	Nan::SetPrototypeMethod(tpl, "attributesConstantPerBlockOn", AttributesConstantPerBlockOn);

	Nan::SetPrototypeMethod(tpl, "GenerateAllCellDataOff", GenerateAllCellDataOff);
	Nan::SetPrototypeMethod(tpl, "generateAllCellDataOff", GenerateAllCellDataOff);

	Nan::SetPrototypeMethod(tpl, "GenerateAllCellDataOn", GenerateAllCellDataOn);
	Nan::SetPrototypeMethod(tpl, "generateAllCellDataOn", GenerateAllCellDataOn);

	Nan::SetPrototypeMethod(tpl, "GenerateAllDataOff", GenerateAllDataOff);
	Nan::SetPrototypeMethod(tpl, "generateAllDataOff", GenerateAllDataOff);

	Nan::SetPrototypeMethod(tpl, "GenerateAllDataOn", GenerateAllDataOn);
	Nan::SetPrototypeMethod(tpl, "generateAllDataOn", GenerateAllDataOn);

	Nan::SetPrototypeMethod(tpl, "GenerateAllPointDataOff", GenerateAllPointDataOff);
	Nan::SetPrototypeMethod(tpl, "generateAllPointDataOff", GenerateAllPointDataOff);

	Nan::SetPrototypeMethod(tpl, "GenerateAllPointDataOn", GenerateAllPointDataOn);
	Nan::SetPrototypeMethod(tpl, "generateAllPointDataOn", GenerateAllPointDataOn);

	Nan::SetPrototypeMethod(tpl, "GenerateCellArrayOff", GenerateCellArrayOff);
	Nan::SetPrototypeMethod(tpl, "generateCellArrayOff", GenerateCellArrayOff);

	Nan::SetPrototypeMethod(tpl, "GenerateCellArrayOn", GenerateCellArrayOn);
	Nan::SetPrototypeMethod(tpl, "generateCellArrayOn", GenerateCellArrayOn);

	Nan::SetPrototypeMethod(tpl, "GenerateCellNormalsOff", GenerateCellNormalsOff);
	Nan::SetPrototypeMethod(tpl, "generateCellNormalsOff", GenerateCellNormalsOff);

	Nan::SetPrototypeMethod(tpl, "GenerateCellNormalsOn", GenerateCellNormalsOn);
	Nan::SetPrototypeMethod(tpl, "generateCellNormalsOn", GenerateCellNormalsOn);

	Nan::SetPrototypeMethod(tpl, "GenerateCellScalarsOff", GenerateCellScalarsOff);
	Nan::SetPrototypeMethod(tpl, "generateCellScalarsOff", GenerateCellScalarsOff);

	Nan::SetPrototypeMethod(tpl, "GenerateCellScalarsOn", GenerateCellScalarsOn);
	Nan::SetPrototypeMethod(tpl, "generateCellScalarsOn", GenerateCellScalarsOn);

	Nan::SetPrototypeMethod(tpl, "GenerateCellTCoordsOff", GenerateCellTCoordsOff);
	Nan::SetPrototypeMethod(tpl, "generateCellTCoordsOff", GenerateCellTCoordsOff);

	Nan::SetPrototypeMethod(tpl, "GenerateCellTCoordsOn", GenerateCellTCoordsOn);
	Nan::SetPrototypeMethod(tpl, "generateCellTCoordsOn", GenerateCellTCoordsOn);

	Nan::SetPrototypeMethod(tpl, "GenerateCellTensorsOff", GenerateCellTensorsOff);
	Nan::SetPrototypeMethod(tpl, "generateCellTensorsOff", GenerateCellTensorsOff);

	Nan::SetPrototypeMethod(tpl, "GenerateCellTensorsOn", GenerateCellTensorsOn);
	Nan::SetPrototypeMethod(tpl, "generateCellTensorsOn", GenerateCellTensorsOn);

	Nan::SetPrototypeMethod(tpl, "GenerateCellVectorsOff", GenerateCellVectorsOff);
	Nan::SetPrototypeMethod(tpl, "generateCellVectorsOff", GenerateCellVectorsOff);

	Nan::SetPrototypeMethod(tpl, "GenerateCellVectorsOn", GenerateCellVectorsOn);
	Nan::SetPrototypeMethod(tpl, "generateCellVectorsOn", GenerateCellVectorsOn);

	Nan::SetPrototypeMethod(tpl, "GenerateFieldArrayOff", GenerateFieldArrayOff);
	Nan::SetPrototypeMethod(tpl, "generateFieldArrayOff", GenerateFieldArrayOff);

	Nan::SetPrototypeMethod(tpl, "GenerateFieldArrayOn", GenerateFieldArrayOn);
	Nan::SetPrototypeMethod(tpl, "generateFieldArrayOn", GenerateFieldArrayOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePointArrayOff", GeneratePointArrayOff);
	Nan::SetPrototypeMethod(tpl, "generatePointArrayOff", GeneratePointArrayOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePointArrayOn", GeneratePointArrayOn);
	Nan::SetPrototypeMethod(tpl, "generatePointArrayOn", GeneratePointArrayOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePointNormalsOff", GeneratePointNormalsOff);
	Nan::SetPrototypeMethod(tpl, "generatePointNormalsOff", GeneratePointNormalsOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePointNormalsOn", GeneratePointNormalsOn);
	Nan::SetPrototypeMethod(tpl, "generatePointNormalsOn", GeneratePointNormalsOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePointScalarsOff", GeneratePointScalarsOff);
	Nan::SetPrototypeMethod(tpl, "generatePointScalarsOff", GeneratePointScalarsOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePointScalarsOn", GeneratePointScalarsOn);
	Nan::SetPrototypeMethod(tpl, "generatePointScalarsOn", GeneratePointScalarsOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePointTCoordsOff", GeneratePointTCoordsOff);
	Nan::SetPrototypeMethod(tpl, "generatePointTCoordsOff", GeneratePointTCoordsOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePointTCoordsOn", GeneratePointTCoordsOn);
	Nan::SetPrototypeMethod(tpl, "generatePointTCoordsOn", GeneratePointTCoordsOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePointTensorsOff", GeneratePointTensorsOff);
	Nan::SetPrototypeMethod(tpl, "generatePointTensorsOff", GeneratePointTensorsOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePointTensorsOn", GeneratePointTensorsOn);
	Nan::SetPrototypeMethod(tpl, "generatePointTensorsOn", GeneratePointTensorsOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePointVectorsOff", GeneratePointVectorsOff);
	Nan::SetPrototypeMethod(tpl, "generatePointVectorsOff", GeneratePointVectorsOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePointVectorsOn", GeneratePointVectorsOn);
	Nan::SetPrototypeMethod(tpl, "generatePointVectorsOn", GeneratePointVectorsOn);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetDataType", GetDataType);
	Nan::SetPrototypeMethod(tpl, "getDataType", GetDataType);

	Nan::SetPrototypeMethod(tpl, "GetGenerateCellArray", GetGenerateCellArray);
	Nan::SetPrototypeMethod(tpl, "getGenerateCellArray", GetGenerateCellArray);

	Nan::SetPrototypeMethod(tpl, "GetGenerateCellNormals", GetGenerateCellNormals);
	Nan::SetPrototypeMethod(tpl, "getGenerateCellNormals", GetGenerateCellNormals);

	Nan::SetPrototypeMethod(tpl, "GetGenerateCellScalars", GetGenerateCellScalars);
	Nan::SetPrototypeMethod(tpl, "getGenerateCellScalars", GetGenerateCellScalars);

	Nan::SetPrototypeMethod(tpl, "GetGenerateCellTCoords", GetGenerateCellTCoords);
	Nan::SetPrototypeMethod(tpl, "getGenerateCellTCoords", GetGenerateCellTCoords);

	Nan::SetPrototypeMethod(tpl, "GetGenerateCellTensors", GetGenerateCellTensors);
	Nan::SetPrototypeMethod(tpl, "getGenerateCellTensors", GetGenerateCellTensors);

	Nan::SetPrototypeMethod(tpl, "GetGenerateCellVectors", GetGenerateCellVectors);
	Nan::SetPrototypeMethod(tpl, "getGenerateCellVectors", GetGenerateCellVectors);

	Nan::SetPrototypeMethod(tpl, "GetGenerateFieldArray", GetGenerateFieldArray);
	Nan::SetPrototypeMethod(tpl, "getGenerateFieldArray", GetGenerateFieldArray);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePointArray", GetGeneratePointArray);
	Nan::SetPrototypeMethod(tpl, "getGeneratePointArray", GetGeneratePointArray);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePointNormals", GetGeneratePointNormals);
	Nan::SetPrototypeMethod(tpl, "getGeneratePointNormals", GetGeneratePointNormals);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePointScalars", GetGeneratePointScalars);
	Nan::SetPrototypeMethod(tpl, "getGeneratePointScalars", GetGeneratePointScalars);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePointTCoords", GetGeneratePointTCoords);
	Nan::SetPrototypeMethod(tpl, "getGeneratePointTCoords", GetGeneratePointTCoords);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePointTensors", GetGeneratePointTensors);
	Nan::SetPrototypeMethod(tpl, "getGeneratePointTensors", GetGeneratePointTensors);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePointVectors", GetGeneratePointVectors);
	Nan::SetPrototypeMethod(tpl, "getGeneratePointVectors", GetGeneratePointVectors);

	Nan::SetPrototypeMethod(tpl, "GetMaximumComponentValue", GetMaximumComponentValue);
	Nan::SetPrototypeMethod(tpl, "getMaximumComponentValue", GetMaximumComponentValue);

	Nan::SetPrototypeMethod(tpl, "GetMinimumComponentValue", GetMinimumComponentValue);
	Nan::SetPrototypeMethod(tpl, "getMinimumComponentValue", GetMinimumComponentValue);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfComponents", GetNumberOfComponents);
	Nan::SetPrototypeMethod(tpl, "getNumberOfComponents", GetNumberOfComponents);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfComponentsMaxValue", GetNumberOfComponentsMaxValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfComponentsMaxValue", GetNumberOfComponentsMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfComponentsMinValue", GetNumberOfComponentsMinValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfComponentsMinValue", GetNumberOfComponentsMinValue);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetComponentRange", SetComponentRange);
	Nan::SetPrototypeMethod(tpl, "setComponentRange", SetComponentRange);

	Nan::SetPrototypeMethod(tpl, "SetDataType", SetDataType);
	Nan::SetPrototypeMethod(tpl, "setDataType", SetDataType);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToBit", SetDataTypeToBit);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToBit", SetDataTypeToBit);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToChar", SetDataTypeToChar);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToChar", SetDataTypeToChar);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToDouble", SetDataTypeToDouble);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToDouble", SetDataTypeToDouble);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToFloat", SetDataTypeToFloat);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToFloat", SetDataTypeToFloat);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToInt", SetDataTypeToInt);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToInt", SetDataTypeToInt);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToLong", SetDataTypeToLong);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToLong", SetDataTypeToLong);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToShort", SetDataTypeToShort);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToShort", SetDataTypeToShort);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToUnsignedChar", SetDataTypeToUnsignedChar);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToUnsignedChar", SetDataTypeToUnsignedChar);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToUnsignedInt", SetDataTypeToUnsignedInt);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToUnsignedInt", SetDataTypeToUnsignedInt);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToUnsignedLong", SetDataTypeToUnsignedLong);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToUnsignedLong", SetDataTypeToUnsignedLong);

	Nan::SetPrototypeMethod(tpl, "SetDataTypeToUnsignedShort", SetDataTypeToUnsignedShort);
	Nan::SetPrototypeMethod(tpl, "setDataTypeToUnsignedShort", SetDataTypeToUnsignedShort);

	Nan::SetPrototypeMethod(tpl, "SetGenerateCellArray", SetGenerateCellArray);
	Nan::SetPrototypeMethod(tpl, "setGenerateCellArray", SetGenerateCellArray);

	Nan::SetPrototypeMethod(tpl, "SetGenerateCellNormals", SetGenerateCellNormals);
	Nan::SetPrototypeMethod(tpl, "setGenerateCellNormals", SetGenerateCellNormals);

	Nan::SetPrototypeMethod(tpl, "SetGenerateCellScalars", SetGenerateCellScalars);
	Nan::SetPrototypeMethod(tpl, "setGenerateCellScalars", SetGenerateCellScalars);

	Nan::SetPrototypeMethod(tpl, "SetGenerateCellTCoords", SetGenerateCellTCoords);
	Nan::SetPrototypeMethod(tpl, "setGenerateCellTCoords", SetGenerateCellTCoords);

	Nan::SetPrototypeMethod(tpl, "SetGenerateCellTensors", SetGenerateCellTensors);
	Nan::SetPrototypeMethod(tpl, "setGenerateCellTensors", SetGenerateCellTensors);

	Nan::SetPrototypeMethod(tpl, "SetGenerateCellVectors", SetGenerateCellVectors);
	Nan::SetPrototypeMethod(tpl, "setGenerateCellVectors", SetGenerateCellVectors);

	Nan::SetPrototypeMethod(tpl, "SetGenerateFieldArray", SetGenerateFieldArray);
	Nan::SetPrototypeMethod(tpl, "setGenerateFieldArray", SetGenerateFieldArray);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePointArray", SetGeneratePointArray);
	Nan::SetPrototypeMethod(tpl, "setGeneratePointArray", SetGeneratePointArray);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePointNormals", SetGeneratePointNormals);
	Nan::SetPrototypeMethod(tpl, "setGeneratePointNormals", SetGeneratePointNormals);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePointScalars", SetGeneratePointScalars);
	Nan::SetPrototypeMethod(tpl, "setGeneratePointScalars", SetGeneratePointScalars);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePointTCoords", SetGeneratePointTCoords);
	Nan::SetPrototypeMethod(tpl, "setGeneratePointTCoords", SetGeneratePointTCoords);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePointTensors", SetGeneratePointTensors);
	Nan::SetPrototypeMethod(tpl, "setGeneratePointTensors", SetGeneratePointTensors);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePointVectors", SetGeneratePointVectors);
	Nan::SetPrototypeMethod(tpl, "setGeneratePointVectors", SetGeneratePointVectors);

	Nan::SetPrototypeMethod(tpl, "SetMaximumComponentValue", SetMaximumComponentValue);
	Nan::SetPrototypeMethod(tpl, "setMaximumComponentValue", SetMaximumComponentValue);

	Nan::SetPrototypeMethod(tpl, "SetMinimumComponentValue", SetMinimumComponentValue);
	Nan::SetPrototypeMethod(tpl, "setMinimumComponentValue", SetMinimumComponentValue);

	Nan::SetPrototypeMethod(tpl, "SetNumberOfComponents", SetNumberOfComponents);
	Nan::SetPrototypeMethod(tpl, "setNumberOfComponents", SetNumberOfComponents);

	ptpl.Reset( tpl );
}

void VtkRandomAttributeGeneratorWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkRandomAttributeGenerator> native = vtkSmartPointer<vtkRandomAttributeGenerator>::New();
		VtkRandomAttributeGeneratorWrap* obj = new VtkRandomAttributeGeneratorWrap(native);		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkRandomAttributeGeneratorWrap::AttributesConstantPerBlockOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AttributesConstantPerBlockOff();
}

void VtkRandomAttributeGeneratorWrap::AttributesConstantPerBlockOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AttributesConstantPerBlockOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateAllCellDataOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateAllCellDataOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateAllCellDataOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateAllCellDataOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateAllDataOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateAllDataOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateAllDataOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateAllDataOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateAllPointDataOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateAllPointDataOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateAllPointDataOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateAllPointDataOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellArrayOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellArrayOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellArrayOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellArrayOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellNormalsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellNormalsOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellNormalsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellNormalsOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellScalarsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellScalarsOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellScalarsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellScalarsOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellTCoordsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellTCoordsOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellTCoordsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellTCoordsOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellTensorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellTensorsOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellTensorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellTensorsOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellVectorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellVectorsOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateCellVectorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateCellVectorsOn();
}

void VtkRandomAttributeGeneratorWrap::GenerateFieldArrayOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateFieldArrayOff();
}

void VtkRandomAttributeGeneratorWrap::GenerateFieldArrayOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateFieldArrayOn();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointArrayOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointArrayOff();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointArrayOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointArrayOn();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointNormalsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointNormalsOff();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointNormalsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointNormalsOn();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointScalarsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointScalarsOff();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointScalarsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointScalarsOn();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointTCoordsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointTCoordsOff();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointTCoordsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointTCoordsOn();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointTensorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointTensorsOff();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointTensorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointTensorsOn();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointVectorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointVectorsOff();
}

void VtkRandomAttributeGeneratorWrap::GeneratePointVectorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointVectorsOn();
}

void VtkRandomAttributeGeneratorWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkRandomAttributeGeneratorWrap::GetDataType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDataType();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGenerateCellArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateCellArray();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGenerateCellNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateCellNormals();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGenerateCellScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateCellScalars();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGenerateCellTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateCellTCoords();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGenerateCellTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateCellTensors();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGenerateCellVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateCellVectors();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGenerateFieldArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateFieldArray();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGeneratePointArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePointArray();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGeneratePointNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePointNormals();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGeneratePointScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePointScalars();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGeneratePointTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePointTCoords();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGeneratePointTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePointTensors();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetGeneratePointVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePointVectors();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetMaximumComponentValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMaximumComponentValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetMinimumComponentValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMinimumComponentValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetNumberOfComponents(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfComponents();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetNumberOfComponentsMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfComponentsMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::GetNumberOfComponentsMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfComponentsMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomAttributeGeneratorWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	vtkRandomAttributeGenerator * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkRandomAttributeGeneratorWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkRandomAttributeGeneratorWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkRandomAttributeGeneratorWrap *w = new VtkRandomAttributeGeneratorWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkRandomAttributeGeneratorWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkRandomAttributeGenerator * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkRandomAttributeGeneratorWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkRandomAttributeGeneratorWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkRandomAttributeGeneratorWrap *w = new VtkRandomAttributeGeneratorWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetComponentRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetComponentRange(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetDataType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDataType(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToBit(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToBit();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToChar(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToChar();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToDouble(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToDouble();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToFloat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToFloat();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToInt(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToInt();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToLong(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToLong();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToShort(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToShort();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToUnsignedChar(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToUnsignedChar();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToUnsignedInt(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToUnsignedInt();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToUnsignedLong(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToUnsignedLong();
}

void VtkRandomAttributeGeneratorWrap::SetDataTypeToUnsignedShort(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetDataTypeToUnsignedShort();
}

void VtkRandomAttributeGeneratorWrap::SetGenerateCellArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateCellArray(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGenerateCellNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateCellNormals(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGenerateCellScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateCellScalars(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGenerateCellTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateCellTCoords(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGenerateCellTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateCellTensors(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGenerateCellVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateCellVectors(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGenerateFieldArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateFieldArray(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGeneratePointArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePointArray(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGeneratePointNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePointNormals(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGeneratePointScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePointScalars(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGeneratePointTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePointTCoords(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGeneratePointTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePointTensors(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetGeneratePointVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePointVectors(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetMaximumComponentValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMaximumComponentValue(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetMinimumComponentValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMinimumComponentValue(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomAttributeGeneratorWrap::SetNumberOfComponents(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomAttributeGeneratorWrap *wrapper = ObjectWrap::Unwrap<VtkRandomAttributeGeneratorWrap>(info.Holder());
	vtkRandomAttributeGenerator *native = (vtkRandomAttributeGenerator *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetNumberOfComponents(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

