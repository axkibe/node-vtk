/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkExporterWrap.h"
#include "vtkGL2PSExporterWrap.h"
#include "vtkObjectWrap.h"
#include "vtkPropCollectionWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkGL2PSExporterWrap::ptpl;

VtkGL2PSExporterWrap::VtkGL2PSExporterWrap()
{ }

VtkGL2PSExporterWrap::VtkGL2PSExporterWrap(vtkSmartPointer<vtkGL2PSExporter> _native)
{ native = _native; }

VtkGL2PSExporterWrap::~VtkGL2PSExporterWrap()
{ }

void VtkGL2PSExporterWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkGL2PSExporter").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("GL2PSExporter").ToLocalChecked(), ConstructorGetter);
}

void VtkGL2PSExporterWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkGL2PSExporterWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkExporterWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkExporterWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkGL2PSExporterWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "BestRootOff", BestRootOff);
	Nan::SetPrototypeMethod(tpl, "bestRootOff", BestRootOff);

	Nan::SetPrototypeMethod(tpl, "BestRootOn", BestRootOn);
	Nan::SetPrototypeMethod(tpl, "bestRootOn", BestRootOn);

	Nan::SetPrototypeMethod(tpl, "CompressOff", CompressOff);
	Nan::SetPrototypeMethod(tpl, "compressOff", CompressOff);

	Nan::SetPrototypeMethod(tpl, "CompressOn", CompressOn);
	Nan::SetPrototypeMethod(tpl, "compressOn", CompressOn);

	Nan::SetPrototypeMethod(tpl, "DrawBackgroundOff", DrawBackgroundOff);
	Nan::SetPrototypeMethod(tpl, "drawBackgroundOff", DrawBackgroundOff);

	Nan::SetPrototypeMethod(tpl, "DrawBackgroundOn", DrawBackgroundOn);
	Nan::SetPrototypeMethod(tpl, "drawBackgroundOn", DrawBackgroundOn);

	Nan::SetPrototypeMethod(tpl, "GetBestRoot", GetBestRoot);
	Nan::SetPrototypeMethod(tpl, "getBestRoot", GetBestRoot);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetCompress", GetCompress);
	Nan::SetPrototypeMethod(tpl, "getCompress", GetCompress);

	Nan::SetPrototypeMethod(tpl, "GetDrawBackground", GetDrawBackground);
	Nan::SetPrototypeMethod(tpl, "getDrawBackground", GetDrawBackground);

	Nan::SetPrototypeMethod(tpl, "GetFileFormat", GetFileFormat);
	Nan::SetPrototypeMethod(tpl, "getFileFormat", GetFileFormat);

	Nan::SetPrototypeMethod(tpl, "GetFileFormatAsString", GetFileFormatAsString);
	Nan::SetPrototypeMethod(tpl, "getFileFormatAsString", GetFileFormatAsString);

	Nan::SetPrototypeMethod(tpl, "GetFileFormatMaxValue", GetFileFormatMaxValue);
	Nan::SetPrototypeMethod(tpl, "getFileFormatMaxValue", GetFileFormatMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetFileFormatMinValue", GetFileFormatMinValue);
	Nan::SetPrototypeMethod(tpl, "getFileFormatMinValue", GetFileFormatMinValue);

	Nan::SetPrototypeMethod(tpl, "GetFilePrefix", GetFilePrefix);
	Nan::SetPrototypeMethod(tpl, "getFilePrefix", GetFilePrefix);

	Nan::SetPrototypeMethod(tpl, "GetLandscape", GetLandscape);
	Nan::SetPrototypeMethod(tpl, "getLandscape", GetLandscape);

	Nan::SetPrototypeMethod(tpl, "GetOcclusionCull", GetOcclusionCull);
	Nan::SetPrototypeMethod(tpl, "getOcclusionCull", GetOcclusionCull);

	Nan::SetPrototypeMethod(tpl, "GetPS3Shading", GetPS3Shading);
	Nan::SetPrototypeMethod(tpl, "getPS3Shading", GetPS3Shading);

	Nan::SetPrototypeMethod(tpl, "GetRasterExclusions", GetRasterExclusions);
	Nan::SetPrototypeMethod(tpl, "getRasterExclusions", GetRasterExclusions);

	Nan::SetPrototypeMethod(tpl, "GetSilent", GetSilent);
	Nan::SetPrototypeMethod(tpl, "getSilent", GetSilent);

	Nan::SetPrototypeMethod(tpl, "GetSimpleLineOffset", GetSimpleLineOffset);
	Nan::SetPrototypeMethod(tpl, "getSimpleLineOffset", GetSimpleLineOffset);

	Nan::SetPrototypeMethod(tpl, "GetSort", GetSort);
	Nan::SetPrototypeMethod(tpl, "getSort", GetSort);

	Nan::SetPrototypeMethod(tpl, "GetSortAsString", GetSortAsString);
	Nan::SetPrototypeMethod(tpl, "getSortAsString", GetSortAsString);

	Nan::SetPrototypeMethod(tpl, "GetSortMaxValue", GetSortMaxValue);
	Nan::SetPrototypeMethod(tpl, "getSortMaxValue", GetSortMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetSortMinValue", GetSortMinValue);
	Nan::SetPrototypeMethod(tpl, "getSortMinValue", GetSortMinValue);

	Nan::SetPrototypeMethod(tpl, "GetText", GetText);
	Nan::SetPrototypeMethod(tpl, "getText", GetText);

	Nan::SetPrototypeMethod(tpl, "GetTextAsPath", GetTextAsPath);
	Nan::SetPrototypeMethod(tpl, "getTextAsPath", GetTextAsPath);

	Nan::SetPrototypeMethod(tpl, "GetTitle", GetTitle);
	Nan::SetPrototypeMethod(tpl, "getTitle", GetTitle);

	Nan::SetPrototypeMethod(tpl, "GetWrite3DPropsAsRasterImage", GetWrite3DPropsAsRasterImage);
	Nan::SetPrototypeMethod(tpl, "getWrite3DPropsAsRasterImage", GetWrite3DPropsAsRasterImage);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "LandscapeOff", LandscapeOff);
	Nan::SetPrototypeMethod(tpl, "landscapeOff", LandscapeOff);

	Nan::SetPrototypeMethod(tpl, "LandscapeOn", LandscapeOn);
	Nan::SetPrototypeMethod(tpl, "landscapeOn", LandscapeOn);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "OcclusionCullOff", OcclusionCullOff);
	Nan::SetPrototypeMethod(tpl, "occlusionCullOff", OcclusionCullOff);

	Nan::SetPrototypeMethod(tpl, "OcclusionCullOn", OcclusionCullOn);
	Nan::SetPrototypeMethod(tpl, "occlusionCullOn", OcclusionCullOn);

	Nan::SetPrototypeMethod(tpl, "PS3ShadingOff", PS3ShadingOff);
	Nan::SetPrototypeMethod(tpl, "pS3ShadingOff", PS3ShadingOff);

	Nan::SetPrototypeMethod(tpl, "PS3ShadingOn", PS3ShadingOn);
	Nan::SetPrototypeMethod(tpl, "pS3ShadingOn", PS3ShadingOn);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetBestRoot", SetBestRoot);
	Nan::SetPrototypeMethod(tpl, "setBestRoot", SetBestRoot);

	Nan::SetPrototypeMethod(tpl, "SetCompress", SetCompress);
	Nan::SetPrototypeMethod(tpl, "setCompress", SetCompress);

	Nan::SetPrototypeMethod(tpl, "SetDrawBackground", SetDrawBackground);
	Nan::SetPrototypeMethod(tpl, "setDrawBackground", SetDrawBackground);

	Nan::SetPrototypeMethod(tpl, "SetFileFormat", SetFileFormat);
	Nan::SetPrototypeMethod(tpl, "setFileFormat", SetFileFormat);

	Nan::SetPrototypeMethod(tpl, "SetFileFormatToEPS", SetFileFormatToEPS);
	Nan::SetPrototypeMethod(tpl, "setFileFormatToEPS", SetFileFormatToEPS);

	Nan::SetPrototypeMethod(tpl, "SetFileFormatToPDF", SetFileFormatToPDF);
	Nan::SetPrototypeMethod(tpl, "setFileFormatToPDF", SetFileFormatToPDF);

	Nan::SetPrototypeMethod(tpl, "SetFileFormatToPS", SetFileFormatToPS);
	Nan::SetPrototypeMethod(tpl, "setFileFormatToPS", SetFileFormatToPS);

	Nan::SetPrototypeMethod(tpl, "SetFileFormatToSVG", SetFileFormatToSVG);
	Nan::SetPrototypeMethod(tpl, "setFileFormatToSVG", SetFileFormatToSVG);

	Nan::SetPrototypeMethod(tpl, "SetFileFormatToTeX", SetFileFormatToTeX);
	Nan::SetPrototypeMethod(tpl, "setFileFormatToTeX", SetFileFormatToTeX);

	Nan::SetPrototypeMethod(tpl, "SetFilePrefix", SetFilePrefix);
	Nan::SetPrototypeMethod(tpl, "setFilePrefix", SetFilePrefix);

	Nan::SetPrototypeMethod(tpl, "SetLandscape", SetLandscape);
	Nan::SetPrototypeMethod(tpl, "setLandscape", SetLandscape);

	Nan::SetPrototypeMethod(tpl, "SetOcclusionCull", SetOcclusionCull);
	Nan::SetPrototypeMethod(tpl, "setOcclusionCull", SetOcclusionCull);

	Nan::SetPrototypeMethod(tpl, "SetPS3Shading", SetPS3Shading);
	Nan::SetPrototypeMethod(tpl, "setPS3Shading", SetPS3Shading);

	Nan::SetPrototypeMethod(tpl, "SetRasterExclusions", SetRasterExclusions);
	Nan::SetPrototypeMethod(tpl, "setRasterExclusions", SetRasterExclusions);

	Nan::SetPrototypeMethod(tpl, "SetSilent", SetSilent);
	Nan::SetPrototypeMethod(tpl, "setSilent", SetSilent);

	Nan::SetPrototypeMethod(tpl, "SetSimpleLineOffset", SetSimpleLineOffset);
	Nan::SetPrototypeMethod(tpl, "setSimpleLineOffset", SetSimpleLineOffset);

	Nan::SetPrototypeMethod(tpl, "SetSort", SetSort);
	Nan::SetPrototypeMethod(tpl, "setSort", SetSort);

	Nan::SetPrototypeMethod(tpl, "SetSortToBSP", SetSortToBSP);
	Nan::SetPrototypeMethod(tpl, "setSortToBSP", SetSortToBSP);

	Nan::SetPrototypeMethod(tpl, "SetSortToOff", SetSortToOff);
	Nan::SetPrototypeMethod(tpl, "setSortToOff", SetSortToOff);

	Nan::SetPrototypeMethod(tpl, "SetSortToSimple", SetSortToSimple);
	Nan::SetPrototypeMethod(tpl, "setSortToSimple", SetSortToSimple);

	Nan::SetPrototypeMethod(tpl, "SetText", SetText);
	Nan::SetPrototypeMethod(tpl, "setText", SetText);

	Nan::SetPrototypeMethod(tpl, "SetTextAsPath", SetTextAsPath);
	Nan::SetPrototypeMethod(tpl, "setTextAsPath", SetTextAsPath);

	Nan::SetPrototypeMethod(tpl, "SetTitle", SetTitle);
	Nan::SetPrototypeMethod(tpl, "setTitle", SetTitle);

	Nan::SetPrototypeMethod(tpl, "SetWrite3DPropsAsRasterImage", SetWrite3DPropsAsRasterImage);
	Nan::SetPrototypeMethod(tpl, "setWrite3DPropsAsRasterImage", SetWrite3DPropsAsRasterImage);

	Nan::SetPrototypeMethod(tpl, "SilentOff", SilentOff);
	Nan::SetPrototypeMethod(tpl, "silentOff", SilentOff);

	Nan::SetPrototypeMethod(tpl, "SilentOn", SilentOn);
	Nan::SetPrototypeMethod(tpl, "silentOn", SilentOn);

	Nan::SetPrototypeMethod(tpl, "SimpleLineOffsetOff", SimpleLineOffsetOff);
	Nan::SetPrototypeMethod(tpl, "simpleLineOffsetOff", SimpleLineOffsetOff);

	Nan::SetPrototypeMethod(tpl, "SimpleLineOffsetOn", SimpleLineOffsetOn);
	Nan::SetPrototypeMethod(tpl, "simpleLineOffsetOn", SimpleLineOffsetOn);

	Nan::SetPrototypeMethod(tpl, "TextAsPathOff", TextAsPathOff);
	Nan::SetPrototypeMethod(tpl, "textAsPathOff", TextAsPathOff);

	Nan::SetPrototypeMethod(tpl, "TextAsPathOn", TextAsPathOn);
	Nan::SetPrototypeMethod(tpl, "textAsPathOn", TextAsPathOn);

	Nan::SetPrototypeMethod(tpl, "TextOff", TextOff);
	Nan::SetPrototypeMethod(tpl, "textOff", TextOff);

	Nan::SetPrototypeMethod(tpl, "TextOn", TextOn);
	Nan::SetPrototypeMethod(tpl, "textOn", TextOn);

	Nan::SetPrototypeMethod(tpl, "UsePainterSettings", UsePainterSettings);
	Nan::SetPrototypeMethod(tpl, "usePainterSettings", UsePainterSettings);

	Nan::SetPrototypeMethod(tpl, "Write3DPropsAsRasterImageOff", Write3DPropsAsRasterImageOff);
	Nan::SetPrototypeMethod(tpl, "write3DPropsAsRasterImageOff", Write3DPropsAsRasterImageOff);

	Nan::SetPrototypeMethod(tpl, "Write3DPropsAsRasterImageOn", Write3DPropsAsRasterImageOn);
	Nan::SetPrototypeMethod(tpl, "write3DPropsAsRasterImageOn", Write3DPropsAsRasterImageOn);

	ptpl.Reset( tpl );
}

void VtkGL2PSExporterWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkGL2PSExporter> native = vtkSmartPointer<vtkGL2PSExporter>::New();
		VtkGL2PSExporterWrap* obj = new VtkGL2PSExporterWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkGL2PSExporterWrap::BestRootOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BestRootOff();
}

void VtkGL2PSExporterWrap::BestRootOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BestRootOn();
}

void VtkGL2PSExporterWrap::CompressOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CompressOff();
}

void VtkGL2PSExporterWrap::CompressOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CompressOn();
}

void VtkGL2PSExporterWrap::DrawBackgroundOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawBackgroundOff();
}

void VtkGL2PSExporterWrap::DrawBackgroundOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawBackgroundOn();
}

void VtkGL2PSExporterWrap::GetBestRoot(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetBestRoot();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGL2PSExporterWrap::GetCompress(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCompress();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetDrawBackground(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawBackground();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetFileFormat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFileFormat();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetFileFormatAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFileFormatAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGL2PSExporterWrap::GetFileFormatMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFileFormatMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetFileFormatMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFileFormatMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetFilePrefix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFilePrefix();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGL2PSExporterWrap::GetLandscape(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLandscape();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetOcclusionCull(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOcclusionCull();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetPS3Shading(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPS3Shading();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetRasterExclusions(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	vtkPropCollection * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRasterExclusions();
		VtkPropCollectionWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropCollectionWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropCollectionWrap *w = new VtkPropCollectionWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkGL2PSExporterWrap::GetSilent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSilent();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetSimpleLineOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSimpleLineOffset();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetSort(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSort();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetSortAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSortAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGL2PSExporterWrap::GetSortMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSortMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetSortMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSortMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetText(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetText();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetTextAsPath(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTextAsPath();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::GetTitle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTitle();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGL2PSExporterWrap::GetWrite3DPropsAsRasterImage(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetWrite3DPropsAsRasterImage();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGL2PSExporterWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::LandscapeOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->LandscapeOff();
}

void VtkGL2PSExporterWrap::LandscapeOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->LandscapeOn();
}

void VtkGL2PSExporterWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	vtkGL2PSExporter * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkGL2PSExporterWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkGL2PSExporterWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkGL2PSExporterWrap *w = new VtkGL2PSExporterWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkGL2PSExporterWrap::OcclusionCullOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OcclusionCullOff();
}

void VtkGL2PSExporterWrap::OcclusionCullOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OcclusionCullOn();
}

void VtkGL2PSExporterWrap::PS3ShadingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PS3ShadingOff();
}

void VtkGL2PSExporterWrap::PS3ShadingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PS3ShadingOn();
}

void VtkGL2PSExporterWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkGL2PSExporter * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkGL2PSExporterWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkGL2PSExporterWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkGL2PSExporterWrap *w = new VtkGL2PSExporterWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetBestRoot(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetBestRoot(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetCompress(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetCompress(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetDrawBackground(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawBackground(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetFileFormat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFileFormat(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetFileFormatToEPS(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFileFormatToEPS();
}

void VtkGL2PSExporterWrap::SetFileFormatToPDF(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFileFormatToPDF();
}

void VtkGL2PSExporterWrap::SetFileFormatToPS(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFileFormatToPS();
}

void VtkGL2PSExporterWrap::SetFileFormatToSVG(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFileFormatToSVG();
}

void VtkGL2PSExporterWrap::SetFileFormatToTeX(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFileFormatToTeX();
}

void VtkGL2PSExporterWrap::SetFilePrefix(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFilePrefix(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetLandscape(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetLandscape(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetOcclusionCull(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOcclusionCull(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetPS3Shading(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetPS3Shading(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetRasterExclusions(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropCollectionWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropCollectionWrap *a0 = ObjectWrap::Unwrap<VtkPropCollectionWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetRasterExclusions(
			(vtkPropCollection *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetSilent(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSilent(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetSimpleLineOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSimpleLineOffset(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetSort(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSort(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetSortToBSP(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetSortToBSP();
}

void VtkGL2PSExporterWrap::SetSortToOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetSortToOff();
}

void VtkGL2PSExporterWrap::SetSortToSimple(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetSortToSimple();
}

void VtkGL2PSExporterWrap::SetText(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetText(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetTextAsPath(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTextAsPath(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetTitle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTitle(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SetWrite3DPropsAsRasterImage(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetWrite3DPropsAsRasterImage(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGL2PSExporterWrap::SilentOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SilentOff();
}

void VtkGL2PSExporterWrap::SilentOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SilentOn();
}

void VtkGL2PSExporterWrap::SimpleLineOffsetOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SimpleLineOffsetOff();
}

void VtkGL2PSExporterWrap::SimpleLineOffsetOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SimpleLineOffsetOn();
}

void VtkGL2PSExporterWrap::TextAsPathOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TextAsPathOff();
}

void VtkGL2PSExporterWrap::TextAsPathOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TextAsPathOn();
}

void VtkGL2PSExporterWrap::TextOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TextOff();
}

void VtkGL2PSExporterWrap::TextOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TextOn();
}

void VtkGL2PSExporterWrap::UsePainterSettings(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UsePainterSettings();
}

void VtkGL2PSExporterWrap::Write3DPropsAsRasterImageOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->Write3DPropsAsRasterImageOff();
}

void VtkGL2PSExporterWrap::Write3DPropsAsRasterImageOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGL2PSExporterWrap *wrapper = ObjectWrap::Unwrap<VtkGL2PSExporterWrap>(info.Holder());
	vtkGL2PSExporter *native = (vtkGL2PSExporter *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->Write3DPropsAsRasterImageOn();
}

