/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include "vtkPolyDataAlgorithmWrap.h"
#include "vtkParticleTracerBaseWrap.h"
#include "vtkObjectWrap.h"
#include "vtkInitialValueProblemSolverWrap.h"
#include "vtkAbstractParticleWriterWrap.h"
#include "vtkAlgorithmOutputWrap.h"
#include "../../plus/plus.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkParticleTracerBaseWrap::ptpl;

VtkParticleTracerBaseWrap::VtkParticleTracerBaseWrap()
{ }

VtkParticleTracerBaseWrap::VtkParticleTracerBaseWrap(vtkSmartPointer<vtkParticleTracerBase> _native)
{ native = _native; }

VtkParticleTracerBaseWrap::~VtkParticleTracerBaseWrap()
{ }

void VtkParticleTracerBaseWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkParticleTracerBase").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("ParticleTracerBase").ToLocalChecked(), ConstructorGetter);
}

void VtkParticleTracerBaseWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkParticleTracerBaseWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkPolyDataAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkPolyDataAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkParticleTracerBaseWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AddSourceConnection", AddSourceConnection);
	Nan::SetPrototypeMethod(tpl, "addSourceConnection", AddSourceConnection);

	Nan::SetPrototypeMethod(tpl, "DisableResetCacheOff", DisableResetCacheOff);
	Nan::SetPrototypeMethod(tpl, "disableResetCacheOff", DisableResetCacheOff);

	Nan::SetPrototypeMethod(tpl, "DisableResetCacheOn", DisableResetCacheOn);
	Nan::SetPrototypeMethod(tpl, "disableResetCacheOn", DisableResetCacheOn);

	Nan::SetPrototypeMethod(tpl, "EnableParticleWritingOff", EnableParticleWritingOff);
	Nan::SetPrototypeMethod(tpl, "enableParticleWritingOff", EnableParticleWritingOff);

	Nan::SetPrototypeMethod(tpl, "EnableParticleWritingOn", EnableParticleWritingOn);
	Nan::SetPrototypeMethod(tpl, "enableParticleWritingOn", EnableParticleWritingOn);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetComputeVorticity", GetComputeVorticity);
	Nan::SetPrototypeMethod(tpl, "getComputeVorticity", GetComputeVorticity);

	Nan::SetPrototypeMethod(tpl, "GetDisableResetCache", GetDisableResetCache);
	Nan::SetPrototypeMethod(tpl, "getDisableResetCache", GetDisableResetCache);

	Nan::SetPrototypeMethod(tpl, "GetEnableParticleWriting", GetEnableParticleWriting);
	Nan::SetPrototypeMethod(tpl, "getEnableParticleWriting", GetEnableParticleWriting);

	Nan::SetPrototypeMethod(tpl, "GetForceReinjectionEveryNSteps", GetForceReinjectionEveryNSteps);
	Nan::SetPrototypeMethod(tpl, "getForceReinjectionEveryNSteps", GetForceReinjectionEveryNSteps);

	Nan::SetPrototypeMethod(tpl, "GetIgnorePipelineTime", GetIgnorePipelineTime);
	Nan::SetPrototypeMethod(tpl, "getIgnorePipelineTime", GetIgnorePipelineTime);

	Nan::SetPrototypeMethod(tpl, "GetIntegrator", GetIntegrator);
	Nan::SetPrototypeMethod(tpl, "getIntegrator", GetIntegrator);

	Nan::SetPrototypeMethod(tpl, "GetIntegratorType", GetIntegratorType);
	Nan::SetPrototypeMethod(tpl, "getIntegratorType", GetIntegratorType);

	Nan::SetPrototypeMethod(tpl, "GetParticleFileName", GetParticleFileName);
	Nan::SetPrototypeMethod(tpl, "getParticleFileName", GetParticleFileName);

	Nan::SetPrototypeMethod(tpl, "GetParticleWriter", GetParticleWriter);
	Nan::SetPrototypeMethod(tpl, "getParticleWriter", GetParticleWriter);

	Nan::SetPrototypeMethod(tpl, "GetRotationScale", GetRotationScale);
	Nan::SetPrototypeMethod(tpl, "getRotationScale", GetRotationScale);

	Nan::SetPrototypeMethod(tpl, "GetStartTime", GetStartTime);
	Nan::SetPrototypeMethod(tpl, "getStartTime", GetStartTime);

	Nan::SetPrototypeMethod(tpl, "GetStaticMesh", GetStaticMesh);
	Nan::SetPrototypeMethod(tpl, "getStaticMesh", GetStaticMesh);

	Nan::SetPrototypeMethod(tpl, "GetStaticSeeds", GetStaticSeeds);
	Nan::SetPrototypeMethod(tpl, "getStaticSeeds", GetStaticSeeds);

	Nan::SetPrototypeMethod(tpl, "GetTerminalSpeed", GetTerminalSpeed);
	Nan::SetPrototypeMethod(tpl, "getTerminalSpeed", GetTerminalSpeed);

	Nan::SetPrototypeMethod(tpl, "GetTerminationTime", GetTerminationTime);
	Nan::SetPrototypeMethod(tpl, "getTerminationTime", GetTerminationTime);

	Nan::SetPrototypeMethod(tpl, "IgnorePipelineTimeOff", IgnorePipelineTimeOff);
	Nan::SetPrototypeMethod(tpl, "ignorePipelineTimeOff", IgnorePipelineTimeOff);

	Nan::SetPrototypeMethod(tpl, "IgnorePipelineTimeOn", IgnorePipelineTimeOn);
	Nan::SetPrototypeMethod(tpl, "ignorePipelineTimeOn", IgnorePipelineTimeOn);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "PrintParticleHistories", PrintParticleHistories);
	Nan::SetPrototypeMethod(tpl, "printParticleHistories", PrintParticleHistories);

	Nan::SetPrototypeMethod(tpl, "RemoveAllSources", RemoveAllSources);
	Nan::SetPrototypeMethod(tpl, "removeAllSources", RemoveAllSources);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetComputeVorticity", SetComputeVorticity);
	Nan::SetPrototypeMethod(tpl, "setComputeVorticity", SetComputeVorticity);

	Nan::SetPrototypeMethod(tpl, "SetDisableResetCache", SetDisableResetCache);
	Nan::SetPrototypeMethod(tpl, "setDisableResetCache", SetDisableResetCache);

	Nan::SetPrototypeMethod(tpl, "SetEnableParticleWriting", SetEnableParticleWriting);
	Nan::SetPrototypeMethod(tpl, "setEnableParticleWriting", SetEnableParticleWriting);

	Nan::SetPrototypeMethod(tpl, "SetForceReinjectionEveryNSteps", SetForceReinjectionEveryNSteps);
	Nan::SetPrototypeMethod(tpl, "setForceReinjectionEveryNSteps", SetForceReinjectionEveryNSteps);

	Nan::SetPrototypeMethod(tpl, "SetIgnorePipelineTime", SetIgnorePipelineTime);
	Nan::SetPrototypeMethod(tpl, "setIgnorePipelineTime", SetIgnorePipelineTime);

	Nan::SetPrototypeMethod(tpl, "SetIntegrator", SetIntegrator);
	Nan::SetPrototypeMethod(tpl, "setIntegrator", SetIntegrator);

	Nan::SetPrototypeMethod(tpl, "SetIntegratorType", SetIntegratorType);
	Nan::SetPrototypeMethod(tpl, "setIntegratorType", SetIntegratorType);

	Nan::SetPrototypeMethod(tpl, "SetParticleFileName", SetParticleFileName);
	Nan::SetPrototypeMethod(tpl, "setParticleFileName", SetParticleFileName);

	Nan::SetPrototypeMethod(tpl, "SetParticleWriter", SetParticleWriter);
	Nan::SetPrototypeMethod(tpl, "setParticleWriter", SetParticleWriter);

	Nan::SetPrototypeMethod(tpl, "SetRotationScale", SetRotationScale);
	Nan::SetPrototypeMethod(tpl, "setRotationScale", SetRotationScale);

	Nan::SetPrototypeMethod(tpl, "SetStartTime", SetStartTime);
	Nan::SetPrototypeMethod(tpl, "setStartTime", SetStartTime);

	Nan::SetPrototypeMethod(tpl, "SetStaticMesh", SetStaticMesh);
	Nan::SetPrototypeMethod(tpl, "setStaticMesh", SetStaticMesh);

	Nan::SetPrototypeMethod(tpl, "SetStaticSeeds", SetStaticSeeds);
	Nan::SetPrototypeMethod(tpl, "setStaticSeeds", SetStaticSeeds);

	Nan::SetPrototypeMethod(tpl, "SetTerminalSpeed", SetTerminalSpeed);
	Nan::SetPrototypeMethod(tpl, "setTerminalSpeed", SetTerminalSpeed);

	Nan::SetPrototypeMethod(tpl, "SetTerminationTime", SetTerminationTime);
	Nan::SetPrototypeMethod(tpl, "setTerminationTime", SetTerminationTime);

#ifdef VTK_NODE_PLUS_VTKPARTICLETRACERBASEWRAP_INITPTPL
	VTK_NODE_PLUS_VTKPARTICLETRACERBASEWRAP_INITPTPL
#endif
	ptpl.Reset( tpl );
}

void VtkParticleTracerBaseWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		Nan::ThrowError("Cannot create instance of abstract class.");
		return;
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkParticleTracerBaseWrap::AddSourceConnection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAlgorithmOutputWrap *a0 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->AddSourceConnection(
			(vtkAlgorithmOutput *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::DisableResetCacheOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DisableResetCacheOff();
}

void VtkParticleTracerBaseWrap::DisableResetCacheOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DisableResetCacheOn();
}

void VtkParticleTracerBaseWrap::EnableParticleWritingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->EnableParticleWritingOff();
}

void VtkParticleTracerBaseWrap::EnableParticleWritingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->EnableParticleWritingOn();
}

void VtkParticleTracerBaseWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkParticleTracerBaseWrap::GetComputeVorticity(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetComputeVorticity();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetDisableResetCache(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDisableResetCache();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetEnableParticleWriting(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEnableParticleWriting();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetForceReinjectionEveryNSteps(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetForceReinjectionEveryNSteps();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetIgnorePipelineTime(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIgnorePipelineTime();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetIntegrator(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	vtkInitialValueProblemSolver * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIntegrator();
	VtkInitialValueProblemSolverWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkInitialValueProblemSolverWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkInitialValueProblemSolverWrap *w = new VtkInitialValueProblemSolverWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkParticleTracerBaseWrap::GetIntegratorType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIntegratorType();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetParticleFileName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetParticleFileName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkParticleTracerBaseWrap::GetParticleWriter(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	vtkAbstractParticleWriter * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetParticleWriter();
	VtkAbstractParticleWriterWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkAbstractParticleWriterWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkAbstractParticleWriterWrap *w = new VtkAbstractParticleWriterWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkParticleTracerBaseWrap::GetRotationScale(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRotationScale();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetStartTime(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStartTime();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetStaticMesh(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStaticMesh();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetStaticSeeds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStaticSeeds();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetTerminalSpeed(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTerminalSpeed();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::GetTerminationTime(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTerminationTime();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParticleTracerBaseWrap::IgnorePipelineTimeOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->IgnorePipelineTimeOff();
}

void VtkParticleTracerBaseWrap::IgnorePipelineTimeOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->IgnorePipelineTimeOn();
}

void VtkParticleTracerBaseWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	vtkParticleTracerBase * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	VtkParticleTracerBaseWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkParticleTracerBaseWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkParticleTracerBaseWrap *w = new VtkParticleTracerBaseWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkParticleTracerBaseWrap::PrintParticleHistories(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->PrintParticleHistories();
}

void VtkParticleTracerBaseWrap::RemoveAllSources(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->RemoveAllSources();
}

void VtkParticleTracerBaseWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkParticleTracerBase * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
		VtkParticleTracerBaseWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkParticleTracerBaseWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkParticleTracerBaseWrap *w = new VtkParticleTracerBaseWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetComputeVorticity(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetComputeVorticity(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetDisableResetCache(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDisableResetCache(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetEnableParticleWriting(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEnableParticleWriting(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetForceReinjectionEveryNSteps(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetForceReinjectionEveryNSteps(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetIgnorePipelineTime(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIgnorePipelineTime(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetIntegrator(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkInitialValueProblemSolverWrap::ptpl))->HasInstance(info[0]))
	{
		VtkInitialValueProblemSolverWrap *a0 = ObjectWrap::Unwrap<VtkInitialValueProblemSolverWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIntegrator(
			(vtkInitialValueProblemSolver *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetIntegratorType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIntegratorType(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetParticleFileName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetParticleFileName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetParticleWriter(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAbstractParticleWriterWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAbstractParticleWriterWrap *a0 = ObjectWrap::Unwrap<VtkAbstractParticleWriterWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetParticleWriter(
			(vtkAbstractParticleWriter *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetRotationScale(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetRotationScale(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetStartTime(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStartTime(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetStaticMesh(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStaticMesh(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetStaticSeeds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStaticSeeds(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetTerminalSpeed(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTerminalSpeed(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParticleTracerBaseWrap::SetTerminationTime(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParticleTracerBaseWrap *wrapper = ObjectWrap::Unwrap<VtkParticleTracerBaseWrap>(info.Holder());
	vtkParticleTracerBase *native = (vtkParticleTracerBase *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTerminationTime(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

