/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkRenderViewWrap.h"
#include "vtkTreeAreaViewWrap.h"
#include "vtkObjectWrap.h"
#include "vtkDataRepresentationWrap.h"
#include "vtkAlgorithmOutputWrap.h"
#include "vtkTreeWrap.h"
#include "vtkGraphWrap.h"
#include "vtkAreaLayoutStrategyWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkTreeAreaViewWrap::ptpl;

VtkTreeAreaViewWrap::VtkTreeAreaViewWrap()
{ }

VtkTreeAreaViewWrap::VtkTreeAreaViewWrap(vtkSmartPointer<vtkTreeAreaView> _native)
{ native = _native; }

VtkTreeAreaViewWrap::~VtkTreeAreaViewWrap()
{ }

void VtkTreeAreaViewWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkTreeAreaView").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("TreeAreaView").ToLocalChecked(), ConstructorGetter);
}

void VtkTreeAreaViewWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkTreeAreaViewWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkRenderViewWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkRenderViewWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkTreeAreaViewWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AreaLabelVisibilityOff", AreaLabelVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "areaLabelVisibilityOff", AreaLabelVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "AreaLabelVisibilityOn", AreaLabelVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "areaLabelVisibilityOn", AreaLabelVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "ColorAreasOff", ColorAreasOff);
	Nan::SetPrototypeMethod(tpl, "colorAreasOff", ColorAreasOff);

	Nan::SetPrototypeMethod(tpl, "ColorAreasOn", ColorAreasOn);
	Nan::SetPrototypeMethod(tpl, "colorAreasOn", ColorAreasOn);

	Nan::SetPrototypeMethod(tpl, "ColorEdgesOff", ColorEdgesOff);
	Nan::SetPrototypeMethod(tpl, "colorEdgesOff", ColorEdgesOff);

	Nan::SetPrototypeMethod(tpl, "ColorEdgesOn", ColorEdgesOn);
	Nan::SetPrototypeMethod(tpl, "colorEdgesOn", ColorEdgesOn);

	Nan::SetPrototypeMethod(tpl, "EdgeLabelVisibilityOff", EdgeLabelVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "edgeLabelVisibilityOff", EdgeLabelVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "EdgeLabelVisibilityOn", EdgeLabelVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "edgeLabelVisibilityOn", EdgeLabelVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "GetAreaColorArrayName", GetAreaColorArrayName);
	Nan::SetPrototypeMethod(tpl, "getAreaColorArrayName", GetAreaColorArrayName);

	Nan::SetPrototypeMethod(tpl, "GetAreaHoverArrayName", GetAreaHoverArrayName);
	Nan::SetPrototypeMethod(tpl, "getAreaHoverArrayName", GetAreaHoverArrayName);

	Nan::SetPrototypeMethod(tpl, "GetAreaLabelArrayName", GetAreaLabelArrayName);
	Nan::SetPrototypeMethod(tpl, "getAreaLabelArrayName", GetAreaLabelArrayName);

	Nan::SetPrototypeMethod(tpl, "GetAreaLabelFontSize", GetAreaLabelFontSize);
	Nan::SetPrototypeMethod(tpl, "getAreaLabelFontSize", GetAreaLabelFontSize);

	Nan::SetPrototypeMethod(tpl, "GetAreaSizeArrayName", GetAreaSizeArrayName);
	Nan::SetPrototypeMethod(tpl, "getAreaSizeArrayName", GetAreaSizeArrayName);

	Nan::SetPrototypeMethod(tpl, "GetBundlingStrength", GetBundlingStrength);
	Nan::SetPrototypeMethod(tpl, "getBundlingStrength", GetBundlingStrength);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetEdgeColorArrayName", GetEdgeColorArrayName);
	Nan::SetPrototypeMethod(tpl, "getEdgeColorArrayName", GetEdgeColorArrayName);

	Nan::SetPrototypeMethod(tpl, "GetEdgeLabelArrayName", GetEdgeLabelArrayName);
	Nan::SetPrototypeMethod(tpl, "getEdgeLabelArrayName", GetEdgeLabelArrayName);

	Nan::SetPrototypeMethod(tpl, "GetEdgeLabelFontSize", GetEdgeLabelFontSize);
	Nan::SetPrototypeMethod(tpl, "getEdgeLabelFontSize", GetEdgeLabelFontSize);

	Nan::SetPrototypeMethod(tpl, "GetLabelPriorityArrayName", GetLabelPriorityArrayName);
	Nan::SetPrototypeMethod(tpl, "getLabelPriorityArrayName", GetLabelPriorityArrayName);

	Nan::SetPrototypeMethod(tpl, "GetLayoutStrategy", GetLayoutStrategy);
	Nan::SetPrototypeMethod(tpl, "getLayoutStrategy", GetLayoutStrategy);

	Nan::SetPrototypeMethod(tpl, "GetShrinkPercentage", GetShrinkPercentage);
	Nan::SetPrototypeMethod(tpl, "getShrinkPercentage", GetShrinkPercentage);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetAreaColorArrayName", SetAreaColorArrayName);
	Nan::SetPrototypeMethod(tpl, "setAreaColorArrayName", SetAreaColorArrayName);

	Nan::SetPrototypeMethod(tpl, "SetAreaHoverArrayName", SetAreaHoverArrayName);
	Nan::SetPrototypeMethod(tpl, "setAreaHoverArrayName", SetAreaHoverArrayName);

	Nan::SetPrototypeMethod(tpl, "SetAreaLabelArrayName", SetAreaLabelArrayName);
	Nan::SetPrototypeMethod(tpl, "setAreaLabelArrayName", SetAreaLabelArrayName);

	Nan::SetPrototypeMethod(tpl, "SetAreaLabelFontSize", SetAreaLabelFontSize);
	Nan::SetPrototypeMethod(tpl, "setAreaLabelFontSize", SetAreaLabelFontSize);

	Nan::SetPrototypeMethod(tpl, "SetAreaSizeArrayName", SetAreaSizeArrayName);
	Nan::SetPrototypeMethod(tpl, "setAreaSizeArrayName", SetAreaSizeArrayName);

	Nan::SetPrototypeMethod(tpl, "SetBundlingStrength", SetBundlingStrength);
	Nan::SetPrototypeMethod(tpl, "setBundlingStrength", SetBundlingStrength);

	Nan::SetPrototypeMethod(tpl, "SetEdgeColorArrayName", SetEdgeColorArrayName);
	Nan::SetPrototypeMethod(tpl, "setEdgeColorArrayName", SetEdgeColorArrayName);

	Nan::SetPrototypeMethod(tpl, "SetEdgeColorToSplineFraction", SetEdgeColorToSplineFraction);
	Nan::SetPrototypeMethod(tpl, "setEdgeColorToSplineFraction", SetEdgeColorToSplineFraction);

	Nan::SetPrototypeMethod(tpl, "SetEdgeLabelArrayName", SetEdgeLabelArrayName);
	Nan::SetPrototypeMethod(tpl, "setEdgeLabelArrayName", SetEdgeLabelArrayName);

	Nan::SetPrototypeMethod(tpl, "SetEdgeLabelFontSize", SetEdgeLabelFontSize);
	Nan::SetPrototypeMethod(tpl, "setEdgeLabelFontSize", SetEdgeLabelFontSize);

	Nan::SetPrototypeMethod(tpl, "SetGraphFromInput", SetGraphFromInput);
	Nan::SetPrototypeMethod(tpl, "setGraphFromInput", SetGraphFromInput);

	Nan::SetPrototypeMethod(tpl, "SetGraphFromInputConnection", SetGraphFromInputConnection);
	Nan::SetPrototypeMethod(tpl, "setGraphFromInputConnection", SetGraphFromInputConnection);

	Nan::SetPrototypeMethod(tpl, "SetLabelPriorityArrayName", SetLabelPriorityArrayName);
	Nan::SetPrototypeMethod(tpl, "setLabelPriorityArrayName", SetLabelPriorityArrayName);

	Nan::SetPrototypeMethod(tpl, "SetLayoutStrategy", SetLayoutStrategy);
	Nan::SetPrototypeMethod(tpl, "setLayoutStrategy", SetLayoutStrategy);

	Nan::SetPrototypeMethod(tpl, "SetShrinkPercentage", SetShrinkPercentage);
	Nan::SetPrototypeMethod(tpl, "setShrinkPercentage", SetShrinkPercentage);

	Nan::SetPrototypeMethod(tpl, "SetTreeFromInput", SetTreeFromInput);
	Nan::SetPrototypeMethod(tpl, "setTreeFromInput", SetTreeFromInput);

	Nan::SetPrototypeMethod(tpl, "SetTreeFromInputConnection", SetTreeFromInputConnection);
	Nan::SetPrototypeMethod(tpl, "setTreeFromInputConnection", SetTreeFromInputConnection);

	Nan::SetPrototypeMethod(tpl, "UseRectangularCoordinatesOff", UseRectangularCoordinatesOff);
	Nan::SetPrototypeMethod(tpl, "useRectangularCoordinatesOff", UseRectangularCoordinatesOff);

	Nan::SetPrototypeMethod(tpl, "UseRectangularCoordinatesOn", UseRectangularCoordinatesOn);
	Nan::SetPrototypeMethod(tpl, "useRectangularCoordinatesOn", UseRectangularCoordinatesOn);

	ptpl.Reset( tpl );
}

void VtkTreeAreaViewWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkTreeAreaView> native = vtkSmartPointer<vtkTreeAreaView>::New();
		VtkTreeAreaViewWrap* obj = new VtkTreeAreaViewWrap(native);		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkTreeAreaViewWrap::AreaLabelVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AreaLabelVisibilityOff();
}

void VtkTreeAreaViewWrap::AreaLabelVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AreaLabelVisibilityOn();
}

void VtkTreeAreaViewWrap::ColorAreasOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ColorAreasOff();
}

void VtkTreeAreaViewWrap::ColorAreasOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ColorAreasOn();
}

void VtkTreeAreaViewWrap::ColorEdgesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ColorEdgesOff();
}

void VtkTreeAreaViewWrap::ColorEdgesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ColorEdgesOn();
}

void VtkTreeAreaViewWrap::EdgeLabelVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->EdgeLabelVisibilityOff();
}

void VtkTreeAreaViewWrap::EdgeLabelVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->EdgeLabelVisibilityOn();
}

void VtkTreeAreaViewWrap::GetAreaColorArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAreaColorArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTreeAreaViewWrap::GetAreaHoverArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAreaHoverArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTreeAreaViewWrap::GetAreaLabelArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAreaLabelArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTreeAreaViewWrap::GetAreaLabelFontSize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAreaLabelFontSize();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTreeAreaViewWrap::GetAreaSizeArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAreaSizeArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTreeAreaViewWrap::GetBundlingStrength(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetBundlingStrength();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTreeAreaViewWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTreeAreaViewWrap::GetEdgeColorArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeColorArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTreeAreaViewWrap::GetEdgeLabelArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeLabelArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTreeAreaViewWrap::GetEdgeLabelFontSize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeLabelFontSize();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTreeAreaViewWrap::GetLabelPriorityArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLabelPriorityArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkTreeAreaViewWrap::GetLayoutStrategy(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	vtkAreaLayoutStrategy * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLayoutStrategy();
		VtkAreaLayoutStrategyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkAreaLayoutStrategyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkAreaLayoutStrategyWrap *w = new VtkAreaLayoutStrategyWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkTreeAreaViewWrap::GetShrinkPercentage(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetShrinkPercentage();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkTreeAreaViewWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	vtkTreeAreaView * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkTreeAreaViewWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkTreeAreaViewWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkTreeAreaViewWrap *w = new VtkTreeAreaViewWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkTreeAreaViewWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkTreeAreaView * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkTreeAreaViewWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkTreeAreaViewWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkTreeAreaViewWrap *w = new VtkTreeAreaViewWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetAreaColorArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAreaColorArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetAreaHoverArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAreaHoverArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetAreaLabelArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAreaLabelArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetAreaLabelFontSize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAreaLabelFontSize(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetAreaSizeArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAreaSizeArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetBundlingStrength(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetBundlingStrength(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetEdgeColorArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEdgeColorArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetEdgeColorToSplineFraction(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetEdgeColorToSplineFraction();
}

void VtkTreeAreaViewWrap::SetEdgeLabelArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEdgeLabelArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetEdgeLabelFontSize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEdgeLabelFontSize(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetGraphFromInput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkGraphWrap::ptpl))->HasInstance(info[0]))
	{
		VtkGraphWrap *a0 = ObjectWrap::Unwrap<VtkGraphWrap>(info[0]->ToObject());
		vtkDataRepresentation * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetGraphFromInput(
			(vtkGraph *) a0->native.GetPointer()
		);
			VtkDataRepresentationWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataRepresentationWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataRepresentationWrap *w = new VtkDataRepresentationWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetGraphFromInputConnection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAlgorithmOutputWrap *a0 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[0]->ToObject());
		vtkDataRepresentation * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetGraphFromInputConnection(
			(vtkAlgorithmOutput *) a0->native.GetPointer()
		);
			VtkDataRepresentationWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataRepresentationWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataRepresentationWrap *w = new VtkDataRepresentationWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetLabelPriorityArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetLabelPriorityArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetLayoutStrategy(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAreaLayoutStrategyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAreaLayoutStrategyWrap *a0 = ObjectWrap::Unwrap<VtkAreaLayoutStrategyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetLayoutStrategy(
			(vtkAreaLayoutStrategy *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetShrinkPercentage(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetShrinkPercentage(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetTreeFromInput(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkTreeWrap::ptpl))->HasInstance(info[0]))
	{
		VtkTreeWrap *a0 = ObjectWrap::Unwrap<VtkTreeWrap>(info[0]->ToObject());
		vtkDataRepresentation * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetTreeFromInput(
			(vtkTree *) a0->native.GetPointer()
		);
			VtkDataRepresentationWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataRepresentationWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataRepresentationWrap *w = new VtkDataRepresentationWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::SetTreeFromInputConnection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAlgorithmOutputWrap *a0 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[0]->ToObject());
		vtkDataRepresentation * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetTreeFromInputConnection(
			(vtkAlgorithmOutput *) a0->native.GetPointer()
		);
			VtkDataRepresentationWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataRepresentationWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataRepresentationWrap *w = new VtkDataRepresentationWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkTreeAreaViewWrap::UseRectangularCoordinatesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseRectangularCoordinatesOff();
}

void VtkTreeAreaViewWrap::UseRectangularCoordinatesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkTreeAreaViewWrap *wrapper = ObjectWrap::Unwrap<VtkTreeAreaViewWrap>(info.Holder());
	vtkTreeAreaView *native = (vtkTreeAreaView *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseRectangularCoordinatesOn();
}

