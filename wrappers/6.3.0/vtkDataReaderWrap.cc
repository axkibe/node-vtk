/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkAlgorithmWrap.h"
#include "vtkDataReaderWrap.h"
#include "vtkObjectWrap.h"
#include "vtkCharArrayWrap.h"
#include "vtkDataSetWrap.h"
#include "vtkPointSetWrap.h"
#include "vtkGraphWrap.h"
#include "vtkTableWrap.h"
#include "vtkRectilinearGridWrap.h"
#include "vtkAbstractArrayWrap.h"
#include "vtkInformationWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkDataReaderWrap::ptpl;

VtkDataReaderWrap::VtkDataReaderWrap()
{ }

VtkDataReaderWrap::VtkDataReaderWrap(vtkSmartPointer<vtkDataReader> _native)
{ native = _native; }

VtkDataReaderWrap::~VtkDataReaderWrap()
{ }

void VtkDataReaderWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkDataReader").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("DataReader").ToLocalChecked(), ConstructorGetter);
}

void VtkDataReaderWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkDataReaderWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkDataReaderWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "CloseVTKFile", CloseVTKFile);
	Nan::SetPrototypeMethod(tpl, "closeVTKFile", CloseVTKFile);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetFieldDataName", GetFieldDataName);
	Nan::SetPrototypeMethod(tpl, "getFieldDataName", GetFieldDataName);

	Nan::SetPrototypeMethod(tpl, "GetFieldDataNameInFile", GetFieldDataNameInFile);
	Nan::SetPrototypeMethod(tpl, "getFieldDataNameInFile", GetFieldDataNameInFile);

	Nan::SetPrototypeMethod(tpl, "GetFileMajorVersion", GetFileMajorVersion);
	Nan::SetPrototypeMethod(tpl, "getFileMajorVersion", GetFileMajorVersion);

	Nan::SetPrototypeMethod(tpl, "GetFileMinorVersion", GetFileMinorVersion);
	Nan::SetPrototypeMethod(tpl, "getFileMinorVersion", GetFileMinorVersion);

	Nan::SetPrototypeMethod(tpl, "GetFileName", GetFileName);
	Nan::SetPrototypeMethod(tpl, "getFileName", GetFileName);

	Nan::SetPrototypeMethod(tpl, "GetFileType", GetFileType);
	Nan::SetPrototypeMethod(tpl, "getFileType", GetFileType);

	Nan::SetPrototypeMethod(tpl, "GetHeader", GetHeader);
	Nan::SetPrototypeMethod(tpl, "getHeader", GetHeader);

	Nan::SetPrototypeMethod(tpl, "GetInputArray", GetInputArray);
	Nan::SetPrototypeMethod(tpl, "getInputArray", GetInputArray);

	Nan::SetPrototypeMethod(tpl, "GetInputString", GetInputString);
	Nan::SetPrototypeMethod(tpl, "getInputString", GetInputString);

	Nan::SetPrototypeMethod(tpl, "GetInputStringLength", GetInputStringLength);
	Nan::SetPrototypeMethod(tpl, "getInputStringLength", GetInputStringLength);

	Nan::SetPrototypeMethod(tpl, "GetLookupTableName", GetLookupTableName);
	Nan::SetPrototypeMethod(tpl, "getLookupTableName", GetLookupTableName);

	Nan::SetPrototypeMethod(tpl, "GetNormalsName", GetNormalsName);
	Nan::SetPrototypeMethod(tpl, "getNormalsName", GetNormalsName);

	Nan::SetPrototypeMethod(tpl, "GetNormalsNameInFile", GetNormalsNameInFile);
	Nan::SetPrototypeMethod(tpl, "getNormalsNameInFile", GetNormalsNameInFile);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfFieldDataInFile", GetNumberOfFieldDataInFile);
	Nan::SetPrototypeMethod(tpl, "getNumberOfFieldDataInFile", GetNumberOfFieldDataInFile);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfNormalsInFile", GetNumberOfNormalsInFile);
	Nan::SetPrototypeMethod(tpl, "getNumberOfNormalsInFile", GetNumberOfNormalsInFile);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfScalarsInFile", GetNumberOfScalarsInFile);
	Nan::SetPrototypeMethod(tpl, "getNumberOfScalarsInFile", GetNumberOfScalarsInFile);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfTCoordsInFile", GetNumberOfTCoordsInFile);
	Nan::SetPrototypeMethod(tpl, "getNumberOfTCoordsInFile", GetNumberOfTCoordsInFile);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfTensorsInFile", GetNumberOfTensorsInFile);
	Nan::SetPrototypeMethod(tpl, "getNumberOfTensorsInFile", GetNumberOfTensorsInFile);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfVectorsInFile", GetNumberOfVectorsInFile);
	Nan::SetPrototypeMethod(tpl, "getNumberOfVectorsInFile", GetNumberOfVectorsInFile);

	Nan::SetPrototypeMethod(tpl, "GetReadAllColorScalars", GetReadAllColorScalars);
	Nan::SetPrototypeMethod(tpl, "getReadAllColorScalars", GetReadAllColorScalars);

	Nan::SetPrototypeMethod(tpl, "GetReadAllFields", GetReadAllFields);
	Nan::SetPrototypeMethod(tpl, "getReadAllFields", GetReadAllFields);

	Nan::SetPrototypeMethod(tpl, "GetReadAllNormals", GetReadAllNormals);
	Nan::SetPrototypeMethod(tpl, "getReadAllNormals", GetReadAllNormals);

	Nan::SetPrototypeMethod(tpl, "GetReadAllScalars", GetReadAllScalars);
	Nan::SetPrototypeMethod(tpl, "getReadAllScalars", GetReadAllScalars);

	Nan::SetPrototypeMethod(tpl, "GetReadAllTCoords", GetReadAllTCoords);
	Nan::SetPrototypeMethod(tpl, "getReadAllTCoords", GetReadAllTCoords);

	Nan::SetPrototypeMethod(tpl, "GetReadAllTensors", GetReadAllTensors);
	Nan::SetPrototypeMethod(tpl, "getReadAllTensors", GetReadAllTensors);

	Nan::SetPrototypeMethod(tpl, "GetReadAllVectors", GetReadAllVectors);
	Nan::SetPrototypeMethod(tpl, "getReadAllVectors", GetReadAllVectors);

	Nan::SetPrototypeMethod(tpl, "GetReadFromInputString", GetReadFromInputString);
	Nan::SetPrototypeMethod(tpl, "getReadFromInputString", GetReadFromInputString);

	Nan::SetPrototypeMethod(tpl, "GetScalarsName", GetScalarsName);
	Nan::SetPrototypeMethod(tpl, "getScalarsName", GetScalarsName);

	Nan::SetPrototypeMethod(tpl, "GetScalarsNameInFile", GetScalarsNameInFile);
	Nan::SetPrototypeMethod(tpl, "getScalarsNameInFile", GetScalarsNameInFile);

	Nan::SetPrototypeMethod(tpl, "GetTCoordsName", GetTCoordsName);
	Nan::SetPrototypeMethod(tpl, "getTCoordsName", GetTCoordsName);

	Nan::SetPrototypeMethod(tpl, "GetTCoordsNameInFile", GetTCoordsNameInFile);
	Nan::SetPrototypeMethod(tpl, "getTCoordsNameInFile", GetTCoordsNameInFile);

	Nan::SetPrototypeMethod(tpl, "GetTensorsName", GetTensorsName);
	Nan::SetPrototypeMethod(tpl, "getTensorsName", GetTensorsName);

	Nan::SetPrototypeMethod(tpl, "GetTensorsNameInFile", GetTensorsNameInFile);
	Nan::SetPrototypeMethod(tpl, "getTensorsNameInFile", GetTensorsNameInFile);

	Nan::SetPrototypeMethod(tpl, "GetVectorsName", GetVectorsName);
	Nan::SetPrototypeMethod(tpl, "getVectorsName", GetVectorsName);

	Nan::SetPrototypeMethod(tpl, "GetVectorsNameInFile", GetVectorsNameInFile);
	Nan::SetPrototypeMethod(tpl, "getVectorsNameInFile", GetVectorsNameInFile);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "IsFilePolyData", IsFilePolyData);
	Nan::SetPrototypeMethod(tpl, "isFilePolyData", IsFilePolyData);

	Nan::SetPrototypeMethod(tpl, "IsFileRectilinearGrid", IsFileRectilinearGrid);
	Nan::SetPrototypeMethod(tpl, "isFileRectilinearGrid", IsFileRectilinearGrid);

	Nan::SetPrototypeMethod(tpl, "IsFileStructuredGrid", IsFileStructuredGrid);
	Nan::SetPrototypeMethod(tpl, "isFileStructuredGrid", IsFileStructuredGrid);

	Nan::SetPrototypeMethod(tpl, "IsFileStructuredPoints", IsFileStructuredPoints);
	Nan::SetPrototypeMethod(tpl, "isFileStructuredPoints", IsFileStructuredPoints);

	Nan::SetPrototypeMethod(tpl, "IsFileUnstructuredGrid", IsFileUnstructuredGrid);
	Nan::SetPrototypeMethod(tpl, "isFileUnstructuredGrid", IsFileUnstructuredGrid);

	Nan::SetPrototypeMethod(tpl, "IsFileValid", IsFileValid);
	Nan::SetPrototypeMethod(tpl, "isFileValid", IsFileValid);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "OpenVTKFile", OpenVTKFile);
	Nan::SetPrototypeMethod(tpl, "openVTKFile", OpenVTKFile);

	Nan::SetPrototypeMethod(tpl, "Read", Read);
	Nan::SetPrototypeMethod(tpl, "read", Read);

	Nan::SetPrototypeMethod(tpl, "ReadAllColorScalarsOff", ReadAllColorScalarsOff);
	Nan::SetPrototypeMethod(tpl, "readAllColorScalarsOff", ReadAllColorScalarsOff);

	Nan::SetPrototypeMethod(tpl, "ReadAllColorScalarsOn", ReadAllColorScalarsOn);
	Nan::SetPrototypeMethod(tpl, "readAllColorScalarsOn", ReadAllColorScalarsOn);

	Nan::SetPrototypeMethod(tpl, "ReadAllFieldsOff", ReadAllFieldsOff);
	Nan::SetPrototypeMethod(tpl, "readAllFieldsOff", ReadAllFieldsOff);

	Nan::SetPrototypeMethod(tpl, "ReadAllFieldsOn", ReadAllFieldsOn);
	Nan::SetPrototypeMethod(tpl, "readAllFieldsOn", ReadAllFieldsOn);

	Nan::SetPrototypeMethod(tpl, "ReadAllNormalsOff", ReadAllNormalsOff);
	Nan::SetPrototypeMethod(tpl, "readAllNormalsOff", ReadAllNormalsOff);

	Nan::SetPrototypeMethod(tpl, "ReadAllNormalsOn", ReadAllNormalsOn);
	Nan::SetPrototypeMethod(tpl, "readAllNormalsOn", ReadAllNormalsOn);

	Nan::SetPrototypeMethod(tpl, "ReadAllScalarsOff", ReadAllScalarsOff);
	Nan::SetPrototypeMethod(tpl, "readAllScalarsOff", ReadAllScalarsOff);

	Nan::SetPrototypeMethod(tpl, "ReadAllScalarsOn", ReadAllScalarsOn);
	Nan::SetPrototypeMethod(tpl, "readAllScalarsOn", ReadAllScalarsOn);

	Nan::SetPrototypeMethod(tpl, "ReadAllTCoordsOff", ReadAllTCoordsOff);
	Nan::SetPrototypeMethod(tpl, "readAllTCoordsOff", ReadAllTCoordsOff);

	Nan::SetPrototypeMethod(tpl, "ReadAllTCoordsOn", ReadAllTCoordsOn);
	Nan::SetPrototypeMethod(tpl, "readAllTCoordsOn", ReadAllTCoordsOn);

	Nan::SetPrototypeMethod(tpl, "ReadAllTensorsOff", ReadAllTensorsOff);
	Nan::SetPrototypeMethod(tpl, "readAllTensorsOff", ReadAllTensorsOff);

	Nan::SetPrototypeMethod(tpl, "ReadAllTensorsOn", ReadAllTensorsOn);
	Nan::SetPrototypeMethod(tpl, "readAllTensorsOn", ReadAllTensorsOn);

	Nan::SetPrototypeMethod(tpl, "ReadAllVectorsOff", ReadAllVectorsOff);
	Nan::SetPrototypeMethod(tpl, "readAllVectorsOff", ReadAllVectorsOff);

	Nan::SetPrototypeMethod(tpl, "ReadAllVectorsOn", ReadAllVectorsOn);
	Nan::SetPrototypeMethod(tpl, "readAllVectorsOn", ReadAllVectorsOn);

	Nan::SetPrototypeMethod(tpl, "ReadArray", ReadArray);
	Nan::SetPrototypeMethod(tpl, "readArray", ReadArray);

	Nan::SetPrototypeMethod(tpl, "ReadCellData", ReadCellData);
	Nan::SetPrototypeMethod(tpl, "readCellData", ReadCellData);

	Nan::SetPrototypeMethod(tpl, "ReadCoordinates", ReadCoordinates);
	Nan::SetPrototypeMethod(tpl, "readCoordinates", ReadCoordinates);

	Nan::SetPrototypeMethod(tpl, "ReadEdgeData", ReadEdgeData);
	Nan::SetPrototypeMethod(tpl, "readEdgeData", ReadEdgeData);

	Nan::SetPrototypeMethod(tpl, "ReadFromInputStringOff", ReadFromInputStringOff);
	Nan::SetPrototypeMethod(tpl, "readFromInputStringOff", ReadFromInputStringOff);

	Nan::SetPrototypeMethod(tpl, "ReadFromInputStringOn", ReadFromInputStringOn);
	Nan::SetPrototypeMethod(tpl, "readFromInputStringOn", ReadFromInputStringOn);

	Nan::SetPrototypeMethod(tpl, "ReadHeader", ReadHeader);
	Nan::SetPrototypeMethod(tpl, "readHeader", ReadHeader);

	Nan::SetPrototypeMethod(tpl, "ReadLine", ReadLine);
	Nan::SetPrototypeMethod(tpl, "readLine", ReadLine);

	Nan::SetPrototypeMethod(tpl, "ReadMetaData", ReadMetaData);
	Nan::SetPrototypeMethod(tpl, "readMetaData", ReadMetaData);

	Nan::SetPrototypeMethod(tpl, "ReadPointData", ReadPointData);
	Nan::SetPrototypeMethod(tpl, "readPointData", ReadPointData);

	Nan::SetPrototypeMethod(tpl, "ReadPoints", ReadPoints);
	Nan::SetPrototypeMethod(tpl, "readPoints", ReadPoints);

	Nan::SetPrototypeMethod(tpl, "ReadRowData", ReadRowData);
	Nan::SetPrototypeMethod(tpl, "readRowData", ReadRowData);

	Nan::SetPrototypeMethod(tpl, "ReadString", ReadString);
	Nan::SetPrototypeMethod(tpl, "readString", ReadString);

	Nan::SetPrototypeMethod(tpl, "ReadVertexData", ReadVertexData);
	Nan::SetPrototypeMethod(tpl, "readVertexData", ReadVertexData);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetBinaryInputString", SetBinaryInputString);
	Nan::SetPrototypeMethod(tpl, "setBinaryInputString", SetBinaryInputString);

	Nan::SetPrototypeMethod(tpl, "SetFieldDataName", SetFieldDataName);
	Nan::SetPrototypeMethod(tpl, "setFieldDataName", SetFieldDataName);

	Nan::SetPrototypeMethod(tpl, "SetFileName", SetFileName);
	Nan::SetPrototypeMethod(tpl, "setFileName", SetFileName);

	Nan::SetPrototypeMethod(tpl, "SetInputArray", SetInputArray);
	Nan::SetPrototypeMethod(tpl, "setInputArray", SetInputArray);

	Nan::SetPrototypeMethod(tpl, "SetInputString", SetInputString);
	Nan::SetPrototypeMethod(tpl, "setInputString", SetInputString);

	Nan::SetPrototypeMethod(tpl, "SetLookupTableName", SetLookupTableName);
	Nan::SetPrototypeMethod(tpl, "setLookupTableName", SetLookupTableName);

	Nan::SetPrototypeMethod(tpl, "SetNormalsName", SetNormalsName);
	Nan::SetPrototypeMethod(tpl, "setNormalsName", SetNormalsName);

	Nan::SetPrototypeMethod(tpl, "SetReadAllColorScalars", SetReadAllColorScalars);
	Nan::SetPrototypeMethod(tpl, "setReadAllColorScalars", SetReadAllColorScalars);

	Nan::SetPrototypeMethod(tpl, "SetReadAllFields", SetReadAllFields);
	Nan::SetPrototypeMethod(tpl, "setReadAllFields", SetReadAllFields);

	Nan::SetPrototypeMethod(tpl, "SetReadAllNormals", SetReadAllNormals);
	Nan::SetPrototypeMethod(tpl, "setReadAllNormals", SetReadAllNormals);

	Nan::SetPrototypeMethod(tpl, "SetReadAllScalars", SetReadAllScalars);
	Nan::SetPrototypeMethod(tpl, "setReadAllScalars", SetReadAllScalars);

	Nan::SetPrototypeMethod(tpl, "SetReadAllTCoords", SetReadAllTCoords);
	Nan::SetPrototypeMethod(tpl, "setReadAllTCoords", SetReadAllTCoords);

	Nan::SetPrototypeMethod(tpl, "SetReadAllTensors", SetReadAllTensors);
	Nan::SetPrototypeMethod(tpl, "setReadAllTensors", SetReadAllTensors);

	Nan::SetPrototypeMethod(tpl, "SetReadAllVectors", SetReadAllVectors);
	Nan::SetPrototypeMethod(tpl, "setReadAllVectors", SetReadAllVectors);

	Nan::SetPrototypeMethod(tpl, "SetReadFromInputString", SetReadFromInputString);
	Nan::SetPrototypeMethod(tpl, "setReadFromInputString", SetReadFromInputString);

	Nan::SetPrototypeMethod(tpl, "SetScalarsName", SetScalarsName);
	Nan::SetPrototypeMethod(tpl, "setScalarsName", SetScalarsName);

	Nan::SetPrototypeMethod(tpl, "SetTCoordsName", SetTCoordsName);
	Nan::SetPrototypeMethod(tpl, "setTCoordsName", SetTCoordsName);

	Nan::SetPrototypeMethod(tpl, "SetTensorsName", SetTensorsName);
	Nan::SetPrototypeMethod(tpl, "setTensorsName", SetTensorsName);

	Nan::SetPrototypeMethod(tpl, "SetVectorsName", SetVectorsName);
	Nan::SetPrototypeMethod(tpl, "setVectorsName", SetVectorsName);

	ptpl.Reset( tpl );
}

void VtkDataReaderWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkDataReader> native = vtkSmartPointer<vtkDataReader>::New();
		VtkDataReaderWrap* obj = new VtkDataReaderWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkDataReaderWrap::CloseVTKFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CloseVTKFile();
}

void VtkDataReaderWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetFieldDataName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFieldDataName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetFieldDataNameInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetFieldDataNameInFile(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::GetFileMajorVersion(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFileMajorVersion();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetFileMinorVersion(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFileMinorVersion();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetFileName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFileName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetFileType(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFileType();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetHeader(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetHeader();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetInputArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	vtkCharArray * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInputArray();
		VtkCharArrayWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkCharArrayWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkCharArrayWrap *w = new VtkCharArrayWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataReaderWrap::GetInputString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInputString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetInputStringLength(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInputStringLength();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetLookupTableName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLookupTableName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetNormalsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNormalsName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetNormalsNameInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetNormalsNameInFile(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::GetNumberOfFieldDataInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfFieldDataInFile();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetNumberOfNormalsInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfNormalsInFile();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetNumberOfScalarsInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfScalarsInFile();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetNumberOfTCoordsInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfTCoordsInFile();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetNumberOfTensorsInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfTensorsInFile();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetNumberOfVectorsInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfVectorsInFile();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetReadAllColorScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetReadAllColorScalars();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetReadAllFields(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetReadAllFields();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetReadAllNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetReadAllNormals();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetReadAllScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetReadAllScalars();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetReadAllTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetReadAllTCoords();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetReadAllTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetReadAllTensors();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetReadAllVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetReadAllVectors();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetReadFromInputString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetReadFromInputString();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::GetScalarsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalarsName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetScalarsNameInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetScalarsNameInFile(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::GetTCoordsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTCoordsName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetTCoordsNameInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetTCoordsNameInFile(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::GetTensorsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTensorsName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetTensorsNameInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetTensorsNameInFile(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::GetVectorsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVectorsName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataReaderWrap::GetVectorsNameInFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetVectorsNameInFile(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::IsFilePolyData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->IsFilePolyData();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::IsFileRectilinearGrid(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->IsFileRectilinearGrid();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::IsFileStructuredGrid(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->IsFileStructuredGrid();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::IsFileStructuredPoints(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->IsFileStructuredPoints();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::IsFileUnstructuredGrid(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->IsFileUnstructuredGrid();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::IsFileValid(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsFileValid(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	vtkDataReader * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkDataReaderWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataReaderWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataReaderWrap *w = new VtkDataReaderWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataReaderWrap::OpenVTKFile(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->OpenVTKFile();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::Read(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->Read(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadAllColorScalarsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllColorScalarsOff();
}

void VtkDataReaderWrap::ReadAllColorScalarsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllColorScalarsOn();
}

void VtkDataReaderWrap::ReadAllFieldsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllFieldsOff();
}

void VtkDataReaderWrap::ReadAllFieldsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllFieldsOn();
}

void VtkDataReaderWrap::ReadAllNormalsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllNormalsOff();
}

void VtkDataReaderWrap::ReadAllNormalsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllNormalsOn();
}

void VtkDataReaderWrap::ReadAllScalarsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllScalarsOff();
}

void VtkDataReaderWrap::ReadAllScalarsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllScalarsOn();
}

void VtkDataReaderWrap::ReadAllTCoordsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllTCoordsOff();
}

void VtkDataReaderWrap::ReadAllTCoordsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllTCoordsOn();
}

void VtkDataReaderWrap::ReadAllTensorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllTensorsOff();
}

void VtkDataReaderWrap::ReadAllTensorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllTensorsOn();
}

void VtkDataReaderWrap::ReadAllVectorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllVectorsOff();
}

void VtkDataReaderWrap::ReadAllVectorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadAllVectorsOn();
}

void VtkDataReaderWrap::ReadArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				vtkAbstractArray * r;
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				r = native->ReadArray(
					*a0,
					info[1]->Int32Value(),
					info[2]->Int32Value()
				);
					VtkAbstractArrayWrap::InitPtpl();
				v8::Local<v8::Value> argv[1] =
					{ Nan::New(vtkNodeJsNoWrap) };
				v8::Local<v8::Function> cons =
					Nan::New<v8::FunctionTemplate>(VtkAbstractArrayWrap::ptpl)->GetFunction();
				v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
				VtkAbstractArrayWrap *w = new VtkAbstractArrayWrap();
				w->native = r;
				w->Wrap(wo);
				info.GetReturnValue().Set(wo);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadCellData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataSetWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataSetWrap *a0 = ObjectWrap::Unwrap<VtkDataSetWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->ReadCellData(
				(vtkDataSet *) a0->native.GetPointer(),
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadCoordinates(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkRectilinearGridWrap::ptpl))->HasInstance(info[0]))
	{
		VtkRectilinearGridWrap *a0 = ObjectWrap::Unwrap<VtkRectilinearGridWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				int r;
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				r = native->ReadCoordinates(
					(vtkRectilinearGrid *) a0->native.GetPointer(),
					info[1]->Int32Value(),
					info[2]->Int32Value()
				);
				info.GetReturnValue().Set(Nan::New(r));
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadEdgeData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkGraphWrap::ptpl))->HasInstance(info[0]))
	{
		VtkGraphWrap *a0 = ObjectWrap::Unwrap<VtkGraphWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->ReadEdgeData(
				(vtkGraph *) a0->native.GetPointer(),
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadFromInputStringOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadFromInputStringOff();
}

void VtkDataReaderWrap::ReadFromInputStringOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ReadFromInputStringOn();
}

void VtkDataReaderWrap::ReadHeader(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->ReadHeader();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkDataReaderWrap::ReadLine(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0( v8::Local<v8::Array>::Cast( info[0]->ToObject() ) );
		char b0[256];
		if( a0->Length() < 256 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 256; i++ )
		{
			if( !a0->Get(i)->IsInt32() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->ReadLine(
			b0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadMetaData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkInformationWrap::ptpl))->HasInstance(info[0]))
	{
		VtkInformationWrap *a0 = ObjectWrap::Unwrap<VtkInformationWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->ReadMetaData(
			(vtkInformation *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadPointData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataSetWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataSetWrap *a0 = ObjectWrap::Unwrap<VtkDataSetWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->ReadPointData(
				(vtkDataSet *) a0->native.GetPointer(),
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadPoints(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkGraphWrap::ptpl))->HasInstance(info[0]))
	{
		VtkGraphWrap *a0 = ObjectWrap::Unwrap<VtkGraphWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->ReadPoints(
				(vtkGraph *) a0->native.GetPointer(),
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadRowData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkTableWrap::ptpl))->HasInstance(info[0]))
	{
		VtkTableWrap *a0 = ObjectWrap::Unwrap<VtkTableWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->ReadRowData(
				(vtkTable *) a0->native.GetPointer(),
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0( v8::Local<v8::Array>::Cast( info[0]->ToObject() ) );
		char b0[256];
		if( a0->Length() < 256 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 256; i++ )
		{
			if( !a0->Get(i)->IsInt32() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->ReadString(
			b0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::ReadVertexData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkGraphWrap::ptpl))->HasInstance(info[0]))
	{
		VtkGraphWrap *a0 = ObjectWrap::Unwrap<VtkGraphWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->ReadVertexData(
				(vtkGraph *) a0->native.GetPointer(),
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkDataReader * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkDataReaderWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataReaderWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataReaderWrap *w = new VtkDataReaderWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetBinaryInputString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetBinaryInputString(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetFieldDataName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFieldDataName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetFileName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFileName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetInputArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkCharArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkCharArrayWrap *a0 = ObjectWrap::Unwrap<VtkCharArrayWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInputArray(
			(vtkCharArray *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetInputString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetInputString(
				*a0,
				info[1]->Int32Value()
			);
			return;
		}
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInputString(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetLookupTableName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetLookupTableName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetNormalsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetNormalsName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetReadAllColorScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetReadAllColorScalars(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetReadAllFields(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetReadAllFields(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetReadAllNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetReadAllNormals(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetReadAllScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetReadAllScalars(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetReadAllTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetReadAllTCoords(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetReadAllTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetReadAllTensors(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetReadAllVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetReadAllVectors(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetReadFromInputString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetReadFromInputString(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetScalarsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScalarsName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetTCoordsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTCoordsName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetTensorsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTensorsName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataReaderWrap::SetVectorsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataReaderWrap *wrapper = ObjectWrap::Unwrap<VtkDataReaderWrap>(info.Holder());
	vtkDataReader *native = (vtkDataReader *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetVectorsName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

