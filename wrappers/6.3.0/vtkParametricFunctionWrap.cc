/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkObjectWrap.h"
#include "vtkParametricFunctionWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkParametricFunctionWrap::ptpl;

VtkParametricFunctionWrap::VtkParametricFunctionWrap()
{ }

VtkParametricFunctionWrap::VtkParametricFunctionWrap(vtkSmartPointer<vtkParametricFunction> _native)
{ native = _native; }

VtkParametricFunctionWrap::~VtkParametricFunctionWrap()
{ }

void VtkParametricFunctionWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkParametricFunction").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("ParametricFunction").ToLocalChecked(), ConstructorGetter);
}

void VtkParametricFunctionWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkParametricFunctionWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkObjectWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkObjectWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkParametricFunctionWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "ClockwiseOrderingOff", ClockwiseOrderingOff);
	Nan::SetPrototypeMethod(tpl, "clockwiseOrderingOff", ClockwiseOrderingOff);

	Nan::SetPrototypeMethod(tpl, "ClockwiseOrderingOn", ClockwiseOrderingOn);
	Nan::SetPrototypeMethod(tpl, "clockwiseOrderingOn", ClockwiseOrderingOn);

	Nan::SetPrototypeMethod(tpl, "DerivativesAvailableOff", DerivativesAvailableOff);
	Nan::SetPrototypeMethod(tpl, "derivativesAvailableOff", DerivativesAvailableOff);

	Nan::SetPrototypeMethod(tpl, "DerivativesAvailableOn", DerivativesAvailableOn);
	Nan::SetPrototypeMethod(tpl, "derivativesAvailableOn", DerivativesAvailableOn);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetClockwiseOrdering", GetClockwiseOrdering);
	Nan::SetPrototypeMethod(tpl, "getClockwiseOrdering", GetClockwiseOrdering);

	Nan::SetPrototypeMethod(tpl, "GetClockwiseOrderingMaxValue", GetClockwiseOrderingMaxValue);
	Nan::SetPrototypeMethod(tpl, "getClockwiseOrderingMaxValue", GetClockwiseOrderingMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetClockwiseOrderingMinValue", GetClockwiseOrderingMinValue);
	Nan::SetPrototypeMethod(tpl, "getClockwiseOrderingMinValue", GetClockwiseOrderingMinValue);

	Nan::SetPrototypeMethod(tpl, "GetDerivativesAvailable", GetDerivativesAvailable);
	Nan::SetPrototypeMethod(tpl, "getDerivativesAvailable", GetDerivativesAvailable);

	Nan::SetPrototypeMethod(tpl, "GetDerivativesAvailableMaxValue", GetDerivativesAvailableMaxValue);
	Nan::SetPrototypeMethod(tpl, "getDerivativesAvailableMaxValue", GetDerivativesAvailableMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetDerivativesAvailableMinValue", GetDerivativesAvailableMinValue);
	Nan::SetPrototypeMethod(tpl, "getDerivativesAvailableMinValue", GetDerivativesAvailableMinValue);

	Nan::SetPrototypeMethod(tpl, "GetDimension", GetDimension);
	Nan::SetPrototypeMethod(tpl, "getDimension", GetDimension);

	Nan::SetPrototypeMethod(tpl, "GetJoinU", GetJoinU);
	Nan::SetPrototypeMethod(tpl, "getJoinU", GetJoinU);

	Nan::SetPrototypeMethod(tpl, "GetJoinUMaxValue", GetJoinUMaxValue);
	Nan::SetPrototypeMethod(tpl, "getJoinUMaxValue", GetJoinUMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetJoinUMinValue", GetJoinUMinValue);
	Nan::SetPrototypeMethod(tpl, "getJoinUMinValue", GetJoinUMinValue);

	Nan::SetPrototypeMethod(tpl, "GetJoinV", GetJoinV);
	Nan::SetPrototypeMethod(tpl, "getJoinV", GetJoinV);

	Nan::SetPrototypeMethod(tpl, "GetJoinVMaxValue", GetJoinVMaxValue);
	Nan::SetPrototypeMethod(tpl, "getJoinVMaxValue", GetJoinVMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetJoinVMinValue", GetJoinVMinValue);
	Nan::SetPrototypeMethod(tpl, "getJoinVMinValue", GetJoinVMinValue);

	Nan::SetPrototypeMethod(tpl, "GetJoinW", GetJoinW);
	Nan::SetPrototypeMethod(tpl, "getJoinW", GetJoinW);

	Nan::SetPrototypeMethod(tpl, "GetJoinWMaxValue", GetJoinWMaxValue);
	Nan::SetPrototypeMethod(tpl, "getJoinWMaxValue", GetJoinWMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetJoinWMinValue", GetJoinWMinValue);
	Nan::SetPrototypeMethod(tpl, "getJoinWMinValue", GetJoinWMinValue);

	Nan::SetPrototypeMethod(tpl, "GetMaximumU", GetMaximumU);
	Nan::SetPrototypeMethod(tpl, "getMaximumU", GetMaximumU);

	Nan::SetPrototypeMethod(tpl, "GetMaximumV", GetMaximumV);
	Nan::SetPrototypeMethod(tpl, "getMaximumV", GetMaximumV);

	Nan::SetPrototypeMethod(tpl, "GetMaximumW", GetMaximumW);
	Nan::SetPrototypeMethod(tpl, "getMaximumW", GetMaximumW);

	Nan::SetPrototypeMethod(tpl, "GetMinimumU", GetMinimumU);
	Nan::SetPrototypeMethod(tpl, "getMinimumU", GetMinimumU);

	Nan::SetPrototypeMethod(tpl, "GetMinimumV", GetMinimumV);
	Nan::SetPrototypeMethod(tpl, "getMinimumV", GetMinimumV);

	Nan::SetPrototypeMethod(tpl, "GetMinimumW", GetMinimumW);
	Nan::SetPrototypeMethod(tpl, "getMinimumW", GetMinimumW);

	Nan::SetPrototypeMethod(tpl, "GetTwistU", GetTwistU);
	Nan::SetPrototypeMethod(tpl, "getTwistU", GetTwistU);

	Nan::SetPrototypeMethod(tpl, "GetTwistUMaxValue", GetTwistUMaxValue);
	Nan::SetPrototypeMethod(tpl, "getTwistUMaxValue", GetTwistUMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetTwistUMinValue", GetTwistUMinValue);
	Nan::SetPrototypeMethod(tpl, "getTwistUMinValue", GetTwistUMinValue);

	Nan::SetPrototypeMethod(tpl, "GetTwistV", GetTwistV);
	Nan::SetPrototypeMethod(tpl, "getTwistV", GetTwistV);

	Nan::SetPrototypeMethod(tpl, "GetTwistVMaxValue", GetTwistVMaxValue);
	Nan::SetPrototypeMethod(tpl, "getTwistVMaxValue", GetTwistVMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetTwistVMinValue", GetTwistVMinValue);
	Nan::SetPrototypeMethod(tpl, "getTwistVMinValue", GetTwistVMinValue);

	Nan::SetPrototypeMethod(tpl, "GetTwistW", GetTwistW);
	Nan::SetPrototypeMethod(tpl, "getTwistW", GetTwistW);

	Nan::SetPrototypeMethod(tpl, "GetTwistWMaxValue", GetTwistWMaxValue);
	Nan::SetPrototypeMethod(tpl, "getTwistWMaxValue", GetTwistWMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetTwistWMinValue", GetTwistWMinValue);
	Nan::SetPrototypeMethod(tpl, "getTwistWMinValue", GetTwistWMinValue);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "JoinUOff", JoinUOff);
	Nan::SetPrototypeMethod(tpl, "joinUOff", JoinUOff);

	Nan::SetPrototypeMethod(tpl, "JoinUOn", JoinUOn);
	Nan::SetPrototypeMethod(tpl, "joinUOn", JoinUOn);

	Nan::SetPrototypeMethod(tpl, "JoinVOff", JoinVOff);
	Nan::SetPrototypeMethod(tpl, "joinVOff", JoinVOff);

	Nan::SetPrototypeMethod(tpl, "JoinVOn", JoinVOn);
	Nan::SetPrototypeMethod(tpl, "joinVOn", JoinVOn);

	Nan::SetPrototypeMethod(tpl, "JoinWOff", JoinWOff);
	Nan::SetPrototypeMethod(tpl, "joinWOff", JoinWOff);

	Nan::SetPrototypeMethod(tpl, "JoinWOn", JoinWOn);
	Nan::SetPrototypeMethod(tpl, "joinWOn", JoinWOn);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetClockwiseOrdering", SetClockwiseOrdering);
	Nan::SetPrototypeMethod(tpl, "setClockwiseOrdering", SetClockwiseOrdering);

	Nan::SetPrototypeMethod(tpl, "SetDerivativesAvailable", SetDerivativesAvailable);
	Nan::SetPrototypeMethod(tpl, "setDerivativesAvailable", SetDerivativesAvailable);

	Nan::SetPrototypeMethod(tpl, "SetJoinU", SetJoinU);
	Nan::SetPrototypeMethod(tpl, "setJoinU", SetJoinU);

	Nan::SetPrototypeMethod(tpl, "SetJoinV", SetJoinV);
	Nan::SetPrototypeMethod(tpl, "setJoinV", SetJoinV);

	Nan::SetPrototypeMethod(tpl, "SetJoinW", SetJoinW);
	Nan::SetPrototypeMethod(tpl, "setJoinW", SetJoinW);

	Nan::SetPrototypeMethod(tpl, "SetMaximumU", SetMaximumU);
	Nan::SetPrototypeMethod(tpl, "setMaximumU", SetMaximumU);

	Nan::SetPrototypeMethod(tpl, "SetMaximumV", SetMaximumV);
	Nan::SetPrototypeMethod(tpl, "setMaximumV", SetMaximumV);

	Nan::SetPrototypeMethod(tpl, "SetMaximumW", SetMaximumW);
	Nan::SetPrototypeMethod(tpl, "setMaximumW", SetMaximumW);

	Nan::SetPrototypeMethod(tpl, "SetMinimumU", SetMinimumU);
	Nan::SetPrototypeMethod(tpl, "setMinimumU", SetMinimumU);

	Nan::SetPrototypeMethod(tpl, "SetMinimumV", SetMinimumV);
	Nan::SetPrototypeMethod(tpl, "setMinimumV", SetMinimumV);

	Nan::SetPrototypeMethod(tpl, "SetMinimumW", SetMinimumW);
	Nan::SetPrototypeMethod(tpl, "setMinimumW", SetMinimumW);

	Nan::SetPrototypeMethod(tpl, "SetTwistU", SetTwistU);
	Nan::SetPrototypeMethod(tpl, "setTwistU", SetTwistU);

	Nan::SetPrototypeMethod(tpl, "SetTwistV", SetTwistV);
	Nan::SetPrototypeMethod(tpl, "setTwistV", SetTwistV);

	Nan::SetPrototypeMethod(tpl, "SetTwistW", SetTwistW);
	Nan::SetPrototypeMethod(tpl, "setTwistW", SetTwistW);

	Nan::SetPrototypeMethod(tpl, "TwistUOff", TwistUOff);
	Nan::SetPrototypeMethod(tpl, "twistUOff", TwistUOff);

	Nan::SetPrototypeMethod(tpl, "TwistUOn", TwistUOn);
	Nan::SetPrototypeMethod(tpl, "twistUOn", TwistUOn);

	Nan::SetPrototypeMethod(tpl, "TwistVOff", TwistVOff);
	Nan::SetPrototypeMethod(tpl, "twistVOff", TwistVOff);

	Nan::SetPrototypeMethod(tpl, "TwistVOn", TwistVOn);
	Nan::SetPrototypeMethod(tpl, "twistVOn", TwistVOn);

	Nan::SetPrototypeMethod(tpl, "TwistWOff", TwistWOff);
	Nan::SetPrototypeMethod(tpl, "twistWOff", TwistWOff);

	Nan::SetPrototypeMethod(tpl, "TwistWOn", TwistWOn);
	Nan::SetPrototypeMethod(tpl, "twistWOn", TwistWOn);

	ptpl.Reset( tpl );
}

void VtkParametricFunctionWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		Nan::ThrowError("Cannot create instance of abstract class.");
		return;
	}
	else
	{
		Nan::Utf8String s(info[0]);
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkParametricFunctionWrap::ClockwiseOrderingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClockwiseOrderingOff();
}

void VtkParametricFunctionWrap::ClockwiseOrderingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClockwiseOrderingOn();
}

void VtkParametricFunctionWrap::DerivativesAvailableOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DerivativesAvailableOff();
}

void VtkParametricFunctionWrap::DerivativesAvailableOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DerivativesAvailableOn();
}

void VtkParametricFunctionWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkParametricFunctionWrap::GetClockwiseOrdering(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClockwiseOrdering();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetClockwiseOrderingMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClockwiseOrderingMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetClockwiseOrderingMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClockwiseOrderingMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetDerivativesAvailable(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDerivativesAvailable();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetDerivativesAvailableMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDerivativesAvailableMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetDerivativesAvailableMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDerivativesAvailableMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetDimension(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDimension();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinU(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinU();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinUMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinUMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinUMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinUMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinV(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinV();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinVMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinVMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinVMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinVMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinW(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinW();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinWMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinWMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetJoinWMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetJoinWMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetMaximumU(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMaximumU();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetMaximumV(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMaximumV();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetMaximumW(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMaximumW();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetMinimumU(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMinimumU();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetMinimumV(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMinimumV();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetMinimumW(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMinimumW();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistU(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistU();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistUMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistUMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistUMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistUMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistV(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistV();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistVMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistVMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistVMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistVMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistW(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistW();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistWMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistWMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::GetTwistWMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTwistWMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkParametricFunctionWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::JoinUOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->JoinUOff();
}

void VtkParametricFunctionWrap::JoinUOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->JoinUOn();
}

void VtkParametricFunctionWrap::JoinVOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->JoinVOff();
}

void VtkParametricFunctionWrap::JoinVOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->JoinVOn();
}

void VtkParametricFunctionWrap::JoinWOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->JoinWOff();
}

void VtkParametricFunctionWrap::JoinWOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->JoinWOn();
}

void VtkParametricFunctionWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	vtkParametricFunction * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkParametricFunctionWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkParametricFunctionWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkParametricFunctionWrap *w = new VtkParametricFunctionWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkParametricFunctionWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkParametricFunction * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkParametricFunctionWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkParametricFunctionWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkParametricFunctionWrap *w = new VtkParametricFunctionWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetClockwiseOrdering(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetClockwiseOrdering(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetDerivativesAvailable(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDerivativesAvailable(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetJoinU(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetJoinU(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetJoinV(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetJoinV(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetJoinW(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetJoinW(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetMaximumU(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMaximumU(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetMaximumV(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMaximumV(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetMaximumW(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMaximumW(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetMinimumU(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMinimumU(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetMinimumV(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMinimumV(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetMinimumW(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMinimumW(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetTwistU(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTwistU(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetTwistV(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTwistV(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::SetTwistW(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTwistW(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkParametricFunctionWrap::TwistUOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TwistUOff();
}

void VtkParametricFunctionWrap::TwistUOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TwistUOn();
}

void VtkParametricFunctionWrap::TwistVOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TwistVOff();
}

void VtkParametricFunctionWrap::TwistVOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TwistVOn();
}

void VtkParametricFunctionWrap::TwistWOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TwistWOff();
}

void VtkParametricFunctionWrap::TwistWOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkParametricFunctionWrap *wrapper = ObjectWrap::Unwrap<VtkParametricFunctionWrap>(info.Holder());
	vtkParametricFunction *native = (vtkParametricFunction *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->TwistWOn();
}

