/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkFieldDataWrap.h"
#include "vtkDataSetAttributesWrap.h"
#include "vtkObjectWrap.h"
#include "vtkDataArrayWrap.h"
#include "vtkAbstractArrayWrap.h"
#include "vtkIdListWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkDataSetAttributesWrap::ptpl;

VtkDataSetAttributesWrap::VtkDataSetAttributesWrap()
{ }

VtkDataSetAttributesWrap::VtkDataSetAttributesWrap(vtkSmartPointer<vtkDataSetAttributes> _native)
{ native = _native; }

VtkDataSetAttributesWrap::~VtkDataSetAttributesWrap()
{ }

void VtkDataSetAttributesWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkDataSetAttributes").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("DataSetAttributes").ToLocalChecked(), ConstructorGetter);
}

void VtkDataSetAttributesWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkDataSetAttributesWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkFieldDataWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkFieldDataWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkDataSetAttributesWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "CopyAllOff", CopyAllOff);
	Nan::SetPrototypeMethod(tpl, "copyAllOff", CopyAllOff);

	Nan::SetPrototypeMethod(tpl, "CopyAllOn", CopyAllOn);
	Nan::SetPrototypeMethod(tpl, "copyAllOn", CopyAllOn);

	Nan::SetPrototypeMethod(tpl, "CopyData", CopyData);
	Nan::SetPrototypeMethod(tpl, "copyData", CopyData);

	Nan::SetPrototypeMethod(tpl, "CopyGlobalIdsOff", CopyGlobalIdsOff);
	Nan::SetPrototypeMethod(tpl, "copyGlobalIdsOff", CopyGlobalIdsOff);

	Nan::SetPrototypeMethod(tpl, "CopyGlobalIdsOn", CopyGlobalIdsOn);
	Nan::SetPrototypeMethod(tpl, "copyGlobalIdsOn", CopyGlobalIdsOn);

	Nan::SetPrototypeMethod(tpl, "CopyNormalsOff", CopyNormalsOff);
	Nan::SetPrototypeMethod(tpl, "copyNormalsOff", CopyNormalsOff);

	Nan::SetPrototypeMethod(tpl, "CopyNormalsOn", CopyNormalsOn);
	Nan::SetPrototypeMethod(tpl, "copyNormalsOn", CopyNormalsOn);

	Nan::SetPrototypeMethod(tpl, "CopyPedigreeIdsOff", CopyPedigreeIdsOff);
	Nan::SetPrototypeMethod(tpl, "copyPedigreeIdsOff", CopyPedigreeIdsOff);

	Nan::SetPrototypeMethod(tpl, "CopyPedigreeIdsOn", CopyPedigreeIdsOn);
	Nan::SetPrototypeMethod(tpl, "copyPedigreeIdsOn", CopyPedigreeIdsOn);

	Nan::SetPrototypeMethod(tpl, "CopyScalarsOff", CopyScalarsOff);
	Nan::SetPrototypeMethod(tpl, "copyScalarsOff", CopyScalarsOff);

	Nan::SetPrototypeMethod(tpl, "CopyScalarsOn", CopyScalarsOn);
	Nan::SetPrototypeMethod(tpl, "copyScalarsOn", CopyScalarsOn);

	Nan::SetPrototypeMethod(tpl, "CopyTCoordsOff", CopyTCoordsOff);
	Nan::SetPrototypeMethod(tpl, "copyTCoordsOff", CopyTCoordsOff);

	Nan::SetPrototypeMethod(tpl, "CopyTCoordsOn", CopyTCoordsOn);
	Nan::SetPrototypeMethod(tpl, "copyTCoordsOn", CopyTCoordsOn);

	Nan::SetPrototypeMethod(tpl, "CopyTensorsOff", CopyTensorsOff);
	Nan::SetPrototypeMethod(tpl, "copyTensorsOff", CopyTensorsOff);

	Nan::SetPrototypeMethod(tpl, "CopyTensorsOn", CopyTensorsOn);
	Nan::SetPrototypeMethod(tpl, "copyTensorsOn", CopyTensorsOn);

	Nan::SetPrototypeMethod(tpl, "CopyTuples", CopyTuples);
	Nan::SetPrototypeMethod(tpl, "copyTuples", CopyTuples);

	Nan::SetPrototypeMethod(tpl, "CopyVectorsOff", CopyVectorsOff);
	Nan::SetPrototypeMethod(tpl, "copyVectorsOff", CopyVectorsOff);

	Nan::SetPrototypeMethod(tpl, "CopyVectorsOn", CopyVectorsOn);
	Nan::SetPrototypeMethod(tpl, "copyVectorsOn", CopyVectorsOn);

	Nan::SetPrototypeMethod(tpl, "DeepCopy", DeepCopy);
	Nan::SetPrototypeMethod(tpl, "deepCopy", DeepCopy);

	Nan::SetPrototypeMethod(tpl, "GetAbstractAttribute", GetAbstractAttribute);
	Nan::SetPrototypeMethod(tpl, "getAbstractAttribute", GetAbstractAttribute);

	Nan::SetPrototypeMethod(tpl, "GetAttribute", GetAttribute);
	Nan::SetPrototypeMethod(tpl, "getAttribute", GetAttribute);

	Nan::SetPrototypeMethod(tpl, "GetAttributeTypeAsString", GetAttributeTypeAsString);
	Nan::SetPrototypeMethod(tpl, "getAttributeTypeAsString", GetAttributeTypeAsString);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetCopyGlobalIds", GetCopyGlobalIds);
	Nan::SetPrototypeMethod(tpl, "getCopyGlobalIds", GetCopyGlobalIds);

	Nan::SetPrototypeMethod(tpl, "GetCopyNormals", GetCopyNormals);
	Nan::SetPrototypeMethod(tpl, "getCopyNormals", GetCopyNormals);

	Nan::SetPrototypeMethod(tpl, "GetCopyPedigreeIds", GetCopyPedigreeIds);
	Nan::SetPrototypeMethod(tpl, "getCopyPedigreeIds", GetCopyPedigreeIds);

	Nan::SetPrototypeMethod(tpl, "GetCopyScalars", GetCopyScalars);
	Nan::SetPrototypeMethod(tpl, "getCopyScalars", GetCopyScalars);

	Nan::SetPrototypeMethod(tpl, "GetCopyTCoords", GetCopyTCoords);
	Nan::SetPrototypeMethod(tpl, "getCopyTCoords", GetCopyTCoords);

	Nan::SetPrototypeMethod(tpl, "GetCopyTensors", GetCopyTensors);
	Nan::SetPrototypeMethod(tpl, "getCopyTensors", GetCopyTensors);

	Nan::SetPrototypeMethod(tpl, "GetCopyVectors", GetCopyVectors);
	Nan::SetPrototypeMethod(tpl, "getCopyVectors", GetCopyVectors);

	Nan::SetPrototypeMethod(tpl, "GetGlobalIds", GetGlobalIds);
	Nan::SetPrototypeMethod(tpl, "getGlobalIds", GetGlobalIds);

	Nan::SetPrototypeMethod(tpl, "GetLongAttributeTypeAsString", GetLongAttributeTypeAsString);
	Nan::SetPrototypeMethod(tpl, "getLongAttributeTypeAsString", GetLongAttributeTypeAsString);

	Nan::SetPrototypeMethod(tpl, "GetNormals", GetNormals);
	Nan::SetPrototypeMethod(tpl, "getNormals", GetNormals);

	Nan::SetPrototypeMethod(tpl, "GetPedigreeIds", GetPedigreeIds);
	Nan::SetPrototypeMethod(tpl, "getPedigreeIds", GetPedigreeIds);

	Nan::SetPrototypeMethod(tpl, "GetScalars", GetScalars);
	Nan::SetPrototypeMethod(tpl, "getScalars", GetScalars);

	Nan::SetPrototypeMethod(tpl, "GetTCoords", GetTCoords);
	Nan::SetPrototypeMethod(tpl, "getTCoords", GetTCoords);

	Nan::SetPrototypeMethod(tpl, "GetTensors", GetTensors);
	Nan::SetPrototypeMethod(tpl, "getTensors", GetTensors);

	Nan::SetPrototypeMethod(tpl, "GetVectors", GetVectors);
	Nan::SetPrototypeMethod(tpl, "getVectors", GetVectors);

	Nan::SetPrototypeMethod(tpl, "GhostArrayName", GhostArrayName);
	Nan::SetPrototypeMethod(tpl, "ghostArrayName", GhostArrayName);

	Nan::SetPrototypeMethod(tpl, "Initialize", Initialize);
	Nan::SetPrototypeMethod(tpl, "initialize", Initialize);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "IsArrayAnAttribute", IsArrayAnAttribute);
	Nan::SetPrototypeMethod(tpl, "isArrayAnAttribute", IsArrayAnAttribute);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "PassData", PassData);
	Nan::SetPrototypeMethod(tpl, "passData", PassData);

	Nan::SetPrototypeMethod(tpl, "RemoveArray", RemoveArray);
	Nan::SetPrototypeMethod(tpl, "removeArray", RemoveArray);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetActiveAttribute", SetActiveAttribute);
	Nan::SetPrototypeMethod(tpl, "setActiveAttribute", SetActiveAttribute);

	Nan::SetPrototypeMethod(tpl, "SetActiveGlobalIds", SetActiveGlobalIds);
	Nan::SetPrototypeMethod(tpl, "setActiveGlobalIds", SetActiveGlobalIds);

	Nan::SetPrototypeMethod(tpl, "SetActiveNormals", SetActiveNormals);
	Nan::SetPrototypeMethod(tpl, "setActiveNormals", SetActiveNormals);

	Nan::SetPrototypeMethod(tpl, "SetActivePedigreeIds", SetActivePedigreeIds);
	Nan::SetPrototypeMethod(tpl, "setActivePedigreeIds", SetActivePedigreeIds);

	Nan::SetPrototypeMethod(tpl, "SetActiveScalars", SetActiveScalars);
	Nan::SetPrototypeMethod(tpl, "setActiveScalars", SetActiveScalars);

	Nan::SetPrototypeMethod(tpl, "SetActiveTCoords", SetActiveTCoords);
	Nan::SetPrototypeMethod(tpl, "setActiveTCoords", SetActiveTCoords);

	Nan::SetPrototypeMethod(tpl, "SetActiveTensors", SetActiveTensors);
	Nan::SetPrototypeMethod(tpl, "setActiveTensors", SetActiveTensors);

	Nan::SetPrototypeMethod(tpl, "SetActiveVectors", SetActiveVectors);
	Nan::SetPrototypeMethod(tpl, "setActiveVectors", SetActiveVectors);

	Nan::SetPrototypeMethod(tpl, "SetAttribute", SetAttribute);
	Nan::SetPrototypeMethod(tpl, "setAttribute", SetAttribute);

	Nan::SetPrototypeMethod(tpl, "SetCopyAttribute", SetCopyAttribute);
	Nan::SetPrototypeMethod(tpl, "setCopyAttribute", SetCopyAttribute);

	Nan::SetPrototypeMethod(tpl, "SetCopyGlobalIds", SetCopyGlobalIds);
	Nan::SetPrototypeMethod(tpl, "setCopyGlobalIds", SetCopyGlobalIds);

	Nan::SetPrototypeMethod(tpl, "SetCopyNormals", SetCopyNormals);
	Nan::SetPrototypeMethod(tpl, "setCopyNormals", SetCopyNormals);

	Nan::SetPrototypeMethod(tpl, "SetCopyPedigreeIds", SetCopyPedigreeIds);
	Nan::SetPrototypeMethod(tpl, "setCopyPedigreeIds", SetCopyPedigreeIds);

	Nan::SetPrototypeMethod(tpl, "SetCopyScalars", SetCopyScalars);
	Nan::SetPrototypeMethod(tpl, "setCopyScalars", SetCopyScalars);

	Nan::SetPrototypeMethod(tpl, "SetCopyTCoords", SetCopyTCoords);
	Nan::SetPrototypeMethod(tpl, "setCopyTCoords", SetCopyTCoords);

	Nan::SetPrototypeMethod(tpl, "SetCopyTensors", SetCopyTensors);
	Nan::SetPrototypeMethod(tpl, "setCopyTensors", SetCopyTensors);

	Nan::SetPrototypeMethod(tpl, "SetCopyVectors", SetCopyVectors);
	Nan::SetPrototypeMethod(tpl, "setCopyVectors", SetCopyVectors);

	Nan::SetPrototypeMethod(tpl, "SetGlobalIds", SetGlobalIds);
	Nan::SetPrototypeMethod(tpl, "setGlobalIds", SetGlobalIds);

	Nan::SetPrototypeMethod(tpl, "SetNormals", SetNormals);
	Nan::SetPrototypeMethod(tpl, "setNormals", SetNormals);

	Nan::SetPrototypeMethod(tpl, "SetPedigreeIds", SetPedigreeIds);
	Nan::SetPrototypeMethod(tpl, "setPedigreeIds", SetPedigreeIds);

	Nan::SetPrototypeMethod(tpl, "SetScalars", SetScalars);
	Nan::SetPrototypeMethod(tpl, "setScalars", SetScalars);

	Nan::SetPrototypeMethod(tpl, "SetTCoords", SetTCoords);
	Nan::SetPrototypeMethod(tpl, "setTCoords", SetTCoords);

	Nan::SetPrototypeMethod(tpl, "SetTensors", SetTensors);
	Nan::SetPrototypeMethod(tpl, "setTensors", SetTensors);

	Nan::SetPrototypeMethod(tpl, "SetVectors", SetVectors);
	Nan::SetPrototypeMethod(tpl, "setVectors", SetVectors);

	Nan::SetPrototypeMethod(tpl, "ShallowCopy", ShallowCopy);
	Nan::SetPrototypeMethod(tpl, "shallowCopy", ShallowCopy);

	Nan::SetPrototypeMethod(tpl, "Update", Update);
	Nan::SetPrototypeMethod(tpl, "update", Update);

	ptpl.Reset( tpl );
}

void VtkDataSetAttributesWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkDataSetAttributes> native = vtkSmartPointer<vtkDataSetAttributes>::New();
		VtkDataSetAttributesWrap* obj = new VtkDataSetAttributesWrap(native);		obj->Wrap(info.This());
	}
	else
	{
		Nan::Utf8String s(info[0]);
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkDataSetAttributesWrap::CopyAllOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->CopyAllOff(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::CopyAllOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->CopyAllOn(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::CopyData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataSetAttributesWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataSetAttributesWrap *a0 = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkIdListWrap::ptpl))->HasInstance(info[1]))
		{
			VtkIdListWrap *a1 = ObjectWrap::Unwrap<VtkIdListWrap>(info[1]->ToObject());
			if(info.Length() > 2 && info[2]->IsObject() && (Nan::New(VtkIdListWrap::ptpl))->HasInstance(info[2]))
			{
				VtkIdListWrap *a2 = ObjectWrap::Unwrap<VtkIdListWrap>(info[2]->ToObject());
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->CopyData(
					(vtkDataSetAttributes *) a0->native.GetPointer(),
					(vtkIdList *) a1->native.GetPointer(),
					(vtkIdList *) a2->native.GetPointer()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::CopyGlobalIdsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyGlobalIdsOff();
}

void VtkDataSetAttributesWrap::CopyGlobalIdsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyGlobalIdsOn();
}

void VtkDataSetAttributesWrap::CopyNormalsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyNormalsOff();
}

void VtkDataSetAttributesWrap::CopyNormalsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyNormalsOn();
}

void VtkDataSetAttributesWrap::CopyPedigreeIdsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyPedigreeIdsOff();
}

void VtkDataSetAttributesWrap::CopyPedigreeIdsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyPedigreeIdsOn();
}

void VtkDataSetAttributesWrap::CopyScalarsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyScalarsOff();
}

void VtkDataSetAttributesWrap::CopyScalarsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyScalarsOn();
}

void VtkDataSetAttributesWrap::CopyTCoordsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyTCoordsOff();
}

void VtkDataSetAttributesWrap::CopyTCoordsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyTCoordsOn();
}

void VtkDataSetAttributesWrap::CopyTensorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyTensorsOff();
}

void VtkDataSetAttributesWrap::CopyTensorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyTensorsOn();
}

void VtkDataSetAttributesWrap::CopyTuples(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAbstractArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAbstractArrayWrap *a0 = ObjectWrap::Unwrap<VtkAbstractArrayWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkAbstractArrayWrap::ptpl))->HasInstance(info[1]))
		{
			VtkAbstractArrayWrap *a1 = ObjectWrap::Unwrap<VtkAbstractArrayWrap>(info[1]->ToObject());
			if(info.Length() > 2 && info[2]->IsObject() && (Nan::New(VtkIdListWrap::ptpl))->HasInstance(info[2]))
			{
				VtkIdListWrap *a2 = ObjectWrap::Unwrap<VtkIdListWrap>(info[2]->ToObject());
				if(info.Length() > 3 && info[3]->IsObject() && (Nan::New(VtkIdListWrap::ptpl))->HasInstance(info[3]))
				{
					VtkIdListWrap *a3 = ObjectWrap::Unwrap<VtkIdListWrap>(info[3]->ToObject());
					if(info.Length() != 4)
					{
						Nan::ThrowError("Too many parameters.");
						return;
					}
					native->CopyTuples(
						(vtkAbstractArray *) a0->native.GetPointer(),
						(vtkAbstractArray *) a1->native.GetPointer(),
						(vtkIdList *) a2->native.GetPointer(),
						(vtkIdList *) a3->native.GetPointer()
					);
					return;
				}
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::CopyVectorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyVectorsOff();
}

void VtkDataSetAttributesWrap::CopyVectorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CopyVectorsOn();
}

void VtkDataSetAttributesWrap::DeepCopy(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkFieldDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkFieldDataWrap *a0 = ObjectWrap::Unwrap<VtkFieldDataWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->DeepCopy(
			(vtkFieldData *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetAbstractAttribute(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkAbstractArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetAbstractAttribute(
			info[0]->Int32Value()
		);
			VtkAbstractArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkAbstractArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkAbstractArrayWrap *w = new VtkAbstractArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetAttribute(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkDataArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetAttribute(
			info[0]->Int32Value()
		);
			VtkDataArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataArrayWrap *w = new VtkDataArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetAttributeTypeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetAttributeTypeAsString(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataSetAttributesWrap::GetCopyGlobalIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetCopyGlobalIds(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetCopyNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetCopyNormals(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetCopyPedigreeIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetCopyPedigreeIds(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetCopyScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetCopyScalars(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetCopyTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetCopyTCoords(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetCopyTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetCopyTensors(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetCopyVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetCopyVectors(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetGlobalIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		vtkDataArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetGlobalIds(
			*a0
		);
			VtkDataArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataArrayWrap *w = new VtkDataArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkDataArray * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGlobalIds();
		VtkDataArrayWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataArrayWrap *w = new VtkDataArrayWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataSetAttributesWrap::GetLongAttributeTypeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		char const * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetLongAttributeTypeAsString(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::GetNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		vtkDataArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetNormals(
			*a0
		);
			VtkDataArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataArrayWrap *w = new VtkDataArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkDataArray * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNormals();
		VtkDataArrayWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataArrayWrap *w = new VtkDataArrayWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataSetAttributesWrap::GetPedigreeIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		vtkAbstractArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetPedigreeIds(
			*a0
		);
			VtkAbstractArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkAbstractArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkAbstractArrayWrap *w = new VtkAbstractArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkAbstractArray * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPedigreeIds();
		VtkAbstractArrayWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkAbstractArrayWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkAbstractArrayWrap *w = new VtkAbstractArrayWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataSetAttributesWrap::GetScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		vtkDataArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetScalars(
			*a0
		);
			VtkDataArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataArrayWrap *w = new VtkDataArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkDataArray * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScalars();
		VtkDataArrayWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataArrayWrap *w = new VtkDataArrayWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataSetAttributesWrap::GetTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		vtkDataArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetTCoords(
			*a0
		);
			VtkDataArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataArrayWrap *w = new VtkDataArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkDataArray * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTCoords();
		VtkDataArrayWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataArrayWrap *w = new VtkDataArrayWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataSetAttributesWrap::GetTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		vtkDataArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetTensors(
			*a0
		);
			VtkDataArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataArrayWrap *w = new VtkDataArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkDataArray * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTensors();
		VtkDataArrayWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataArrayWrap *w = new VtkDataArrayWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataSetAttributesWrap::GetVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		vtkDataArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetVectors(
			*a0
		);
			VtkDataArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataArrayWrap *w = new VtkDataArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	vtkDataArray * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVectors();
		VtkDataArrayWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataArrayWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataArrayWrap *w = new VtkDataArrayWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataSetAttributesWrap::GhostArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GhostArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkDataSetAttributesWrap::Initialize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->Initialize();
}

void VtkDataSetAttributesWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::IsArrayAnAttribute(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsArrayAnAttribute(
			info[0]->Int32Value()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	vtkDataSetAttributes * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkDataSetAttributesWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataSetAttributesWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataSetAttributesWrap *w = new VtkDataSetAttributesWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkDataSetAttributesWrap::PassData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkFieldDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkFieldDataWrap *a0 = ObjectWrap::Unwrap<VtkFieldDataWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->PassData(
			(vtkFieldData *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::RemoveArray(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->RemoveArray(
			*a0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->RemoveArray(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkDataSetAttributes * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkDataSetAttributesWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkDataSetAttributesWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkDataSetAttributesWrap *w = new VtkDataSetAttributesWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetActiveAttribute(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->SetActiveAttribute(
				*a0,
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->SetActiveAttribute(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetActiveGlobalIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetActiveGlobalIds(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetActiveNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetActiveNormals(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetActivePedigreeIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetActivePedigreeIds(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetActiveScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetActiveScalars(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetActiveTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetActiveTCoords(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetActiveTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetActiveTensors(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetActiveVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetActiveVectors(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetAttribute(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAbstractArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAbstractArrayWrap *a0 = ObjectWrap::Unwrap<VtkAbstractArrayWrap>(info[0]->ToObject());
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->SetAttribute(
				(vtkAbstractArray *) a0->native.GetPointer(),
				info[1]->Int32Value()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetCopyAttribute(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() > 2 && info[2]->IsInt32())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetCopyAttribute(
					info[0]->Int32Value(),
					info[1]->Int32Value(),
					info[2]->Int32Value()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetCopyGlobalIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCopyGlobalIds(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetCopyNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCopyNormals(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetCopyPedigreeIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCopyPedigreeIds(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetCopyScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCopyScalars(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetCopyTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCopyTCoords(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetCopyTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCopyTensors(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetCopyVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsInt32())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetCopyVectors(
				info[0]->Int32Value(),
				info[1]->Int32Value()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetGlobalIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataArrayWrap *a0 = ObjectWrap::Unwrap<VtkDataArrayWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetGlobalIds(
			(vtkDataArray *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetNormals(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataArrayWrap *a0 = ObjectWrap::Unwrap<VtkDataArrayWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetNormals(
			(vtkDataArray *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetPedigreeIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAbstractArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAbstractArrayWrap *a0 = ObjectWrap::Unwrap<VtkAbstractArrayWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetPedigreeIds(
			(vtkAbstractArray *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataArrayWrap *a0 = ObjectWrap::Unwrap<VtkDataArrayWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetScalars(
			(vtkDataArray *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetTCoords(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataArrayWrap *a0 = ObjectWrap::Unwrap<VtkDataArrayWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetTCoords(
			(vtkDataArray *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetTensors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataArrayWrap *a0 = ObjectWrap::Unwrap<VtkDataArrayWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetTensors(
			(vtkDataArray *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::SetVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataArrayWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataArrayWrap *a0 = ObjectWrap::Unwrap<VtkDataArrayWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SetVectors(
			(vtkDataArray *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::ShallowCopy(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkFieldDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkFieldDataWrap *a0 = ObjectWrap::Unwrap<VtkFieldDataWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->ShallowCopy(
			(vtkFieldData *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkDataSetAttributesWrap::Update(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkDataSetAttributesWrap *wrapper = ObjectWrap::Unwrap<VtkDataSetAttributesWrap>(info.Holder());
	vtkDataSetAttributes *native = (vtkDataSetAttributes *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->Update();
}

