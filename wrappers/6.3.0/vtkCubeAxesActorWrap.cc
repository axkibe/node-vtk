/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>


#include "vtkActorWrap.h"
#include "vtkCubeAxesActorWrap.h"
#include "vtkObjectWrap.h"
#include "vtkViewportWrap.h"
#include "vtkStringArrayWrap.h"
#include "vtkCameraWrap.h"
#include "vtkWindowWrap.h"
#include "vtkTextPropertyWrap.h"
#include "vtkPropertyWrap.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkCubeAxesActorWrap::ptpl;

VtkCubeAxesActorWrap::VtkCubeAxesActorWrap()
{ }

VtkCubeAxesActorWrap::VtkCubeAxesActorWrap(vtkSmartPointer<vtkCubeAxesActor> _native)
{ native = _native; }

VtkCubeAxesActorWrap::~VtkCubeAxesActorWrap()
{ }

void VtkCubeAxesActorWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkCubeAxesActor").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("CubeAxesActor").ToLocalChecked(), ConstructorGetter);
}

void VtkCubeAxesActorWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkCubeAxesActorWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkActorWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkActorWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkCubeAxesActorWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "CenterStickyAxesOff", CenterStickyAxesOff);
	Nan::SetPrototypeMethod(tpl, "centerStickyAxesOff", CenterStickyAxesOff);

	Nan::SetPrototypeMethod(tpl, "CenterStickyAxesOn", CenterStickyAxesOn);
	Nan::SetPrototypeMethod(tpl, "centerStickyAxesOn", CenterStickyAxesOn);

	Nan::SetPrototypeMethod(tpl, "DrawXGridlinesOff", DrawXGridlinesOff);
	Nan::SetPrototypeMethod(tpl, "drawXGridlinesOff", DrawXGridlinesOff);

	Nan::SetPrototypeMethod(tpl, "DrawXGridlinesOn", DrawXGridlinesOn);
	Nan::SetPrototypeMethod(tpl, "drawXGridlinesOn", DrawXGridlinesOn);

	Nan::SetPrototypeMethod(tpl, "DrawXGridpolysOff", DrawXGridpolysOff);
	Nan::SetPrototypeMethod(tpl, "drawXGridpolysOff", DrawXGridpolysOff);

	Nan::SetPrototypeMethod(tpl, "DrawXGridpolysOn", DrawXGridpolysOn);
	Nan::SetPrototypeMethod(tpl, "drawXGridpolysOn", DrawXGridpolysOn);

	Nan::SetPrototypeMethod(tpl, "DrawXInnerGridlinesOff", DrawXInnerGridlinesOff);
	Nan::SetPrototypeMethod(tpl, "drawXInnerGridlinesOff", DrawXInnerGridlinesOff);

	Nan::SetPrototypeMethod(tpl, "DrawXInnerGridlinesOn", DrawXInnerGridlinesOn);
	Nan::SetPrototypeMethod(tpl, "drawXInnerGridlinesOn", DrawXInnerGridlinesOn);

	Nan::SetPrototypeMethod(tpl, "DrawYGridlinesOff", DrawYGridlinesOff);
	Nan::SetPrototypeMethod(tpl, "drawYGridlinesOff", DrawYGridlinesOff);

	Nan::SetPrototypeMethod(tpl, "DrawYGridlinesOn", DrawYGridlinesOn);
	Nan::SetPrototypeMethod(tpl, "drawYGridlinesOn", DrawYGridlinesOn);

	Nan::SetPrototypeMethod(tpl, "DrawYGridpolysOff", DrawYGridpolysOff);
	Nan::SetPrototypeMethod(tpl, "drawYGridpolysOff", DrawYGridpolysOff);

	Nan::SetPrototypeMethod(tpl, "DrawYGridpolysOn", DrawYGridpolysOn);
	Nan::SetPrototypeMethod(tpl, "drawYGridpolysOn", DrawYGridpolysOn);

	Nan::SetPrototypeMethod(tpl, "DrawYInnerGridlinesOff", DrawYInnerGridlinesOff);
	Nan::SetPrototypeMethod(tpl, "drawYInnerGridlinesOff", DrawYInnerGridlinesOff);

	Nan::SetPrototypeMethod(tpl, "DrawYInnerGridlinesOn", DrawYInnerGridlinesOn);
	Nan::SetPrototypeMethod(tpl, "drawYInnerGridlinesOn", DrawYInnerGridlinesOn);

	Nan::SetPrototypeMethod(tpl, "DrawZGridlinesOff", DrawZGridlinesOff);
	Nan::SetPrototypeMethod(tpl, "drawZGridlinesOff", DrawZGridlinesOff);

	Nan::SetPrototypeMethod(tpl, "DrawZGridlinesOn", DrawZGridlinesOn);
	Nan::SetPrototypeMethod(tpl, "drawZGridlinesOn", DrawZGridlinesOn);

	Nan::SetPrototypeMethod(tpl, "DrawZGridpolysOff", DrawZGridpolysOff);
	Nan::SetPrototypeMethod(tpl, "drawZGridpolysOff", DrawZGridpolysOff);

	Nan::SetPrototypeMethod(tpl, "DrawZGridpolysOn", DrawZGridpolysOn);
	Nan::SetPrototypeMethod(tpl, "drawZGridpolysOn", DrawZGridpolysOn);

	Nan::SetPrototypeMethod(tpl, "DrawZInnerGridlinesOff", DrawZInnerGridlinesOff);
	Nan::SetPrototypeMethod(tpl, "drawZInnerGridlinesOff", DrawZInnerGridlinesOff);

	Nan::SetPrototypeMethod(tpl, "DrawZInnerGridlinesOn", DrawZInnerGridlinesOn);
	Nan::SetPrototypeMethod(tpl, "drawZInnerGridlinesOn", DrawZInnerGridlinesOn);

	Nan::SetPrototypeMethod(tpl, "GetAxisLabels", GetAxisLabels);
	Nan::SetPrototypeMethod(tpl, "getAxisLabels", GetAxisLabels);

	Nan::SetPrototypeMethod(tpl, "GetCamera", GetCamera);
	Nan::SetPrototypeMethod(tpl, "getCamera", GetCamera);

	Nan::SetPrototypeMethod(tpl, "GetCenterStickyAxes", GetCenterStickyAxes);
	Nan::SetPrototypeMethod(tpl, "getCenterStickyAxes", GetCenterStickyAxes);

	Nan::SetPrototypeMethod(tpl, "GetClassName", GetClassName);
	Nan::SetPrototypeMethod(tpl, "getClassName", GetClassName);

	Nan::SetPrototypeMethod(tpl, "GetCornerOffset", GetCornerOffset);
	Nan::SetPrototypeMethod(tpl, "getCornerOffset", GetCornerOffset);

	Nan::SetPrototypeMethod(tpl, "GetDistanceLODThreshold", GetDistanceLODThreshold);
	Nan::SetPrototypeMethod(tpl, "getDistanceLODThreshold", GetDistanceLODThreshold);

	Nan::SetPrototypeMethod(tpl, "GetDistanceLODThresholdMaxValue", GetDistanceLODThresholdMaxValue);
	Nan::SetPrototypeMethod(tpl, "getDistanceLODThresholdMaxValue", GetDistanceLODThresholdMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetDistanceLODThresholdMinValue", GetDistanceLODThresholdMinValue);
	Nan::SetPrototypeMethod(tpl, "getDistanceLODThresholdMinValue", GetDistanceLODThresholdMinValue);

	Nan::SetPrototypeMethod(tpl, "GetDrawXGridlines", GetDrawXGridlines);
	Nan::SetPrototypeMethod(tpl, "getDrawXGridlines", GetDrawXGridlines);

	Nan::SetPrototypeMethod(tpl, "GetDrawXGridpolys", GetDrawXGridpolys);
	Nan::SetPrototypeMethod(tpl, "getDrawXGridpolys", GetDrawXGridpolys);

	Nan::SetPrototypeMethod(tpl, "GetDrawXInnerGridlines", GetDrawXInnerGridlines);
	Nan::SetPrototypeMethod(tpl, "getDrawXInnerGridlines", GetDrawXInnerGridlines);

	Nan::SetPrototypeMethod(tpl, "GetDrawYGridlines", GetDrawYGridlines);
	Nan::SetPrototypeMethod(tpl, "getDrawYGridlines", GetDrawYGridlines);

	Nan::SetPrototypeMethod(tpl, "GetDrawYGridpolys", GetDrawYGridpolys);
	Nan::SetPrototypeMethod(tpl, "getDrawYGridpolys", GetDrawYGridpolys);

	Nan::SetPrototypeMethod(tpl, "GetDrawYInnerGridlines", GetDrawYInnerGridlines);
	Nan::SetPrototypeMethod(tpl, "getDrawYInnerGridlines", GetDrawYInnerGridlines);

	Nan::SetPrototypeMethod(tpl, "GetDrawZGridlines", GetDrawZGridlines);
	Nan::SetPrototypeMethod(tpl, "getDrawZGridlines", GetDrawZGridlines);

	Nan::SetPrototypeMethod(tpl, "GetDrawZGridpolys", GetDrawZGridpolys);
	Nan::SetPrototypeMethod(tpl, "getDrawZGridpolys", GetDrawZGridpolys);

	Nan::SetPrototypeMethod(tpl, "GetDrawZInnerGridlines", GetDrawZInnerGridlines);
	Nan::SetPrototypeMethod(tpl, "getDrawZInnerGridlines", GetDrawZInnerGridlines);

	Nan::SetPrototypeMethod(tpl, "GetEnableDistanceLOD", GetEnableDistanceLOD);
	Nan::SetPrototypeMethod(tpl, "getEnableDistanceLOD", GetEnableDistanceLOD);

	Nan::SetPrototypeMethod(tpl, "GetEnableViewAngleLOD", GetEnableViewAngleLOD);
	Nan::SetPrototypeMethod(tpl, "getEnableViewAngleLOD", GetEnableViewAngleLOD);

	Nan::SetPrototypeMethod(tpl, "GetFlyMode", GetFlyMode);
	Nan::SetPrototypeMethod(tpl, "getFlyMode", GetFlyMode);

	Nan::SetPrototypeMethod(tpl, "GetFlyModeMaxValue", GetFlyModeMaxValue);
	Nan::SetPrototypeMethod(tpl, "getFlyModeMaxValue", GetFlyModeMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetFlyModeMinValue", GetFlyModeMinValue);
	Nan::SetPrototypeMethod(tpl, "getFlyModeMinValue", GetFlyModeMinValue);

	Nan::SetPrototypeMethod(tpl, "GetGridLineLocation", GetGridLineLocation);
	Nan::SetPrototypeMethod(tpl, "getGridLineLocation", GetGridLineLocation);

	Nan::SetPrototypeMethod(tpl, "GetInertia", GetInertia);
	Nan::SetPrototypeMethod(tpl, "getInertia", GetInertia);

	Nan::SetPrototypeMethod(tpl, "GetInertiaMaxValue", GetInertiaMaxValue);
	Nan::SetPrototypeMethod(tpl, "getInertiaMaxValue", GetInertiaMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetInertiaMinValue", GetInertiaMinValue);
	Nan::SetPrototypeMethod(tpl, "getInertiaMinValue", GetInertiaMinValue);

	Nan::SetPrototypeMethod(tpl, "GetLabelOffset", GetLabelOffset);
	Nan::SetPrototypeMethod(tpl, "getLabelOffset", GetLabelOffset);

	Nan::SetPrototypeMethod(tpl, "GetLabelTextProperty", GetLabelTextProperty);
	Nan::SetPrototypeMethod(tpl, "getLabelTextProperty", GetLabelTextProperty);

	Nan::SetPrototypeMethod(tpl, "GetScreenSize", GetScreenSize);
	Nan::SetPrototypeMethod(tpl, "getScreenSize", GetScreenSize);

	Nan::SetPrototypeMethod(tpl, "GetStickyAxes", GetStickyAxes);
	Nan::SetPrototypeMethod(tpl, "getStickyAxes", GetStickyAxes);

	Nan::SetPrototypeMethod(tpl, "GetTickLocation", GetTickLocation);
	Nan::SetPrototypeMethod(tpl, "getTickLocation", GetTickLocation);

	Nan::SetPrototypeMethod(tpl, "GetTickLocationMaxValue", GetTickLocationMaxValue);
	Nan::SetPrototypeMethod(tpl, "getTickLocationMaxValue", GetTickLocationMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetTickLocationMinValue", GetTickLocationMinValue);
	Nan::SetPrototypeMethod(tpl, "getTickLocationMinValue", GetTickLocationMinValue);

	Nan::SetPrototypeMethod(tpl, "GetTitleOffset", GetTitleOffset);
	Nan::SetPrototypeMethod(tpl, "getTitleOffset", GetTitleOffset);

	Nan::SetPrototypeMethod(tpl, "GetTitleTextProperty", GetTitleTextProperty);
	Nan::SetPrototypeMethod(tpl, "getTitleTextProperty", GetTitleTextProperty);

	Nan::SetPrototypeMethod(tpl, "GetUse2DMode", GetUse2DMode);
	Nan::SetPrototypeMethod(tpl, "getUse2DMode", GetUse2DMode);

	Nan::SetPrototypeMethod(tpl, "GetUseAxisOrigin", GetUseAxisOrigin);
	Nan::SetPrototypeMethod(tpl, "getUseAxisOrigin", GetUseAxisOrigin);

	Nan::SetPrototypeMethod(tpl, "GetUseOrientedBounds", GetUseOrientedBounds);
	Nan::SetPrototypeMethod(tpl, "getUseOrientedBounds", GetUseOrientedBounds);

	Nan::SetPrototypeMethod(tpl, "GetUseTextActor3D", GetUseTextActor3D);
	Nan::SetPrototypeMethod(tpl, "getUseTextActor3D", GetUseTextActor3D);

	Nan::SetPrototypeMethod(tpl, "GetViewAngleLODThreshold", GetViewAngleLODThreshold);
	Nan::SetPrototypeMethod(tpl, "getViewAngleLODThreshold", GetViewAngleLODThreshold);

	Nan::SetPrototypeMethod(tpl, "GetViewAngleLODThresholdMaxValue", GetViewAngleLODThresholdMaxValue);
	Nan::SetPrototypeMethod(tpl, "getViewAngleLODThresholdMaxValue", GetViewAngleLODThresholdMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetViewAngleLODThresholdMinValue", GetViewAngleLODThresholdMinValue);
	Nan::SetPrototypeMethod(tpl, "getViewAngleLODThresholdMinValue", GetViewAngleLODThresholdMinValue);

	Nan::SetPrototypeMethod(tpl, "GetXAxesGridlinesProperty", GetXAxesGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "getXAxesGridlinesProperty", GetXAxesGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetXAxesGridpolysProperty", GetXAxesGridpolysProperty);
	Nan::SetPrototypeMethod(tpl, "getXAxesGridpolysProperty", GetXAxesGridpolysProperty);

	Nan::SetPrototypeMethod(tpl, "GetXAxesInnerGridlinesProperty", GetXAxesInnerGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "getXAxesInnerGridlinesProperty", GetXAxesInnerGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetXAxesLinesProperty", GetXAxesLinesProperty);
	Nan::SetPrototypeMethod(tpl, "getXAxesLinesProperty", GetXAxesLinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetXAxisLabelVisibility", GetXAxisLabelVisibility);
	Nan::SetPrototypeMethod(tpl, "getXAxisLabelVisibility", GetXAxisLabelVisibility);

	Nan::SetPrototypeMethod(tpl, "GetXAxisMinorTickVisibility", GetXAxisMinorTickVisibility);
	Nan::SetPrototypeMethod(tpl, "getXAxisMinorTickVisibility", GetXAxisMinorTickVisibility);

	Nan::SetPrototypeMethod(tpl, "GetXAxisTickVisibility", GetXAxisTickVisibility);
	Nan::SetPrototypeMethod(tpl, "getXAxisTickVisibility", GetXAxisTickVisibility);

	Nan::SetPrototypeMethod(tpl, "GetXAxisVisibility", GetXAxisVisibility);
	Nan::SetPrototypeMethod(tpl, "getXAxisVisibility", GetXAxisVisibility);

	Nan::SetPrototypeMethod(tpl, "GetXLabelFormat", GetXLabelFormat);
	Nan::SetPrototypeMethod(tpl, "getXLabelFormat", GetXLabelFormat);

	Nan::SetPrototypeMethod(tpl, "GetXTitle", GetXTitle);
	Nan::SetPrototypeMethod(tpl, "getXTitle", GetXTitle);

	Nan::SetPrototypeMethod(tpl, "GetXUnits", GetXUnits);
	Nan::SetPrototypeMethod(tpl, "getXUnits", GetXUnits);

	Nan::SetPrototypeMethod(tpl, "GetYAxesGridlinesProperty", GetYAxesGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "getYAxesGridlinesProperty", GetYAxesGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetYAxesGridpolysProperty", GetYAxesGridpolysProperty);
	Nan::SetPrototypeMethod(tpl, "getYAxesGridpolysProperty", GetYAxesGridpolysProperty);

	Nan::SetPrototypeMethod(tpl, "GetYAxesInnerGridlinesProperty", GetYAxesInnerGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "getYAxesInnerGridlinesProperty", GetYAxesInnerGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetYAxesLinesProperty", GetYAxesLinesProperty);
	Nan::SetPrototypeMethod(tpl, "getYAxesLinesProperty", GetYAxesLinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetYAxisLabelVisibility", GetYAxisLabelVisibility);
	Nan::SetPrototypeMethod(tpl, "getYAxisLabelVisibility", GetYAxisLabelVisibility);

	Nan::SetPrototypeMethod(tpl, "GetYAxisMinorTickVisibility", GetYAxisMinorTickVisibility);
	Nan::SetPrototypeMethod(tpl, "getYAxisMinorTickVisibility", GetYAxisMinorTickVisibility);

	Nan::SetPrototypeMethod(tpl, "GetYAxisTickVisibility", GetYAxisTickVisibility);
	Nan::SetPrototypeMethod(tpl, "getYAxisTickVisibility", GetYAxisTickVisibility);

	Nan::SetPrototypeMethod(tpl, "GetYAxisVisibility", GetYAxisVisibility);
	Nan::SetPrototypeMethod(tpl, "getYAxisVisibility", GetYAxisVisibility);

	Nan::SetPrototypeMethod(tpl, "GetYLabelFormat", GetYLabelFormat);
	Nan::SetPrototypeMethod(tpl, "getYLabelFormat", GetYLabelFormat);

	Nan::SetPrototypeMethod(tpl, "GetYTitle", GetYTitle);
	Nan::SetPrototypeMethod(tpl, "getYTitle", GetYTitle);

	Nan::SetPrototypeMethod(tpl, "GetYUnits", GetYUnits);
	Nan::SetPrototypeMethod(tpl, "getYUnits", GetYUnits);

	Nan::SetPrototypeMethod(tpl, "GetZAxesGridlinesProperty", GetZAxesGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "getZAxesGridlinesProperty", GetZAxesGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetZAxesGridpolysProperty", GetZAxesGridpolysProperty);
	Nan::SetPrototypeMethod(tpl, "getZAxesGridpolysProperty", GetZAxesGridpolysProperty);

	Nan::SetPrototypeMethod(tpl, "GetZAxesInnerGridlinesProperty", GetZAxesInnerGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "getZAxesInnerGridlinesProperty", GetZAxesInnerGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetZAxesLinesProperty", GetZAxesLinesProperty);
	Nan::SetPrototypeMethod(tpl, "getZAxesLinesProperty", GetZAxesLinesProperty);

	Nan::SetPrototypeMethod(tpl, "GetZAxisLabelVisibility", GetZAxisLabelVisibility);
	Nan::SetPrototypeMethod(tpl, "getZAxisLabelVisibility", GetZAxisLabelVisibility);

	Nan::SetPrototypeMethod(tpl, "GetZAxisMinorTickVisibility", GetZAxisMinorTickVisibility);
	Nan::SetPrototypeMethod(tpl, "getZAxisMinorTickVisibility", GetZAxisMinorTickVisibility);

	Nan::SetPrototypeMethod(tpl, "GetZAxisTickVisibility", GetZAxisTickVisibility);
	Nan::SetPrototypeMethod(tpl, "getZAxisTickVisibility", GetZAxisTickVisibility);

	Nan::SetPrototypeMethod(tpl, "GetZAxisVisibility", GetZAxisVisibility);
	Nan::SetPrototypeMethod(tpl, "getZAxisVisibility", GetZAxisVisibility);

	Nan::SetPrototypeMethod(tpl, "GetZLabelFormat", GetZLabelFormat);
	Nan::SetPrototypeMethod(tpl, "getZLabelFormat", GetZLabelFormat);

	Nan::SetPrototypeMethod(tpl, "GetZTitle", GetZTitle);
	Nan::SetPrototypeMethod(tpl, "getZTitle", GetZTitle);

	Nan::SetPrototypeMethod(tpl, "GetZUnits", GetZUnits);
	Nan::SetPrototypeMethod(tpl, "getZUnits", GetZUnits);

	Nan::SetPrototypeMethod(tpl, "HasTranslucentPolygonalGeometry", HasTranslucentPolygonalGeometry);
	Nan::SetPrototypeMethod(tpl, "hasTranslucentPolygonalGeometry", HasTranslucentPolygonalGeometry);

	Nan::SetPrototypeMethod(tpl, "IsA", IsA);
	Nan::SetPrototypeMethod(tpl, "isA", IsA);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "ReleaseGraphicsResources", ReleaseGraphicsResources);
	Nan::SetPrototypeMethod(tpl, "releaseGraphicsResources", ReleaseGraphicsResources);

	Nan::SetPrototypeMethod(tpl, "RenderOpaqueGeometry", RenderOpaqueGeometry);
	Nan::SetPrototypeMethod(tpl, "renderOpaqueGeometry", RenderOpaqueGeometry);

	Nan::SetPrototypeMethod(tpl, "RenderOverlay", RenderOverlay);
	Nan::SetPrototypeMethod(tpl, "renderOverlay", RenderOverlay);

	Nan::SetPrototypeMethod(tpl, "RenderTranslucentGeometry", RenderTranslucentGeometry);
	Nan::SetPrototypeMethod(tpl, "renderTranslucentGeometry", RenderTranslucentGeometry);

	Nan::SetPrototypeMethod(tpl, "RenderTranslucentPolygonalGeometry", RenderTranslucentPolygonalGeometry);
	Nan::SetPrototypeMethod(tpl, "renderTranslucentPolygonalGeometry", RenderTranslucentPolygonalGeometry);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetAxisBaseForX", SetAxisBaseForX);
	Nan::SetPrototypeMethod(tpl, "setAxisBaseForX", SetAxisBaseForX);

	Nan::SetPrototypeMethod(tpl, "SetAxisBaseForY", SetAxisBaseForY);
	Nan::SetPrototypeMethod(tpl, "setAxisBaseForY", SetAxisBaseForY);

	Nan::SetPrototypeMethod(tpl, "SetAxisBaseForZ", SetAxisBaseForZ);
	Nan::SetPrototypeMethod(tpl, "setAxisBaseForZ", SetAxisBaseForZ);

	Nan::SetPrototypeMethod(tpl, "SetAxisLabels", SetAxisLabels);
	Nan::SetPrototypeMethod(tpl, "setAxisLabels", SetAxisLabels);

	Nan::SetPrototypeMethod(tpl, "SetAxisOrigin", SetAxisOrigin);
	Nan::SetPrototypeMethod(tpl, "setAxisOrigin", SetAxisOrigin);

	Nan::SetPrototypeMethod(tpl, "SetBounds", SetBounds);
	Nan::SetPrototypeMethod(tpl, "setBounds", SetBounds);

	Nan::SetPrototypeMethod(tpl, "SetCamera", SetCamera);
	Nan::SetPrototypeMethod(tpl, "setCamera", SetCamera);

	Nan::SetPrototypeMethod(tpl, "SetCenterStickyAxes", SetCenterStickyAxes);
	Nan::SetPrototypeMethod(tpl, "setCenterStickyAxes", SetCenterStickyAxes);

	Nan::SetPrototypeMethod(tpl, "SetCornerOffset", SetCornerOffset);
	Nan::SetPrototypeMethod(tpl, "setCornerOffset", SetCornerOffset);

	Nan::SetPrototypeMethod(tpl, "SetDistanceLODThreshold", SetDistanceLODThreshold);
	Nan::SetPrototypeMethod(tpl, "setDistanceLODThreshold", SetDistanceLODThreshold);

	Nan::SetPrototypeMethod(tpl, "SetDrawXGridlines", SetDrawXGridlines);
	Nan::SetPrototypeMethod(tpl, "setDrawXGridlines", SetDrawXGridlines);

	Nan::SetPrototypeMethod(tpl, "SetDrawXGridpolys", SetDrawXGridpolys);
	Nan::SetPrototypeMethod(tpl, "setDrawXGridpolys", SetDrawXGridpolys);

	Nan::SetPrototypeMethod(tpl, "SetDrawXInnerGridlines", SetDrawXInnerGridlines);
	Nan::SetPrototypeMethod(tpl, "setDrawXInnerGridlines", SetDrawXInnerGridlines);

	Nan::SetPrototypeMethod(tpl, "SetDrawYGridlines", SetDrawYGridlines);
	Nan::SetPrototypeMethod(tpl, "setDrawYGridlines", SetDrawYGridlines);

	Nan::SetPrototypeMethod(tpl, "SetDrawYGridpolys", SetDrawYGridpolys);
	Nan::SetPrototypeMethod(tpl, "setDrawYGridpolys", SetDrawYGridpolys);

	Nan::SetPrototypeMethod(tpl, "SetDrawYInnerGridlines", SetDrawYInnerGridlines);
	Nan::SetPrototypeMethod(tpl, "setDrawYInnerGridlines", SetDrawYInnerGridlines);

	Nan::SetPrototypeMethod(tpl, "SetDrawZGridlines", SetDrawZGridlines);
	Nan::SetPrototypeMethod(tpl, "setDrawZGridlines", SetDrawZGridlines);

	Nan::SetPrototypeMethod(tpl, "SetDrawZGridpolys", SetDrawZGridpolys);
	Nan::SetPrototypeMethod(tpl, "setDrawZGridpolys", SetDrawZGridpolys);

	Nan::SetPrototypeMethod(tpl, "SetDrawZInnerGridlines", SetDrawZInnerGridlines);
	Nan::SetPrototypeMethod(tpl, "setDrawZInnerGridlines", SetDrawZInnerGridlines);

	Nan::SetPrototypeMethod(tpl, "SetEnableDistanceLOD", SetEnableDistanceLOD);
	Nan::SetPrototypeMethod(tpl, "setEnableDistanceLOD", SetEnableDistanceLOD);

	Nan::SetPrototypeMethod(tpl, "SetEnableViewAngleLOD", SetEnableViewAngleLOD);
	Nan::SetPrototypeMethod(tpl, "setEnableViewAngleLOD", SetEnableViewAngleLOD);

	Nan::SetPrototypeMethod(tpl, "SetFlyMode", SetFlyMode);
	Nan::SetPrototypeMethod(tpl, "setFlyMode", SetFlyMode);

	Nan::SetPrototypeMethod(tpl, "SetFlyModeToClosestTriad", SetFlyModeToClosestTriad);
	Nan::SetPrototypeMethod(tpl, "setFlyModeToClosestTriad", SetFlyModeToClosestTriad);

	Nan::SetPrototypeMethod(tpl, "SetFlyModeToFurthestTriad", SetFlyModeToFurthestTriad);
	Nan::SetPrototypeMethod(tpl, "setFlyModeToFurthestTriad", SetFlyModeToFurthestTriad);

	Nan::SetPrototypeMethod(tpl, "SetFlyModeToOuterEdges", SetFlyModeToOuterEdges);
	Nan::SetPrototypeMethod(tpl, "setFlyModeToOuterEdges", SetFlyModeToOuterEdges);

	Nan::SetPrototypeMethod(tpl, "SetFlyModeToStaticEdges", SetFlyModeToStaticEdges);
	Nan::SetPrototypeMethod(tpl, "setFlyModeToStaticEdges", SetFlyModeToStaticEdges);

	Nan::SetPrototypeMethod(tpl, "SetFlyModeToStaticTriad", SetFlyModeToStaticTriad);
	Nan::SetPrototypeMethod(tpl, "setFlyModeToStaticTriad", SetFlyModeToStaticTriad);

	Nan::SetPrototypeMethod(tpl, "SetGridLineLocation", SetGridLineLocation);
	Nan::SetPrototypeMethod(tpl, "setGridLineLocation", SetGridLineLocation);

	Nan::SetPrototypeMethod(tpl, "SetInertia", SetInertia);
	Nan::SetPrototypeMethod(tpl, "setInertia", SetInertia);

	Nan::SetPrototypeMethod(tpl, "SetLabelOffset", SetLabelOffset);
	Nan::SetPrototypeMethod(tpl, "setLabelOffset", SetLabelOffset);

	Nan::SetPrototypeMethod(tpl, "SetOrientedBounds", SetOrientedBounds);
	Nan::SetPrototypeMethod(tpl, "setOrientedBounds", SetOrientedBounds);

	Nan::SetPrototypeMethod(tpl, "SetSaveTitlePosition", SetSaveTitlePosition);
	Nan::SetPrototypeMethod(tpl, "setSaveTitlePosition", SetSaveTitlePosition);

	Nan::SetPrototypeMethod(tpl, "SetScreenSize", SetScreenSize);
	Nan::SetPrototypeMethod(tpl, "setScreenSize", SetScreenSize);

	Nan::SetPrototypeMethod(tpl, "SetStickyAxes", SetStickyAxes);
	Nan::SetPrototypeMethod(tpl, "setStickyAxes", SetStickyAxes);

	Nan::SetPrototypeMethod(tpl, "SetTickLocation", SetTickLocation);
	Nan::SetPrototypeMethod(tpl, "setTickLocation", SetTickLocation);

	Nan::SetPrototypeMethod(tpl, "SetTickLocationToBoth", SetTickLocationToBoth);
	Nan::SetPrototypeMethod(tpl, "setTickLocationToBoth", SetTickLocationToBoth);

	Nan::SetPrototypeMethod(tpl, "SetTickLocationToInside", SetTickLocationToInside);
	Nan::SetPrototypeMethod(tpl, "setTickLocationToInside", SetTickLocationToInside);

	Nan::SetPrototypeMethod(tpl, "SetTickLocationToOutside", SetTickLocationToOutside);
	Nan::SetPrototypeMethod(tpl, "setTickLocationToOutside", SetTickLocationToOutside);

	Nan::SetPrototypeMethod(tpl, "SetTitleOffset", SetTitleOffset);
	Nan::SetPrototypeMethod(tpl, "setTitleOffset", SetTitleOffset);

	Nan::SetPrototypeMethod(tpl, "SetUse2DMode", SetUse2DMode);
	Nan::SetPrototypeMethod(tpl, "setUse2DMode", SetUse2DMode);

	Nan::SetPrototypeMethod(tpl, "SetUseAxisOrigin", SetUseAxisOrigin);
	Nan::SetPrototypeMethod(tpl, "setUseAxisOrigin", SetUseAxisOrigin);

	Nan::SetPrototypeMethod(tpl, "SetUseOrientedBounds", SetUseOrientedBounds);
	Nan::SetPrototypeMethod(tpl, "setUseOrientedBounds", SetUseOrientedBounds);

	Nan::SetPrototypeMethod(tpl, "SetUseTextActor3D", SetUseTextActor3D);
	Nan::SetPrototypeMethod(tpl, "setUseTextActor3D", SetUseTextActor3D);

	Nan::SetPrototypeMethod(tpl, "SetViewAngleLODThreshold", SetViewAngleLODThreshold);
	Nan::SetPrototypeMethod(tpl, "setViewAngleLODThreshold", SetViewAngleLODThreshold);

	Nan::SetPrototypeMethod(tpl, "SetXAxesGridlinesProperty", SetXAxesGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "setXAxesGridlinesProperty", SetXAxesGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetXAxesGridpolysProperty", SetXAxesGridpolysProperty);
	Nan::SetPrototypeMethod(tpl, "setXAxesGridpolysProperty", SetXAxesGridpolysProperty);

	Nan::SetPrototypeMethod(tpl, "SetXAxesInnerGridlinesProperty", SetXAxesInnerGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "setXAxesInnerGridlinesProperty", SetXAxesInnerGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetXAxesLinesProperty", SetXAxesLinesProperty);
	Nan::SetPrototypeMethod(tpl, "setXAxesLinesProperty", SetXAxesLinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetXAxisLabelVisibility", SetXAxisLabelVisibility);
	Nan::SetPrototypeMethod(tpl, "setXAxisLabelVisibility", SetXAxisLabelVisibility);

	Nan::SetPrototypeMethod(tpl, "SetXAxisMinorTickVisibility", SetXAxisMinorTickVisibility);
	Nan::SetPrototypeMethod(tpl, "setXAxisMinorTickVisibility", SetXAxisMinorTickVisibility);

	Nan::SetPrototypeMethod(tpl, "SetXAxisRange", SetXAxisRange);
	Nan::SetPrototypeMethod(tpl, "setXAxisRange", SetXAxisRange);

	Nan::SetPrototypeMethod(tpl, "SetXAxisTickVisibility", SetXAxisTickVisibility);
	Nan::SetPrototypeMethod(tpl, "setXAxisTickVisibility", SetXAxisTickVisibility);

	Nan::SetPrototypeMethod(tpl, "SetXAxisVisibility", SetXAxisVisibility);
	Nan::SetPrototypeMethod(tpl, "setXAxisVisibility", SetXAxisVisibility);

	Nan::SetPrototypeMethod(tpl, "SetXLabelFormat", SetXLabelFormat);
	Nan::SetPrototypeMethod(tpl, "setXLabelFormat", SetXLabelFormat);

	Nan::SetPrototypeMethod(tpl, "SetXTitle", SetXTitle);
	Nan::SetPrototypeMethod(tpl, "setXTitle", SetXTitle);

	Nan::SetPrototypeMethod(tpl, "SetXUnits", SetXUnits);
	Nan::SetPrototypeMethod(tpl, "setXUnits", SetXUnits);

	Nan::SetPrototypeMethod(tpl, "SetYAxesGridlinesProperty", SetYAxesGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "setYAxesGridlinesProperty", SetYAxesGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetYAxesGridpolysProperty", SetYAxesGridpolysProperty);
	Nan::SetPrototypeMethod(tpl, "setYAxesGridpolysProperty", SetYAxesGridpolysProperty);

	Nan::SetPrototypeMethod(tpl, "SetYAxesInnerGridlinesProperty", SetYAxesInnerGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "setYAxesInnerGridlinesProperty", SetYAxesInnerGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetYAxesLinesProperty", SetYAxesLinesProperty);
	Nan::SetPrototypeMethod(tpl, "setYAxesLinesProperty", SetYAxesLinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetYAxisLabelVisibility", SetYAxisLabelVisibility);
	Nan::SetPrototypeMethod(tpl, "setYAxisLabelVisibility", SetYAxisLabelVisibility);

	Nan::SetPrototypeMethod(tpl, "SetYAxisMinorTickVisibility", SetYAxisMinorTickVisibility);
	Nan::SetPrototypeMethod(tpl, "setYAxisMinorTickVisibility", SetYAxisMinorTickVisibility);

	Nan::SetPrototypeMethod(tpl, "SetYAxisRange", SetYAxisRange);
	Nan::SetPrototypeMethod(tpl, "setYAxisRange", SetYAxisRange);

	Nan::SetPrototypeMethod(tpl, "SetYAxisTickVisibility", SetYAxisTickVisibility);
	Nan::SetPrototypeMethod(tpl, "setYAxisTickVisibility", SetYAxisTickVisibility);

	Nan::SetPrototypeMethod(tpl, "SetYAxisVisibility", SetYAxisVisibility);
	Nan::SetPrototypeMethod(tpl, "setYAxisVisibility", SetYAxisVisibility);

	Nan::SetPrototypeMethod(tpl, "SetYLabelFormat", SetYLabelFormat);
	Nan::SetPrototypeMethod(tpl, "setYLabelFormat", SetYLabelFormat);

	Nan::SetPrototypeMethod(tpl, "SetYTitle", SetYTitle);
	Nan::SetPrototypeMethod(tpl, "setYTitle", SetYTitle);

	Nan::SetPrototypeMethod(tpl, "SetYUnits", SetYUnits);
	Nan::SetPrototypeMethod(tpl, "setYUnits", SetYUnits);

	Nan::SetPrototypeMethod(tpl, "SetZAxesGridlinesProperty", SetZAxesGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "setZAxesGridlinesProperty", SetZAxesGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetZAxesGridpolysProperty", SetZAxesGridpolysProperty);
	Nan::SetPrototypeMethod(tpl, "setZAxesGridpolysProperty", SetZAxesGridpolysProperty);

	Nan::SetPrototypeMethod(tpl, "SetZAxesInnerGridlinesProperty", SetZAxesInnerGridlinesProperty);
	Nan::SetPrototypeMethod(tpl, "setZAxesInnerGridlinesProperty", SetZAxesInnerGridlinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetZAxesLinesProperty", SetZAxesLinesProperty);
	Nan::SetPrototypeMethod(tpl, "setZAxesLinesProperty", SetZAxesLinesProperty);

	Nan::SetPrototypeMethod(tpl, "SetZAxisLabelVisibility", SetZAxisLabelVisibility);
	Nan::SetPrototypeMethod(tpl, "setZAxisLabelVisibility", SetZAxisLabelVisibility);

	Nan::SetPrototypeMethod(tpl, "SetZAxisMinorTickVisibility", SetZAxisMinorTickVisibility);
	Nan::SetPrototypeMethod(tpl, "setZAxisMinorTickVisibility", SetZAxisMinorTickVisibility);

	Nan::SetPrototypeMethod(tpl, "SetZAxisRange", SetZAxisRange);
	Nan::SetPrototypeMethod(tpl, "setZAxisRange", SetZAxisRange);

	Nan::SetPrototypeMethod(tpl, "SetZAxisTickVisibility", SetZAxisTickVisibility);
	Nan::SetPrototypeMethod(tpl, "setZAxisTickVisibility", SetZAxisTickVisibility);

	Nan::SetPrototypeMethod(tpl, "SetZAxisVisibility", SetZAxisVisibility);
	Nan::SetPrototypeMethod(tpl, "setZAxisVisibility", SetZAxisVisibility);

	Nan::SetPrototypeMethod(tpl, "SetZLabelFormat", SetZLabelFormat);
	Nan::SetPrototypeMethod(tpl, "setZLabelFormat", SetZLabelFormat);

	Nan::SetPrototypeMethod(tpl, "SetZTitle", SetZTitle);
	Nan::SetPrototypeMethod(tpl, "setZTitle", SetZTitle);

	Nan::SetPrototypeMethod(tpl, "SetZUnits", SetZUnits);
	Nan::SetPrototypeMethod(tpl, "setZUnits", SetZUnits);

	Nan::SetPrototypeMethod(tpl, "StickyAxesOff", StickyAxesOff);
	Nan::SetPrototypeMethod(tpl, "stickyAxesOff", StickyAxesOff);

	Nan::SetPrototypeMethod(tpl, "StickyAxesOn", StickyAxesOn);
	Nan::SetPrototypeMethod(tpl, "stickyAxesOn", StickyAxesOn);

	Nan::SetPrototypeMethod(tpl, "XAxisLabelVisibilityOff", XAxisLabelVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "xAxisLabelVisibilityOff", XAxisLabelVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "XAxisLabelVisibilityOn", XAxisLabelVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "xAxisLabelVisibilityOn", XAxisLabelVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "XAxisMinorTickVisibilityOff", XAxisMinorTickVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "xAxisMinorTickVisibilityOff", XAxisMinorTickVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "XAxisMinorTickVisibilityOn", XAxisMinorTickVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "xAxisMinorTickVisibilityOn", XAxisMinorTickVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "XAxisTickVisibilityOff", XAxisTickVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "xAxisTickVisibilityOff", XAxisTickVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "XAxisTickVisibilityOn", XAxisTickVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "xAxisTickVisibilityOn", XAxisTickVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "XAxisVisibilityOff", XAxisVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "xAxisVisibilityOff", XAxisVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "XAxisVisibilityOn", XAxisVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "xAxisVisibilityOn", XAxisVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "YAxisLabelVisibilityOff", YAxisLabelVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "yAxisLabelVisibilityOff", YAxisLabelVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "YAxisLabelVisibilityOn", YAxisLabelVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "yAxisLabelVisibilityOn", YAxisLabelVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "YAxisMinorTickVisibilityOff", YAxisMinorTickVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "yAxisMinorTickVisibilityOff", YAxisMinorTickVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "YAxisMinorTickVisibilityOn", YAxisMinorTickVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "yAxisMinorTickVisibilityOn", YAxisMinorTickVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "YAxisTickVisibilityOff", YAxisTickVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "yAxisTickVisibilityOff", YAxisTickVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "YAxisTickVisibilityOn", YAxisTickVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "yAxisTickVisibilityOn", YAxisTickVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "YAxisVisibilityOff", YAxisVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "yAxisVisibilityOff", YAxisVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "YAxisVisibilityOn", YAxisVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "yAxisVisibilityOn", YAxisVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "ZAxisLabelVisibilityOff", ZAxisLabelVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "zAxisLabelVisibilityOff", ZAxisLabelVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "ZAxisLabelVisibilityOn", ZAxisLabelVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "zAxisLabelVisibilityOn", ZAxisLabelVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "ZAxisMinorTickVisibilityOff", ZAxisMinorTickVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "zAxisMinorTickVisibilityOff", ZAxisMinorTickVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "ZAxisMinorTickVisibilityOn", ZAxisMinorTickVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "zAxisMinorTickVisibilityOn", ZAxisMinorTickVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "ZAxisTickVisibilityOff", ZAxisTickVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "zAxisTickVisibilityOff", ZAxisTickVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "ZAxisTickVisibilityOn", ZAxisTickVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "zAxisTickVisibilityOn", ZAxisTickVisibilityOn);

	Nan::SetPrototypeMethod(tpl, "ZAxisVisibilityOff", ZAxisVisibilityOff);
	Nan::SetPrototypeMethod(tpl, "zAxisVisibilityOff", ZAxisVisibilityOff);

	Nan::SetPrototypeMethod(tpl, "ZAxisVisibilityOn", ZAxisVisibilityOn);
	Nan::SetPrototypeMethod(tpl, "zAxisVisibilityOn", ZAxisVisibilityOn);

	ptpl.Reset( tpl );
}

void VtkCubeAxesActorWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkCubeAxesActor> native = vtkSmartPointer<vtkCubeAxesActor>::New();
		VtkCubeAxesActorWrap* obj = new VtkCubeAxesActorWrap(native);		obj->Wrap(info.This());
	}
	else
	{
		Nan::Utf8String s(info[0]);
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
			Nan::ThrowError("Parameter Error");
	}

	info.GetReturnValue().Set(info.This());
}

void VtkCubeAxesActorWrap::CenterStickyAxesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CenterStickyAxesOff();
}

void VtkCubeAxesActorWrap::CenterStickyAxesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CenterStickyAxesOn();
}

void VtkCubeAxesActorWrap::DrawXGridlinesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawXGridlinesOff();
}

void VtkCubeAxesActorWrap::DrawXGridlinesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawXGridlinesOn();
}

void VtkCubeAxesActorWrap::DrawXGridpolysOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawXGridpolysOff();
}

void VtkCubeAxesActorWrap::DrawXGridpolysOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawXGridpolysOn();
}

void VtkCubeAxesActorWrap::DrawXInnerGridlinesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawXInnerGridlinesOff();
}

void VtkCubeAxesActorWrap::DrawXInnerGridlinesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawXInnerGridlinesOn();
}

void VtkCubeAxesActorWrap::DrawYGridlinesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawYGridlinesOff();
}

void VtkCubeAxesActorWrap::DrawYGridlinesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawYGridlinesOn();
}

void VtkCubeAxesActorWrap::DrawYGridpolysOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawYGridpolysOff();
}

void VtkCubeAxesActorWrap::DrawYGridpolysOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawYGridpolysOn();
}

void VtkCubeAxesActorWrap::DrawYInnerGridlinesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawYInnerGridlinesOff();
}

void VtkCubeAxesActorWrap::DrawYInnerGridlinesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawYInnerGridlinesOn();
}

void VtkCubeAxesActorWrap::DrawZGridlinesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawZGridlinesOff();
}

void VtkCubeAxesActorWrap::DrawZGridlinesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawZGridlinesOn();
}

void VtkCubeAxesActorWrap::DrawZGridpolysOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawZGridpolysOff();
}

void VtkCubeAxesActorWrap::DrawZGridpolysOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawZGridpolysOn();
}

void VtkCubeAxesActorWrap::DrawZInnerGridlinesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawZInnerGridlinesOff();
}

void VtkCubeAxesActorWrap::DrawZInnerGridlinesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DrawZInnerGridlinesOn();
}

void VtkCubeAxesActorWrap::GetAxisLabels(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkStringArray * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetAxisLabels(
			info[0]->Int32Value()
		);
			VtkStringArrayWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkStringArrayWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkStringArrayWrap *w = new VtkStringArrayWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::GetCamera(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkCamera * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCamera();
		VtkCameraWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkCameraWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkCameraWrap *w = new VtkCameraWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetCenterStickyAxes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCenterStickyAxes();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetClassName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClassName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetCornerOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCornerOffset();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDistanceLODThreshold(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDistanceLODThreshold();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDistanceLODThresholdMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDistanceLODThresholdMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDistanceLODThresholdMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDistanceLODThresholdMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawXGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawXGridlines();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawXGridpolys(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawXGridpolys();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawXInnerGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawXInnerGridlines();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawYGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawYGridlines();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawYGridpolys(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawYGridpolys();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawYInnerGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawYInnerGridlines();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawZGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawZGridlines();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawZGridpolys(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawZGridpolys();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetDrawZInnerGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDrawZInnerGridlines();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetEnableDistanceLOD(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEnableDistanceLOD();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetEnableViewAngleLOD(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEnableViewAngleLOD();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetFlyMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFlyMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetFlyModeMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFlyModeMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetFlyModeMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFlyModeMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetGridLineLocation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGridLineLocation();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetInertia(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInertia();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetInertiaMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInertiaMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetInertiaMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetInertiaMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetLabelOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetLabelOffset();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetLabelTextProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkTextProperty * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetLabelTextProperty(
			info[0]->Int32Value()
		);
			VtkTextPropertyWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkTextPropertyWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkTextPropertyWrap *w = new VtkTextPropertyWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::GetScreenSize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScreenSize();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetStickyAxes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStickyAxes();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetTickLocation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTickLocation();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetTickLocationMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTickLocationMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetTickLocationMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTickLocationMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetTitleOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetTitleOffset();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetTitleTextProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkTextProperty * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetTitleTextProperty(
			info[0]->Int32Value()
		);
			VtkTextPropertyWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkTextPropertyWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkTextPropertyWrap *w = new VtkTextPropertyWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::GetUse2DMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUse2DMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetUseAxisOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseAxisOrigin();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetUseOrientedBounds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseOrientedBounds();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetUseTextActor3D(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseTextActor3D();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetViewAngleLODThreshold(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewAngleLODThreshold();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetViewAngleLODThresholdMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewAngleLODThresholdMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetViewAngleLODThresholdMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetViewAngleLODThresholdMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetXAxesGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXAxesGridlinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetXAxesGridpolysProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXAxesGridpolysProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetXAxesInnerGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXAxesInnerGridlinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetXAxesLinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXAxesLinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetXAxisLabelVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXAxisLabelVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetXAxisMinorTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXAxisMinorTickVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetXAxisTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXAxisTickVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetXAxisVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXAxisVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetXLabelFormat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXLabelFormat();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetXTitle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXTitle();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetXUnits(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetXUnits();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetYAxesGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYAxesGridlinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetYAxesGridpolysProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYAxesGridpolysProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetYAxesInnerGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYAxesInnerGridlinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetYAxesLinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYAxesLinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetYAxisLabelVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYAxisLabelVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetYAxisMinorTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYAxisMinorTickVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetYAxisTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYAxisTickVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetYAxisVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYAxisVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetYLabelFormat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYLabelFormat();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetYTitle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYTitle();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetYUnits(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetYUnits();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetZAxesGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZAxesGridlinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetZAxesGridpolysProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZAxesGridpolysProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetZAxesInnerGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZAxesInnerGridlinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetZAxesLinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkProperty * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZAxesLinesProperty();
		VtkPropertyWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPropertyWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPropertyWrap *w = new VtkPropertyWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::GetZAxisLabelVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZAxisLabelVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetZAxisMinorTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZAxisMinorTickVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetZAxisTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZAxisTickVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetZAxisVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZAxisVisibility();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::GetZLabelFormat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZLabelFormat();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetZTitle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZTitle();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::GetZUnits(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetZUnits();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkCubeAxesActorWrap::HasTranslucentPolygonalGeometry(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->HasTranslucentPolygonalGeometry();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkCubeAxesActorWrap::IsA(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->IsA(
			*a0
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	vtkCubeAxesActor * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
		VtkCubeAxesActorWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkCubeAxesActorWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkCubeAxesActorWrap *w = new VtkCubeAxesActorWrap();
	w->native.TakeReference(r);
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkCubeAxesActorWrap::ReleaseGraphicsResources(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkWindowWrap::ptpl))->HasInstance(info[0]))
	{
		VtkWindowWrap *a0 = ObjectWrap::Unwrap<VtkWindowWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->ReleaseGraphicsResources(
			(vtkWindow *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::RenderOpaqueGeometry(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkViewportWrap::ptpl))->HasInstance(info[0]))
	{
		VtkViewportWrap *a0 = ObjectWrap::Unwrap<VtkViewportWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->RenderOpaqueGeometry(
			(vtkViewport *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::RenderOverlay(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkViewportWrap::ptpl))->HasInstance(info[0]))
	{
		VtkViewportWrap *a0 = ObjectWrap::Unwrap<VtkViewportWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->RenderOverlay(
			(vtkViewport *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::RenderTranslucentGeometry(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkViewportWrap::ptpl))->HasInstance(info[0]))
	{
		VtkViewportWrap *a0 = ObjectWrap::Unwrap<VtkViewportWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->RenderTranslucentGeometry(
			(vtkViewport *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::RenderTranslucentPolygonalGeometry(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkViewportWrap::ptpl))->HasInstance(info[0]))
	{
		VtkViewportWrap *a0 = ObjectWrap::Unwrap<VtkViewportWrap>(info[0]->ToObject());
		int r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->RenderTranslucentPolygonalGeometry(
			(vtkViewport *) a0->native.GetPointer()
		);
		info.GetReturnValue().Set(Nan::New(r));
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectWrap *a0 = ObjectWrap::Unwrap<VtkObjectWrap>(info[0]->ToObject());
		vtkCubeAxesActor * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObject *) a0->native.GetPointer()
		);
			VtkCubeAxesActorWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkCubeAxesActorWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkCubeAxesActorWrap *w = new VtkCubeAxesActorWrap();
		w->native.TakeReference(r);
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetAxisBaseForX(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetAxisBaseForX(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetAxisBaseForY(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetAxisBaseForY(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetAxisBaseForZ(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetAxisBaseForZ(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetAxisLabels(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkStringArrayWrap::ptpl))->HasInstance(info[1]))
		{
			VtkStringArrayWrap *a1 = ObjectWrap::Unwrap<VtkStringArrayWrap>(info[1]->ToObject());
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetAxisLabels(
				info[0]->Int32Value(),
				(vtkStringArray *) a1->native.GetPointer()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetAxisOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() != 3)
				{
					Nan::ThrowError("Too many parameters.");
					return;
				}
				native->SetAxisOrigin(
					info[0]->NumberValue(),
					info[1]->NumberValue(),
					info[2]->NumberValue()
				);
				return;
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetBounds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() > 3 && info[3]->IsNumber())
				{
					if(info.Length() > 4 && info[4]->IsNumber())
					{
						if(info.Length() > 5 && info[5]->IsNumber())
						{
							if(info.Length() != 6)
							{
								Nan::ThrowError("Too many parameters.");
								return;
							}
							native->SetBounds(
								info[0]->NumberValue(),
								info[1]->NumberValue(),
								info[2]->NumberValue(),
								info[3]->NumberValue(),
								info[4]->NumberValue(),
								info[5]->NumberValue()
							);
							return;
						}
					}
				}
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetCamera(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkCameraWrap::ptpl))->HasInstance(info[0]))
	{
		VtkCameraWrap *a0 = ObjectWrap::Unwrap<VtkCameraWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetCamera(
			(vtkCamera *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetCenterStickyAxes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetCenterStickyAxes(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetCornerOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetCornerOffset(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDistanceLODThreshold(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDistanceLODThreshold(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawXGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawXGridlines(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawXGridpolys(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawXGridpolys(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawXInnerGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawXInnerGridlines(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawYGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawYGridlines(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawYGridpolys(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawYGridpolys(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawYInnerGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawYInnerGridlines(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawZGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawZGridlines(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawZGridpolys(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawZGridpolys(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetDrawZInnerGridlines(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDrawZInnerGridlines(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetEnableDistanceLOD(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEnableDistanceLOD(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetEnableViewAngleLOD(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEnableViewAngleLOD(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetFlyMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFlyMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetFlyModeToClosestTriad(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFlyModeToClosestTriad();
}

void VtkCubeAxesActorWrap::SetFlyModeToFurthestTriad(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFlyModeToFurthestTriad();
}

void VtkCubeAxesActorWrap::SetFlyModeToOuterEdges(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFlyModeToOuterEdges();
}

void VtkCubeAxesActorWrap::SetFlyModeToStaticEdges(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFlyModeToStaticEdges();
}

void VtkCubeAxesActorWrap::SetFlyModeToStaticTriad(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetFlyModeToStaticTriad();
}

void VtkCubeAxesActorWrap::SetGridLineLocation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGridLineLocation(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetInertia(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetInertia(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetLabelOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetLabelOffset(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetOrientedBounds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() > 2 && info[2]->IsNumber())
			{
				if(info.Length() > 3 && info[3]->IsNumber())
				{
					if(info.Length() > 4 && info[4]->IsNumber())
					{
						if(info.Length() > 5 && info[5]->IsNumber())
						{
							if(info.Length() != 6)
							{
								Nan::ThrowError("Too many parameters.");
								return;
							}
							native->SetOrientedBounds(
								info[0]->NumberValue(),
								info[1]->NumberValue(),
								info[2]->NumberValue(),
								info[3]->NumberValue(),
								info[4]->NumberValue(),
								info[5]->NumberValue()
							);
							return;
						}
					}
				}
			}
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetSaveTitlePosition(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSaveTitlePosition(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetScreenSize(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScreenSize(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetStickyAxes(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStickyAxes(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetTickLocation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTickLocation(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetTickLocationToBoth(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetTickLocationToBoth();
}

void VtkCubeAxesActorWrap::SetTickLocationToInside(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetTickLocationToInside();
}

void VtkCubeAxesActorWrap::SetTickLocationToOutside(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetTickLocationToOutside();
}

void VtkCubeAxesActorWrap::SetTitleOffset(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetTitleOffset(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetUse2DMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUse2DMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetUseAxisOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseAxisOrigin(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetUseOrientedBounds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseOrientedBounds(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetUseTextActor3D(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseTextActor3D(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetViewAngleLODThreshold(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetViewAngleLODThreshold(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxesGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXAxesGridlinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxesGridpolysProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXAxesGridpolysProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxesInnerGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXAxesInnerGridlinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxesLinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXAxesLinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxisLabelVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXAxisLabelVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxisMinorTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXAxisMinorTickVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxisRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetXAxisRange(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxisTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXAxisTickVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXAxisVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXAxisVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXLabelFormat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXLabelFormat(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXTitle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXTitle(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetXUnits(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetXUnits(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxesGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYAxesGridlinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxesGridpolysProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYAxesGridpolysProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxesInnerGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYAxesInnerGridlinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxesLinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYAxesLinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxisLabelVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYAxisLabelVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxisMinorTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYAxisMinorTickVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxisRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetYAxisRange(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxisTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYAxisTickVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYAxisVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYAxisVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYLabelFormat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYLabelFormat(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYTitle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYTitle(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetYUnits(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetYUnits(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxesGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZAxesGridlinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxesGridpolysProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZAxesGridpolysProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxesInnerGridlinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZAxesInnerGridlinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxesLinesProperty(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPropertyWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPropertyWrap *a0 = ObjectWrap::Unwrap<VtkPropertyWrap>(info[0]->ToObject());
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZAxesLinesProperty(
			(vtkProperty *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxisLabelVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZAxisLabelVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxisMinorTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZAxisMinorTickVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxisRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetZAxisRange(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxisTickVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZAxisTickVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZAxisVisibility(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZAxisVisibility(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZLabelFormat(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZLabelFormat(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZTitle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZTitle(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::SetZUnits(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		Nan::Utf8String a0(info[0]);
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetZUnits(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkCubeAxesActorWrap::StickyAxesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StickyAxesOff();
}

void VtkCubeAxesActorWrap::StickyAxesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StickyAxesOn();
}

void VtkCubeAxesActorWrap::XAxisLabelVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->XAxisLabelVisibilityOff();
}

void VtkCubeAxesActorWrap::XAxisLabelVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->XAxisLabelVisibilityOn();
}

void VtkCubeAxesActorWrap::XAxisMinorTickVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->XAxisMinorTickVisibilityOff();
}

void VtkCubeAxesActorWrap::XAxisMinorTickVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->XAxisMinorTickVisibilityOn();
}

void VtkCubeAxesActorWrap::XAxisTickVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->XAxisTickVisibilityOff();
}

void VtkCubeAxesActorWrap::XAxisTickVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->XAxisTickVisibilityOn();
}

void VtkCubeAxesActorWrap::XAxisVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->XAxisVisibilityOff();
}

void VtkCubeAxesActorWrap::XAxisVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->XAxisVisibilityOn();
}

void VtkCubeAxesActorWrap::YAxisLabelVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->YAxisLabelVisibilityOff();
}

void VtkCubeAxesActorWrap::YAxisLabelVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->YAxisLabelVisibilityOn();
}

void VtkCubeAxesActorWrap::YAxisMinorTickVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->YAxisMinorTickVisibilityOff();
}

void VtkCubeAxesActorWrap::YAxisMinorTickVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->YAxisMinorTickVisibilityOn();
}

void VtkCubeAxesActorWrap::YAxisTickVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->YAxisTickVisibilityOff();
}

void VtkCubeAxesActorWrap::YAxisTickVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->YAxisTickVisibilityOn();
}

void VtkCubeAxesActorWrap::YAxisVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->YAxisVisibilityOff();
}

void VtkCubeAxesActorWrap::YAxisVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->YAxisVisibilityOn();
}

void VtkCubeAxesActorWrap::ZAxisLabelVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ZAxisLabelVisibilityOff();
}

void VtkCubeAxesActorWrap::ZAxisLabelVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ZAxisLabelVisibilityOn();
}

void VtkCubeAxesActorWrap::ZAxisMinorTickVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ZAxisMinorTickVisibilityOff();
}

void VtkCubeAxesActorWrap::ZAxisMinorTickVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ZAxisMinorTickVisibilityOn();
}

void VtkCubeAxesActorWrap::ZAxisTickVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ZAxisTickVisibilityOff();
}

void VtkCubeAxesActorWrap::ZAxisTickVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ZAxisTickVisibilityOn();
}

void VtkCubeAxesActorWrap::ZAxisVisibilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ZAxisVisibilityOff();
}

void VtkCubeAxesActorWrap::ZAxisVisibilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkCubeAxesActorWrap *wrapper = ObjectWrap::Unwrap<VtkCubeAxesActorWrap>(info.Holder());
	vtkCubeAxesActor *native = (vtkCubeAxesActor *)wrapper->native.GetPointer();
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ZAxisVisibilityOn();
}

