/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include "vtkGraphAlgorithmWrap.h"
#include "vtkRandomGraphSourceWrap.h"
#include "vtkObjectBaseWrap.h"
#include "../../plus/plus.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkRandomGraphSourceWrap::ptpl;

VtkRandomGraphSourceWrap::VtkRandomGraphSourceWrap()
{ }

VtkRandomGraphSourceWrap::VtkRandomGraphSourceWrap(vtkSmartPointer<vtkRandomGraphSource> _native)
{ native = _native; }

VtkRandomGraphSourceWrap::~VtkRandomGraphSourceWrap()
{ }

void VtkRandomGraphSourceWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkRandomGraphSource").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("RandomGraphSource").ToLocalChecked(), ConstructorGetter);
}

void VtkRandomGraphSourceWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkRandomGraphSourceWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkGraphAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkGraphAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkRandomGraphSourceWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AllowParallelEdgesOff", AllowParallelEdgesOff);
	Nan::SetPrototypeMethod(tpl, "allowParallelEdgesOff", AllowParallelEdgesOff);

	Nan::SetPrototypeMethod(tpl, "AllowParallelEdgesOn", AllowParallelEdgesOn);
	Nan::SetPrototypeMethod(tpl, "allowParallelEdgesOn", AllowParallelEdgesOn);

	Nan::SetPrototypeMethod(tpl, "AllowSelfLoopsOff", AllowSelfLoopsOff);
	Nan::SetPrototypeMethod(tpl, "allowSelfLoopsOff", AllowSelfLoopsOff);

	Nan::SetPrototypeMethod(tpl, "AllowSelfLoopsOn", AllowSelfLoopsOn);
	Nan::SetPrototypeMethod(tpl, "allowSelfLoopsOn", AllowSelfLoopsOn);

	Nan::SetPrototypeMethod(tpl, "DirectedOff", DirectedOff);
	Nan::SetPrototypeMethod(tpl, "directedOff", DirectedOff);

	Nan::SetPrototypeMethod(tpl, "DirectedOn", DirectedOn);
	Nan::SetPrototypeMethod(tpl, "directedOn", DirectedOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePedigreeIdsOff", GeneratePedigreeIdsOff);
	Nan::SetPrototypeMethod(tpl, "generatePedigreeIdsOff", GeneratePedigreeIdsOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePedigreeIdsOn", GeneratePedigreeIdsOn);
	Nan::SetPrototypeMethod(tpl, "generatePedigreeIdsOn", GeneratePedigreeIdsOn);

	Nan::SetPrototypeMethod(tpl, "GetAllowParallelEdges", GetAllowParallelEdges);
	Nan::SetPrototypeMethod(tpl, "getAllowParallelEdges", GetAllowParallelEdges);

	Nan::SetPrototypeMethod(tpl, "GetAllowSelfLoops", GetAllowSelfLoops);
	Nan::SetPrototypeMethod(tpl, "getAllowSelfLoops", GetAllowSelfLoops);

	Nan::SetPrototypeMethod(tpl, "GetDirected", GetDirected);
	Nan::SetPrototypeMethod(tpl, "getDirected", GetDirected);

	Nan::SetPrototypeMethod(tpl, "GetEdgePedigreeIdArrayName", GetEdgePedigreeIdArrayName);
	Nan::SetPrototypeMethod(tpl, "getEdgePedigreeIdArrayName", GetEdgePedigreeIdArrayName);

	Nan::SetPrototypeMethod(tpl, "GetEdgeProbability", GetEdgeProbability);
	Nan::SetPrototypeMethod(tpl, "getEdgeProbability", GetEdgeProbability);

	Nan::SetPrototypeMethod(tpl, "GetEdgeProbabilityMaxValue", GetEdgeProbabilityMaxValue);
	Nan::SetPrototypeMethod(tpl, "getEdgeProbabilityMaxValue", GetEdgeProbabilityMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetEdgeProbabilityMinValue", GetEdgeProbabilityMinValue);
	Nan::SetPrototypeMethod(tpl, "getEdgeProbabilityMinValue", GetEdgeProbabilityMinValue);

	Nan::SetPrototypeMethod(tpl, "GetEdgeWeightArrayName", GetEdgeWeightArrayName);
	Nan::SetPrototypeMethod(tpl, "getEdgeWeightArrayName", GetEdgeWeightArrayName);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePedigreeIds", GetGeneratePedigreeIds);
	Nan::SetPrototypeMethod(tpl, "getGeneratePedigreeIds", GetGeneratePedigreeIds);

	Nan::SetPrototypeMethod(tpl, "GetIncludeEdgeWeights", GetIncludeEdgeWeights);
	Nan::SetPrototypeMethod(tpl, "getIncludeEdgeWeights", GetIncludeEdgeWeights);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfEdges", GetNumberOfEdges);
	Nan::SetPrototypeMethod(tpl, "getNumberOfEdges", GetNumberOfEdges);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfEdgesMaxValue", GetNumberOfEdgesMaxValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfEdgesMaxValue", GetNumberOfEdgesMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfEdgesMinValue", GetNumberOfEdgesMinValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfEdgesMinValue", GetNumberOfEdgesMinValue);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfVertices", GetNumberOfVertices);
	Nan::SetPrototypeMethod(tpl, "getNumberOfVertices", GetNumberOfVertices);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfVerticesMaxValue", GetNumberOfVerticesMaxValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfVerticesMaxValue", GetNumberOfVerticesMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfVerticesMinValue", GetNumberOfVerticesMinValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfVerticesMinValue", GetNumberOfVerticesMinValue);

	Nan::SetPrototypeMethod(tpl, "GetSeed", GetSeed);
	Nan::SetPrototypeMethod(tpl, "getSeed", GetSeed);

	Nan::SetPrototypeMethod(tpl, "GetStartWithTree", GetStartWithTree);
	Nan::SetPrototypeMethod(tpl, "getStartWithTree", GetStartWithTree);

	Nan::SetPrototypeMethod(tpl, "GetUseEdgeProbability", GetUseEdgeProbability);
	Nan::SetPrototypeMethod(tpl, "getUseEdgeProbability", GetUseEdgeProbability);

	Nan::SetPrototypeMethod(tpl, "GetVertexPedigreeIdArrayName", GetVertexPedigreeIdArrayName);
	Nan::SetPrototypeMethod(tpl, "getVertexPedigreeIdArrayName", GetVertexPedigreeIdArrayName);

	Nan::SetPrototypeMethod(tpl, "IncludeEdgeWeightsOff", IncludeEdgeWeightsOff);
	Nan::SetPrototypeMethod(tpl, "includeEdgeWeightsOff", IncludeEdgeWeightsOff);

	Nan::SetPrototypeMethod(tpl, "IncludeEdgeWeightsOn", IncludeEdgeWeightsOn);
	Nan::SetPrototypeMethod(tpl, "includeEdgeWeightsOn", IncludeEdgeWeightsOn);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetAllowParallelEdges", SetAllowParallelEdges);
	Nan::SetPrototypeMethod(tpl, "setAllowParallelEdges", SetAllowParallelEdges);

	Nan::SetPrototypeMethod(tpl, "SetAllowSelfLoops", SetAllowSelfLoops);
	Nan::SetPrototypeMethod(tpl, "setAllowSelfLoops", SetAllowSelfLoops);

	Nan::SetPrototypeMethod(tpl, "SetDirected", SetDirected);
	Nan::SetPrototypeMethod(tpl, "setDirected", SetDirected);

	Nan::SetPrototypeMethod(tpl, "SetEdgePedigreeIdArrayName", SetEdgePedigreeIdArrayName);
	Nan::SetPrototypeMethod(tpl, "setEdgePedigreeIdArrayName", SetEdgePedigreeIdArrayName);

	Nan::SetPrototypeMethod(tpl, "SetEdgeProbability", SetEdgeProbability);
	Nan::SetPrototypeMethod(tpl, "setEdgeProbability", SetEdgeProbability);

	Nan::SetPrototypeMethod(tpl, "SetEdgeWeightArrayName", SetEdgeWeightArrayName);
	Nan::SetPrototypeMethod(tpl, "setEdgeWeightArrayName", SetEdgeWeightArrayName);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePedigreeIds", SetGeneratePedigreeIds);
	Nan::SetPrototypeMethod(tpl, "setGeneratePedigreeIds", SetGeneratePedigreeIds);

	Nan::SetPrototypeMethod(tpl, "SetIncludeEdgeWeights", SetIncludeEdgeWeights);
	Nan::SetPrototypeMethod(tpl, "setIncludeEdgeWeights", SetIncludeEdgeWeights);

	Nan::SetPrototypeMethod(tpl, "SetNumberOfEdges", SetNumberOfEdges);
	Nan::SetPrototypeMethod(tpl, "setNumberOfEdges", SetNumberOfEdges);

	Nan::SetPrototypeMethod(tpl, "SetNumberOfVertices", SetNumberOfVertices);
	Nan::SetPrototypeMethod(tpl, "setNumberOfVertices", SetNumberOfVertices);

	Nan::SetPrototypeMethod(tpl, "SetSeed", SetSeed);
	Nan::SetPrototypeMethod(tpl, "setSeed", SetSeed);

	Nan::SetPrototypeMethod(tpl, "SetStartWithTree", SetStartWithTree);
	Nan::SetPrototypeMethod(tpl, "setStartWithTree", SetStartWithTree);

	Nan::SetPrototypeMethod(tpl, "SetUseEdgeProbability", SetUseEdgeProbability);
	Nan::SetPrototypeMethod(tpl, "setUseEdgeProbability", SetUseEdgeProbability);

	Nan::SetPrototypeMethod(tpl, "SetVertexPedigreeIdArrayName", SetVertexPedigreeIdArrayName);
	Nan::SetPrototypeMethod(tpl, "setVertexPedigreeIdArrayName", SetVertexPedigreeIdArrayName);

	Nan::SetPrototypeMethod(tpl, "StartWithTreeOff", StartWithTreeOff);
	Nan::SetPrototypeMethod(tpl, "startWithTreeOff", StartWithTreeOff);

	Nan::SetPrototypeMethod(tpl, "StartWithTreeOn", StartWithTreeOn);
	Nan::SetPrototypeMethod(tpl, "startWithTreeOn", StartWithTreeOn);

	Nan::SetPrototypeMethod(tpl, "UseEdgeProbabilityOff", UseEdgeProbabilityOff);
	Nan::SetPrototypeMethod(tpl, "useEdgeProbabilityOff", UseEdgeProbabilityOff);

	Nan::SetPrototypeMethod(tpl, "UseEdgeProbabilityOn", UseEdgeProbabilityOn);
	Nan::SetPrototypeMethod(tpl, "useEdgeProbabilityOn", UseEdgeProbabilityOn);

#ifdef VTK_NODE_PLUS_VTKRANDOMGRAPHSOURCEWRAP_INITPTPL
	VTK_NODE_PLUS_VTKRANDOMGRAPHSOURCEWRAP_INITPTPL
#endif
	ptpl.Reset( tpl );
}

void VtkRandomGraphSourceWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkRandomGraphSource> native = vtkSmartPointer<vtkRandomGraphSource>::New();
		VtkRandomGraphSourceWrap* obj = new VtkRandomGraphSourceWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkRandomGraphSourceWrap::AllowParallelEdgesOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AllowParallelEdgesOff();
}

void VtkRandomGraphSourceWrap::AllowParallelEdgesOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AllowParallelEdgesOn();
}

void VtkRandomGraphSourceWrap::AllowSelfLoopsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AllowSelfLoopsOff();
}

void VtkRandomGraphSourceWrap::AllowSelfLoopsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AllowSelfLoopsOn();
}

void VtkRandomGraphSourceWrap::DirectedOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DirectedOff();
}

void VtkRandomGraphSourceWrap::DirectedOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->DirectedOn();
}

void VtkRandomGraphSourceWrap::GeneratePedigreeIdsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePedigreeIdsOff();
}

void VtkRandomGraphSourceWrap::GeneratePedigreeIdsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePedigreeIdsOn();
}

void VtkRandomGraphSourceWrap::GetAllowParallelEdges(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAllowParallelEdges();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetAllowSelfLoops(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAllowSelfLoops();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetDirected(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetDirected();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetEdgePedigreeIdArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgePedigreeIdArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkRandomGraphSourceWrap::GetEdgeProbability(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeProbability();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetEdgeProbabilityMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeProbabilityMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetEdgeProbabilityMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeProbabilityMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetEdgeWeightArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeWeightArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkRandomGraphSourceWrap::GetGeneratePedigreeIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePedigreeIds();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetIncludeEdgeWeights(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIncludeEdgeWeights();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetNumberOfEdges(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfEdges();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetNumberOfEdgesMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfEdgesMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetNumberOfEdgesMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfEdgesMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetNumberOfVertices(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfVertices();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetNumberOfVerticesMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfVerticesMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetNumberOfVerticesMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfVerticesMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetSeed(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSeed();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetStartWithTree(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStartWithTree();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetUseEdgeProbability(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseEdgeProbability();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkRandomGraphSourceWrap::GetVertexPedigreeIdArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVertexPedigreeIdArrayName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkRandomGraphSourceWrap::IncludeEdgeWeightsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->IncludeEdgeWeightsOff();
}

void VtkRandomGraphSourceWrap::IncludeEdgeWeightsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->IncludeEdgeWeightsOn();
}

void VtkRandomGraphSourceWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	vtkRandomGraphSource * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	VtkRandomGraphSourceWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkRandomGraphSourceWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkRandomGraphSourceWrap *w = new VtkRandomGraphSourceWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkRandomGraphSourceWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectBaseWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectBaseWrap *a0 = ObjectWrap::Unwrap<VtkObjectBaseWrap>(info[0]->ToObject());
		vtkRandomGraphSource * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObjectBase *) a0->native.GetPointer()
		);
		VtkRandomGraphSourceWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkRandomGraphSourceWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkRandomGraphSourceWrap *w = new VtkRandomGraphSourceWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetAllowParallelEdges(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAllowParallelEdges(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetAllowSelfLoops(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAllowSelfLoops(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetDirected(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetDirected(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetEdgePedigreeIdArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEdgePedigreeIdArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetEdgeProbability(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEdgeProbability(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetEdgeWeightArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEdgeWeightArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetGeneratePedigreeIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePedigreeIds(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetIncludeEdgeWeights(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIncludeEdgeWeights(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetNumberOfEdges(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetNumberOfEdges(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetNumberOfVertices(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetNumberOfVertices(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetSeed(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSeed(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetStartWithTree(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStartWithTree(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetUseEdgeProbability(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseEdgeProbability(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::SetVertexPedigreeIdArrayName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetVertexPedigreeIdArrayName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkRandomGraphSourceWrap::StartWithTreeOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StartWithTreeOff();
}

void VtkRandomGraphSourceWrap::StartWithTreeOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->StartWithTreeOn();
}

void VtkRandomGraphSourceWrap::UseEdgeProbabilityOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseEdgeProbabilityOff();
}

void VtkRandomGraphSourceWrap::UseEdgeProbabilityOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkRandomGraphSourceWrap *wrapper = ObjectWrap::Unwrap<VtkRandomGraphSourceWrap>(info.Holder());
	vtkRandomGraphSource *native = (vtkRandomGraphSource *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseEdgeProbabilityOn();
}

