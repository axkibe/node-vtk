/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include "vtkPolyDataAlgorithmWrap.h"
#include "vtkGlyph3DWrap.h"
#include "vtkObjectBaseWrap.h"
#include "vtkPolyDataWrap.h"
#include "vtkAlgorithmOutputWrap.h"
#include "vtkTransformWrap.h"
#include "../../plus/plus.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkGlyph3DWrap::ptpl;

VtkGlyph3DWrap::VtkGlyph3DWrap()
{ }

VtkGlyph3DWrap::VtkGlyph3DWrap(vtkSmartPointer<vtkGlyph3D> _native)
{ native = _native; }

VtkGlyph3DWrap::~VtkGlyph3DWrap()
{ }

void VtkGlyph3DWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkGlyph3D").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("Glyph3D").ToLocalChecked(), ConstructorGetter);
}

void VtkGlyph3DWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkGlyph3DWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkPolyDataAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkPolyDataAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkGlyph3DWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "ClampingOff", ClampingOff);
	Nan::SetPrototypeMethod(tpl, "clampingOff", ClampingOff);

	Nan::SetPrototypeMethod(tpl, "ClampingOn", ClampingOn);
	Nan::SetPrototypeMethod(tpl, "clampingOn", ClampingOn);

	Nan::SetPrototypeMethod(tpl, "FillCellDataOff", FillCellDataOff);
	Nan::SetPrototypeMethod(tpl, "fillCellDataOff", FillCellDataOff);

	Nan::SetPrototypeMethod(tpl, "FillCellDataOn", FillCellDataOn);
	Nan::SetPrototypeMethod(tpl, "fillCellDataOn", FillCellDataOn);

	Nan::SetPrototypeMethod(tpl, "GeneratePointIdsOff", GeneratePointIdsOff);
	Nan::SetPrototypeMethod(tpl, "generatePointIdsOff", GeneratePointIdsOff);

	Nan::SetPrototypeMethod(tpl, "GeneratePointIdsOn", GeneratePointIdsOn);
	Nan::SetPrototypeMethod(tpl, "generatePointIdsOn", GeneratePointIdsOn);

	Nan::SetPrototypeMethod(tpl, "GetClamping", GetClamping);
	Nan::SetPrototypeMethod(tpl, "getClamping", GetClamping);

	Nan::SetPrototypeMethod(tpl, "GetColorMode", GetColorMode);
	Nan::SetPrototypeMethod(tpl, "getColorMode", GetColorMode);

	Nan::SetPrototypeMethod(tpl, "GetColorModeAsString", GetColorModeAsString);
	Nan::SetPrototypeMethod(tpl, "getColorModeAsString", GetColorModeAsString);

	Nan::SetPrototypeMethod(tpl, "GetFillCellData", GetFillCellData);
	Nan::SetPrototypeMethod(tpl, "getFillCellData", GetFillCellData);

	Nan::SetPrototypeMethod(tpl, "GetGeneratePointIds", GetGeneratePointIds);
	Nan::SetPrototypeMethod(tpl, "getGeneratePointIds", GetGeneratePointIds);

	Nan::SetPrototypeMethod(tpl, "GetIndexMode", GetIndexMode);
	Nan::SetPrototypeMethod(tpl, "getIndexMode", GetIndexMode);

	Nan::SetPrototypeMethod(tpl, "GetIndexModeAsString", GetIndexModeAsString);
	Nan::SetPrototypeMethod(tpl, "getIndexModeAsString", GetIndexModeAsString);

	Nan::SetPrototypeMethod(tpl, "GetOrient", GetOrient);
	Nan::SetPrototypeMethod(tpl, "getOrient", GetOrient);

	Nan::SetPrototypeMethod(tpl, "GetOutputPointsPrecision", GetOutputPointsPrecision);
	Nan::SetPrototypeMethod(tpl, "getOutputPointsPrecision", GetOutputPointsPrecision);

	Nan::SetPrototypeMethod(tpl, "GetPointIdsName", GetPointIdsName);
	Nan::SetPrototypeMethod(tpl, "getPointIdsName", GetPointIdsName);

	Nan::SetPrototypeMethod(tpl, "GetRange", GetRange);
	Nan::SetPrototypeMethod(tpl, "getRange", GetRange);

	Nan::SetPrototypeMethod(tpl, "GetScaleFactor", GetScaleFactor);
	Nan::SetPrototypeMethod(tpl, "getScaleFactor", GetScaleFactor);

	Nan::SetPrototypeMethod(tpl, "GetScaleMode", GetScaleMode);
	Nan::SetPrototypeMethod(tpl, "getScaleMode", GetScaleMode);

	Nan::SetPrototypeMethod(tpl, "GetScaleModeAsString", GetScaleModeAsString);
	Nan::SetPrototypeMethod(tpl, "getScaleModeAsString", GetScaleModeAsString);

	Nan::SetPrototypeMethod(tpl, "GetScaling", GetScaling);
	Nan::SetPrototypeMethod(tpl, "getScaling", GetScaling);

	Nan::SetPrototypeMethod(tpl, "GetSource", GetSource);
	Nan::SetPrototypeMethod(tpl, "getSource", GetSource);

	Nan::SetPrototypeMethod(tpl, "GetSourceTransform", GetSourceTransform);
	Nan::SetPrototypeMethod(tpl, "getSourceTransform", GetSourceTransform);

	Nan::SetPrototypeMethod(tpl, "GetVectorMode", GetVectorMode);
	Nan::SetPrototypeMethod(tpl, "getVectorMode", GetVectorMode);

	Nan::SetPrototypeMethod(tpl, "GetVectorModeAsString", GetVectorModeAsString);
	Nan::SetPrototypeMethod(tpl, "getVectorModeAsString", GetVectorModeAsString);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "OrientOff", OrientOff);
	Nan::SetPrototypeMethod(tpl, "orientOff", OrientOff);

	Nan::SetPrototypeMethod(tpl, "OrientOn", OrientOn);
	Nan::SetPrototypeMethod(tpl, "orientOn", OrientOn);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "ScalingOff", ScalingOff);
	Nan::SetPrototypeMethod(tpl, "scalingOff", ScalingOff);

	Nan::SetPrototypeMethod(tpl, "ScalingOn", ScalingOn);
	Nan::SetPrototypeMethod(tpl, "scalingOn", ScalingOn);

	Nan::SetPrototypeMethod(tpl, "SetClamping", SetClamping);
	Nan::SetPrototypeMethod(tpl, "setClamping", SetClamping);

	Nan::SetPrototypeMethod(tpl, "SetColorMode", SetColorMode);
	Nan::SetPrototypeMethod(tpl, "setColorMode", SetColorMode);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToColorByScalar", SetColorModeToColorByScalar);
	Nan::SetPrototypeMethod(tpl, "setColorModeToColorByScalar", SetColorModeToColorByScalar);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToColorByScale", SetColorModeToColorByScale);
	Nan::SetPrototypeMethod(tpl, "setColorModeToColorByScale", SetColorModeToColorByScale);

	Nan::SetPrototypeMethod(tpl, "SetColorModeToColorByVector", SetColorModeToColorByVector);
	Nan::SetPrototypeMethod(tpl, "setColorModeToColorByVector", SetColorModeToColorByVector);

	Nan::SetPrototypeMethod(tpl, "SetFillCellData", SetFillCellData);
	Nan::SetPrototypeMethod(tpl, "setFillCellData", SetFillCellData);

	Nan::SetPrototypeMethod(tpl, "SetGeneratePointIds", SetGeneratePointIds);
	Nan::SetPrototypeMethod(tpl, "setGeneratePointIds", SetGeneratePointIds);

	Nan::SetPrototypeMethod(tpl, "SetIndexMode", SetIndexMode);
	Nan::SetPrototypeMethod(tpl, "setIndexMode", SetIndexMode);

	Nan::SetPrototypeMethod(tpl, "SetIndexModeToOff", SetIndexModeToOff);
	Nan::SetPrototypeMethod(tpl, "setIndexModeToOff", SetIndexModeToOff);

	Nan::SetPrototypeMethod(tpl, "SetIndexModeToScalar", SetIndexModeToScalar);
	Nan::SetPrototypeMethod(tpl, "setIndexModeToScalar", SetIndexModeToScalar);

	Nan::SetPrototypeMethod(tpl, "SetIndexModeToVector", SetIndexModeToVector);
	Nan::SetPrototypeMethod(tpl, "setIndexModeToVector", SetIndexModeToVector);

	Nan::SetPrototypeMethod(tpl, "SetOrient", SetOrient);
	Nan::SetPrototypeMethod(tpl, "setOrient", SetOrient);

	Nan::SetPrototypeMethod(tpl, "SetOutputPointsPrecision", SetOutputPointsPrecision);
	Nan::SetPrototypeMethod(tpl, "setOutputPointsPrecision", SetOutputPointsPrecision);

	Nan::SetPrototypeMethod(tpl, "SetPointIdsName", SetPointIdsName);
	Nan::SetPrototypeMethod(tpl, "setPointIdsName", SetPointIdsName);

	Nan::SetPrototypeMethod(tpl, "SetRange", SetRange);
	Nan::SetPrototypeMethod(tpl, "setRange", SetRange);

	Nan::SetPrototypeMethod(tpl, "SetScaleFactor", SetScaleFactor);
	Nan::SetPrototypeMethod(tpl, "setScaleFactor", SetScaleFactor);

	Nan::SetPrototypeMethod(tpl, "SetScaleMode", SetScaleMode);
	Nan::SetPrototypeMethod(tpl, "setScaleMode", SetScaleMode);

	Nan::SetPrototypeMethod(tpl, "SetScaleModeToDataScalingOff", SetScaleModeToDataScalingOff);
	Nan::SetPrototypeMethod(tpl, "setScaleModeToDataScalingOff", SetScaleModeToDataScalingOff);

	Nan::SetPrototypeMethod(tpl, "SetScaleModeToScaleByScalar", SetScaleModeToScaleByScalar);
	Nan::SetPrototypeMethod(tpl, "setScaleModeToScaleByScalar", SetScaleModeToScaleByScalar);

	Nan::SetPrototypeMethod(tpl, "SetScaleModeToScaleByVector", SetScaleModeToScaleByVector);
	Nan::SetPrototypeMethod(tpl, "setScaleModeToScaleByVector", SetScaleModeToScaleByVector);

	Nan::SetPrototypeMethod(tpl, "SetScaleModeToScaleByVectorComponents", SetScaleModeToScaleByVectorComponents);
	Nan::SetPrototypeMethod(tpl, "setScaleModeToScaleByVectorComponents", SetScaleModeToScaleByVectorComponents);

	Nan::SetPrototypeMethod(tpl, "SetScaling", SetScaling);
	Nan::SetPrototypeMethod(tpl, "setScaling", SetScaling);

	Nan::SetPrototypeMethod(tpl, "SetSourceConnection", SetSourceConnection);
	Nan::SetPrototypeMethod(tpl, "setSourceConnection", SetSourceConnection);

	Nan::SetPrototypeMethod(tpl, "SetSourceData", SetSourceData);
	Nan::SetPrototypeMethod(tpl, "setSourceData", SetSourceData);

	Nan::SetPrototypeMethod(tpl, "SetSourceTransform", SetSourceTransform);
	Nan::SetPrototypeMethod(tpl, "setSourceTransform", SetSourceTransform);

	Nan::SetPrototypeMethod(tpl, "SetVectorMode", SetVectorMode);
	Nan::SetPrototypeMethod(tpl, "setVectorMode", SetVectorMode);

	Nan::SetPrototypeMethod(tpl, "SetVectorModeToUseNormal", SetVectorModeToUseNormal);
	Nan::SetPrototypeMethod(tpl, "setVectorModeToUseNormal", SetVectorModeToUseNormal);

	Nan::SetPrototypeMethod(tpl, "SetVectorModeToUseVector", SetVectorModeToUseVector);
	Nan::SetPrototypeMethod(tpl, "setVectorModeToUseVector", SetVectorModeToUseVector);

	Nan::SetPrototypeMethod(tpl, "SetVectorModeToVectorRotationOff", SetVectorModeToVectorRotationOff);
	Nan::SetPrototypeMethod(tpl, "setVectorModeToVectorRotationOff", SetVectorModeToVectorRotationOff);

#ifdef VTK_NODE_PLUS_VTKGLYPH3DWRAP_INITPTPL
	VTK_NODE_PLUS_VTKGLYPH3DWRAP_INITPTPL
#endif
	ptpl.Reset( tpl );
}

void VtkGlyph3DWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkGlyph3D> native = vtkSmartPointer<vtkGlyph3D>::New();
		VtkGlyph3DWrap* obj = new VtkGlyph3DWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkGlyph3DWrap::ClampingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClampingOff();
}

void VtkGlyph3DWrap::ClampingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ClampingOn();
}

void VtkGlyph3DWrap::FillCellDataOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FillCellDataOff();
}

void VtkGlyph3DWrap::FillCellDataOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FillCellDataOn();
}

void VtkGlyph3DWrap::GeneratePointIdsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointIdsOff();
}

void VtkGlyph3DWrap::GeneratePointIdsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GeneratePointIdsOn();
}

void VtkGlyph3DWrap::GetClamping(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetClamping();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetColorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetColorModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetColorModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGlyph3DWrap::GetFillCellData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFillCellData();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetGeneratePointIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGeneratePointIds();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetIndexMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIndexMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetIndexModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIndexModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGlyph3DWrap::GetOrient(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOrient();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetOutputPointsPrecision(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOutputPointsPrecision();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetPointIdsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetPointIdsName();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGlyph3DWrap::GetRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	double const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRange();
	Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(v8::Isolate::GetCurrent(), 2 * sizeof(double));
	Local<v8::Float64Array> at = v8::Float64Array::New(ab, 0, 2);
	memcpy(ab->GetContents().Data(), r, 2 * sizeof(double));
	info.GetReturnValue().Set(at);
}

void VtkGlyph3DWrap::GetScaleFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaleFactor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetScaleMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaleMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetScaleModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaleModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGlyph3DWrap::GetScaling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetScaling();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetSource(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		vtkPolyData * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->GetSource(
			info[0]->Int32Value()
		);
		VtkPolyDataWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkPolyDataWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkPolyDataWrap *w = new VtkPolyDataWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::GetSourceTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	vtkTransform * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSourceTransform();
	VtkTransformWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkTransformWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkTransformWrap *w = new VtkTransformWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkGlyph3DWrap::GetVectorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVectorMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkGlyph3DWrap::GetVectorModeAsString(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	char const * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetVectorModeAsString();
	info.GetReturnValue().Set(Nan::New(r).ToLocalChecked());
}

void VtkGlyph3DWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	vtkGlyph3D * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	VtkGlyph3DWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkGlyph3DWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkGlyph3DWrap *w = new VtkGlyph3DWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkGlyph3DWrap::OrientOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OrientOff();
}

void VtkGlyph3DWrap::OrientOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->OrientOn();
}

void VtkGlyph3DWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectBaseWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectBaseWrap *a0 = ObjectWrap::Unwrap<VtkObjectBaseWrap>(info[0]->ToObject());
		vtkGlyph3D * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObjectBase *) a0->native.GetPointer()
		);
		VtkGlyph3DWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkGlyph3DWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkGlyph3DWrap *w = new VtkGlyph3DWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::ScalingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ScalingOff();
}

void VtkGlyph3DWrap::ScalingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->ScalingOn();
}

void VtkGlyph3DWrap::SetClamping(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetClamping(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetColorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetColorMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetColorModeToColorByScalar(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToColorByScalar();
}

void VtkGlyph3DWrap::SetColorModeToColorByScale(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToColorByScale();
}

void VtkGlyph3DWrap::SetColorModeToColorByVector(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetColorModeToColorByVector();
}

void VtkGlyph3DWrap::SetFillCellData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFillCellData(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetGeneratePointIds(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGeneratePointIds(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetIndexMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIndexMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetIndexModeToOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetIndexModeToOff();
}

void VtkGlyph3DWrap::SetIndexModeToScalar(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetIndexModeToScalar();
}

void VtkGlyph3DWrap::SetIndexModeToVector(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetIndexModeToVector();
}

void VtkGlyph3DWrap::SetOrient(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOrient(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetOutputPointsPrecision(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputPointsPrecision(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetPointIdsName(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsString())
	{
		Nan::Utf8String a0(info[0]);
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetPointIdsName(
			*a0
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetRange(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	size_t i;
	if(info.Length() > 0 && info[0]->IsFloat64Array())
	{
		v8::Local<v8::Float64Array>a0(v8::Local<v8::Float64Array>::Cast(info[0]->ToObject()));
		if( a0->Length() < 2 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetRange(
			(double *)(a0->Buffer()->GetContents().Data())
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsArray())
	{
		v8::Local<v8::Array>a0(v8::Local<v8::Array>::Cast(info[0]->ToObject()));
		double b0[2];
		if( a0->Length() < 2 )
		{
			Nan::ThrowError("Array too short.");
			return;
		}

		for( i = 0; i < 2; i++ )
		{
			if( !a0->Get(i)->IsNumber() )
			{
				Nan::ThrowError("Array contents invalid.");
				return;
			}
			b0[i] = a0->Get(i)->NumberValue();
		}
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetRange(
			b0
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsNumber())
	{
		if(info.Length() > 1 && info[1]->IsNumber())
		{
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetRange(
				info[0]->NumberValue(),
				info[1]->NumberValue()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetScaleFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScaleFactor(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetScaleMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScaleMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetScaleModeToDataScalingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScaleModeToDataScalingOff();
}

void VtkGlyph3DWrap::SetScaleModeToScaleByScalar(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScaleModeToScaleByScalar();
}

void VtkGlyph3DWrap::SetScaleModeToScaleByVector(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScaleModeToScaleByVector();
}

void VtkGlyph3DWrap::SetScaleModeToScaleByVectorComponents(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetScaleModeToScaleByVectorComponents();
}

void VtkGlyph3DWrap::SetScaling(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetScaling(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetSourceConnection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAlgorithmOutputWrap *a0 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceConnection(
			(vtkAlgorithmOutput *) a0->native.GetPointer()
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[1]))
		{
			VtkAlgorithmOutputWrap *a1 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[1]->ToObject());
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetSourceConnection(
				info[0]->Int32Value(),
				(vtkAlgorithmOutput *) a1->native.GetPointer()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetSourceData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPolyDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPolyDataWrap *a0 = ObjectWrap::Unwrap<VtkPolyDataWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceData(
			(vtkPolyData *) a0->native.GetPointer()
		);
		return;
	}
	else if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkPolyDataWrap::ptpl))->HasInstance(info[1]))
		{
			VtkPolyDataWrap *a1 = ObjectWrap::Unwrap<VtkPolyDataWrap>(info[1]->ToObject());
						if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			native->SetSourceData(
				info[0]->Int32Value(),
				(vtkPolyData *) a1->native.GetPointer()
			);
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetSourceTransform(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkTransformWrap::ptpl))->HasInstance(info[0]))
	{
		VtkTransformWrap *a0 = ObjectWrap::Unwrap<VtkTransformWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceTransform(
			(vtkTransform *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetVectorMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetVectorMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkGlyph3DWrap::SetVectorModeToUseNormal(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetVectorModeToUseNormal();
}

void VtkGlyph3DWrap::SetVectorModeToUseVector(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetVectorModeToUseVector();
}

void VtkGlyph3DWrap::SetVectorModeToVectorRotationOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkGlyph3DWrap *wrapper = ObjectWrap::Unwrap<VtkGlyph3DWrap>(info.Holder());
	vtkGlyph3D *native = (vtkGlyph3D *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->SetVectorModeToVectorRotationOff();
}

