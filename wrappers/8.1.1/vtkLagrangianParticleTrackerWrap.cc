/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include "vtkDataObjectAlgorithmWrap.h"
#include "vtkLagrangianParticleTrackerWrap.h"
#include "vtkObjectBaseWrap.h"
#include "vtkLagrangianBasicIntegrationModelWrap.h"
#include "vtkInitialValueProblemSolverWrap.h"
#include "vtkDataObjectWrap.h"
#include "vtkAlgorithmOutputWrap.h"
#include "vtkInformationWrap.h"
#include "../../plus/plus.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkLagrangianParticleTrackerWrap::ptpl;

VtkLagrangianParticleTrackerWrap::VtkLagrangianParticleTrackerWrap()
{ }

VtkLagrangianParticleTrackerWrap::VtkLagrangianParticleTrackerWrap(vtkSmartPointer<vtkLagrangianParticleTracker> _native)
{ native = _native; }

VtkLagrangianParticleTrackerWrap::~VtkLagrangianParticleTrackerWrap()
{ }

void VtkLagrangianParticleTrackerWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkLagrangianParticleTracker").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("LagrangianParticleTracker").ToLocalChecked(), ConstructorGetter);
}

void VtkLagrangianParticleTrackerWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkLagrangianParticleTrackerWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkDataObjectAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkDataObjectAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkLagrangianParticleTrackerWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "AdaptiveStepReintegrationOff", AdaptiveStepReintegrationOff);
	Nan::SetPrototypeMethod(tpl, "adaptiveStepReintegrationOff", AdaptiveStepReintegrationOff);

	Nan::SetPrototypeMethod(tpl, "AdaptiveStepReintegrationOn", AdaptiveStepReintegrationOn);
	Nan::SetPrototypeMethod(tpl, "adaptiveStepReintegrationOn", AdaptiveStepReintegrationOn);

	Nan::SetPrototypeMethod(tpl, "CreateOutOfDomainParticleOff", CreateOutOfDomainParticleOff);
	Nan::SetPrototypeMethod(tpl, "createOutOfDomainParticleOff", CreateOutOfDomainParticleOff);

	Nan::SetPrototypeMethod(tpl, "CreateOutOfDomainParticleOn", CreateOutOfDomainParticleOn);
	Nan::SetPrototypeMethod(tpl, "createOutOfDomainParticleOn", CreateOutOfDomainParticleOn);

	Nan::SetPrototypeMethod(tpl, "FillInputPortInformation", FillInputPortInformation);
	Nan::SetPrototypeMethod(tpl, "fillInputPortInformation", FillInputPortInformation);

	Nan::SetPrototypeMethod(tpl, "FillOutputPortInformation", FillOutputPortInformation);
	Nan::SetPrototypeMethod(tpl, "fillOutputPortInformation", FillOutputPortInformation);

	Nan::SetPrototypeMethod(tpl, "GetAdaptiveStepReintegration", GetAdaptiveStepReintegration);
	Nan::SetPrototypeMethod(tpl, "getAdaptiveStepReintegration", GetAdaptiveStepReintegration);

	Nan::SetPrototypeMethod(tpl, "GetCellLengthComputationMode", GetCellLengthComputationMode);
	Nan::SetPrototypeMethod(tpl, "getCellLengthComputationMode", GetCellLengthComputationMode);

	Nan::SetPrototypeMethod(tpl, "GetCreateOutOfDomainParticle", GetCreateOutOfDomainParticle);
	Nan::SetPrototypeMethod(tpl, "getCreateOutOfDomainParticle", GetCreateOutOfDomainParticle);

	Nan::SetPrototypeMethod(tpl, "GetIntegrationModel", GetIntegrationModel);
	Nan::SetPrototypeMethod(tpl, "getIntegrationModel", GetIntegrationModel);

	Nan::SetPrototypeMethod(tpl, "GetIntegrator", GetIntegrator);
	Nan::SetPrototypeMethod(tpl, "getIntegrator", GetIntegrator);

	Nan::SetPrototypeMethod(tpl, "GetMaximumNumberOfSteps", GetMaximumNumberOfSteps);
	Nan::SetPrototypeMethod(tpl, "getMaximumNumberOfSteps", GetMaximumNumberOfSteps);

	Nan::SetPrototypeMethod(tpl, "GetParticlePathsRenderingPointsThreshold", GetParticlePathsRenderingPointsThreshold);
	Nan::SetPrototypeMethod(tpl, "getParticlePathsRenderingPointsThreshold", GetParticlePathsRenderingPointsThreshold);

	Nan::SetPrototypeMethod(tpl, "GetSource", GetSource);
	Nan::SetPrototypeMethod(tpl, "getSource", GetSource);

	Nan::SetPrototypeMethod(tpl, "GetStepFactor", GetStepFactor);
	Nan::SetPrototypeMethod(tpl, "getStepFactor", GetStepFactor);

	Nan::SetPrototypeMethod(tpl, "GetStepFactorMax", GetStepFactorMax);
	Nan::SetPrototypeMethod(tpl, "getStepFactorMax", GetStepFactorMax);

	Nan::SetPrototypeMethod(tpl, "GetStepFactorMin", GetStepFactorMin);
	Nan::SetPrototypeMethod(tpl, "getStepFactorMin", GetStepFactorMin);

	Nan::SetPrototypeMethod(tpl, "GetSurface", GetSurface);
	Nan::SetPrototypeMethod(tpl, "getSurface", GetSurface);

	Nan::SetPrototypeMethod(tpl, "GetUseParticlePathsRenderingThreshold", GetUseParticlePathsRenderingThreshold);
	Nan::SetPrototypeMethod(tpl, "getUseParticlePathsRenderingThreshold", GetUseParticlePathsRenderingThreshold);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetAdaptiveStepReintegration", SetAdaptiveStepReintegration);
	Nan::SetPrototypeMethod(tpl, "setAdaptiveStepReintegration", SetAdaptiveStepReintegration);

	Nan::SetPrototypeMethod(tpl, "SetCellLengthComputationMode", SetCellLengthComputationMode);
	Nan::SetPrototypeMethod(tpl, "setCellLengthComputationMode", SetCellLengthComputationMode);

	Nan::SetPrototypeMethod(tpl, "SetCreateOutOfDomainParticle", SetCreateOutOfDomainParticle);
	Nan::SetPrototypeMethod(tpl, "setCreateOutOfDomainParticle", SetCreateOutOfDomainParticle);

	Nan::SetPrototypeMethod(tpl, "SetIntegrationModel", SetIntegrationModel);
	Nan::SetPrototypeMethod(tpl, "setIntegrationModel", SetIntegrationModel);

	Nan::SetPrototypeMethod(tpl, "SetIntegrator", SetIntegrator);
	Nan::SetPrototypeMethod(tpl, "setIntegrator", SetIntegrator);

	Nan::SetPrototypeMethod(tpl, "SetMaximumNumberOfSteps", SetMaximumNumberOfSteps);
	Nan::SetPrototypeMethod(tpl, "setMaximumNumberOfSteps", SetMaximumNumberOfSteps);

	Nan::SetPrototypeMethod(tpl, "SetParticlePathsRenderingPointsThreshold", SetParticlePathsRenderingPointsThreshold);
	Nan::SetPrototypeMethod(tpl, "setParticlePathsRenderingPointsThreshold", SetParticlePathsRenderingPointsThreshold);

	Nan::SetPrototypeMethod(tpl, "SetSourceConnection", SetSourceConnection);
	Nan::SetPrototypeMethod(tpl, "setSourceConnection", SetSourceConnection);

	Nan::SetPrototypeMethod(tpl, "SetSourceData", SetSourceData);
	Nan::SetPrototypeMethod(tpl, "setSourceData", SetSourceData);

	Nan::SetPrototypeMethod(tpl, "SetStepFactor", SetStepFactor);
	Nan::SetPrototypeMethod(tpl, "setStepFactor", SetStepFactor);

	Nan::SetPrototypeMethod(tpl, "SetStepFactorMax", SetStepFactorMax);
	Nan::SetPrototypeMethod(tpl, "setStepFactorMax", SetStepFactorMax);

	Nan::SetPrototypeMethod(tpl, "SetStepFactorMin", SetStepFactorMin);
	Nan::SetPrototypeMethod(tpl, "setStepFactorMin", SetStepFactorMin);

	Nan::SetPrototypeMethod(tpl, "SetSurfaceConnection", SetSurfaceConnection);
	Nan::SetPrototypeMethod(tpl, "setSurfaceConnection", SetSurfaceConnection);

	Nan::SetPrototypeMethod(tpl, "SetSurfaceData", SetSurfaceData);
	Nan::SetPrototypeMethod(tpl, "setSurfaceData", SetSurfaceData);

	Nan::SetPrototypeMethod(tpl, "SetUseParticlePathsRenderingThreshold", SetUseParticlePathsRenderingThreshold);
	Nan::SetPrototypeMethod(tpl, "setUseParticlePathsRenderingThreshold", SetUseParticlePathsRenderingThreshold);

	Nan::SetPrototypeMethod(tpl, "UseParticlePathsRenderingThresholdOff", UseParticlePathsRenderingThresholdOff);
	Nan::SetPrototypeMethod(tpl, "useParticlePathsRenderingThresholdOff", UseParticlePathsRenderingThresholdOff);

	Nan::SetPrototypeMethod(tpl, "UseParticlePathsRenderingThresholdOn", UseParticlePathsRenderingThresholdOn);
	Nan::SetPrototypeMethod(tpl, "useParticlePathsRenderingThresholdOn", UseParticlePathsRenderingThresholdOn);

#ifdef VTK_NODE_PLUS_VTKLAGRANGIANPARTICLETRACKERWRAP_INITPTPL
	VTK_NODE_PLUS_VTKLAGRANGIANPARTICLETRACKERWRAP_INITPTPL
#endif
	ptpl.Reset( tpl );
}

void VtkLagrangianParticleTrackerWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkLagrangianParticleTracker> native = vtkSmartPointer<vtkLagrangianParticleTracker>::New();
		VtkLagrangianParticleTrackerWrap* obj = new VtkLagrangianParticleTrackerWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkLagrangianParticleTrackerWrap::AdaptiveStepReintegrationOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AdaptiveStepReintegrationOff();
}

void VtkLagrangianParticleTrackerWrap::AdaptiveStepReintegrationOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->AdaptiveStepReintegrationOn();
}

void VtkLagrangianParticleTrackerWrap::CreateOutOfDomainParticleOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CreateOutOfDomainParticleOff();
}

void VtkLagrangianParticleTrackerWrap::CreateOutOfDomainParticleOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->CreateOutOfDomainParticleOn();
}

void VtkLagrangianParticleTrackerWrap::FillInputPortInformation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkInformationWrap::ptpl))->HasInstance(info[1]))
		{
			VtkInformationWrap *a1 = ObjectWrap::Unwrap<VtkInformationWrap>(info[1]->ToObject());
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->FillInputPortInformation(
				info[0]->Int32Value(),
				(vtkInformation *) a1->native.GetPointer()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::FillOutputPortInformation(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
		if(info.Length() > 1 && info[1]->IsObject() && (Nan::New(VtkInformationWrap::ptpl))->HasInstance(info[1]))
		{
			VtkInformationWrap *a1 = ObjectWrap::Unwrap<VtkInformationWrap>(info[1]->ToObject());
			int r;
			if(info.Length() != 2)
			{
				Nan::ThrowError("Too many parameters.");
				return;
			}
			r = native->FillOutputPortInformation(
				info[0]->Int32Value(),
				(vtkInformation *) a1->native.GetPointer()
			);
			info.GetReturnValue().Set(Nan::New(r));
			return;
		}
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::GetAdaptiveStepReintegration(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetAdaptiveStepReintegration();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::GetCellLengthComputationMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCellLengthComputationMode();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::GetCreateOutOfDomainParticle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetCreateOutOfDomainParticle();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::GetIntegrationModel(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	vtkLagrangianBasicIntegrationModel * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIntegrationModel();
	VtkLagrangianBasicIntegrationModelWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkLagrangianBasicIntegrationModelWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkLagrangianBasicIntegrationModelWrap *w = new VtkLagrangianBasicIntegrationModelWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkLagrangianParticleTrackerWrap::GetIntegrator(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	vtkInitialValueProblemSolver * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetIntegrator();
	VtkInitialValueProblemSolverWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkInitialValueProblemSolverWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkInitialValueProblemSolverWrap *w = new VtkInitialValueProblemSolverWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkLagrangianParticleTrackerWrap::GetMaximumNumberOfSteps(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetMaximumNumberOfSteps();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::GetParticlePathsRenderingPointsThreshold(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetParticlePathsRenderingPointsThreshold();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::GetSource(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	vtkDataObject * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSource();
	VtkDataObjectWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataObjectWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataObjectWrap *w = new VtkDataObjectWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkLagrangianParticleTrackerWrap::GetStepFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStepFactor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::GetStepFactorMax(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStepFactorMax();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::GetStepFactorMin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetStepFactorMin();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::GetSurface(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	vtkDataObject * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSurface();
	VtkDataObjectWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkDataObjectWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkDataObjectWrap *w = new VtkDataObjectWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkLagrangianParticleTrackerWrap::GetUseParticlePathsRenderingThreshold(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	bool r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetUseParticlePathsRenderingThreshold();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkLagrangianParticleTrackerWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	vtkLagrangianParticleTracker * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	VtkLagrangianParticleTrackerWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkLagrangianParticleTrackerWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkLagrangianParticleTrackerWrap *w = new VtkLagrangianParticleTrackerWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkLagrangianParticleTrackerWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectBaseWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectBaseWrap *a0 = ObjectWrap::Unwrap<VtkObjectBaseWrap>(info[0]->ToObject());
		vtkLagrangianParticleTracker * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObjectBase *) a0->native.GetPointer()
		);
		VtkLagrangianParticleTrackerWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkLagrangianParticleTrackerWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkLagrangianParticleTrackerWrap *w = new VtkLagrangianParticleTrackerWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetAdaptiveStepReintegration(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetAdaptiveStepReintegration(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetCellLengthComputationMode(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetCellLengthComputationMode(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetCreateOutOfDomainParticle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetCreateOutOfDomainParticle(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetIntegrationModel(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkLagrangianBasicIntegrationModelWrap::ptpl))->HasInstance(info[0]))
	{
		VtkLagrangianBasicIntegrationModelWrap *a0 = ObjectWrap::Unwrap<VtkLagrangianBasicIntegrationModelWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIntegrationModel(
			(vtkLagrangianBasicIntegrationModel *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetIntegrator(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkInitialValueProblemSolverWrap::ptpl))->HasInstance(info[0]))
	{
		VtkInitialValueProblemSolverWrap *a0 = ObjectWrap::Unwrap<VtkInitialValueProblemSolverWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetIntegrator(
			(vtkInitialValueProblemSolver *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetMaximumNumberOfSteps(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetMaximumNumberOfSteps(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetParticlePathsRenderingPointsThreshold(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetParticlePathsRenderingPointsThreshold(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetSourceConnection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAlgorithmOutputWrap *a0 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceConnection(
			(vtkAlgorithmOutput *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetSourceData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataObjectWrap *a0 = ObjectWrap::Unwrap<VtkDataObjectWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceData(
			(vtkDataObject *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetStepFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStepFactor(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetStepFactorMax(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStepFactorMax(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetStepFactorMin(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetStepFactorMin(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetSurfaceConnection(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkAlgorithmOutputWrap::ptpl))->HasInstance(info[0]))
	{
		VtkAlgorithmOutputWrap *a0 = ObjectWrap::Unwrap<VtkAlgorithmOutputWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSurfaceConnection(
			(vtkAlgorithmOutput *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetSurfaceData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkDataObjectWrap::ptpl))->HasInstance(info[0]))
	{
		VtkDataObjectWrap *a0 = ObjectWrap::Unwrap<VtkDataObjectWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSurfaceData(
			(vtkDataObject *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::SetUseParticlePathsRenderingThreshold(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsBoolean())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetUseParticlePathsRenderingThreshold(
			info[0]->BooleanValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkLagrangianParticleTrackerWrap::UseParticlePathsRenderingThresholdOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseParticlePathsRenderingThresholdOff();
}

void VtkLagrangianParticleTrackerWrap::UseParticlePathsRenderingThresholdOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkLagrangianParticleTrackerWrap *wrapper = ObjectWrap::Unwrap<VtkLagrangianParticleTrackerWrap>(info.Holder());
	vtkLagrangianParticleTracker *native = (vtkLagrangianParticleTracker *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->UseParticlePathsRenderingThresholdOn();
}

