/* this file has been autogenerated by vtkNodeJsWrap */
/* editing this might proof futile */

#define VTK_WRAPPING_CXX
#define VTK_STREAMS_FWD_ONLY
#include <nan.h>

#include "vtkPolyDataAlgorithmWrap.h"
#include "vtkSmoothPolyDataFilterWrap.h"
#include "vtkObjectBaseWrap.h"
#include "vtkPolyDataWrap.h"
#include "../../plus/plus.h"

using namespace v8;

extern Nan::Persistent<v8::Object> vtkNodeJsNoWrap;
Nan::Persistent<v8::FunctionTemplate> VtkSmoothPolyDataFilterWrap::ptpl;

VtkSmoothPolyDataFilterWrap::VtkSmoothPolyDataFilterWrap()
{ }

VtkSmoothPolyDataFilterWrap::VtkSmoothPolyDataFilterWrap(vtkSmartPointer<vtkSmoothPolyDataFilter> _native)
{ native = _native; }

VtkSmoothPolyDataFilterWrap::~VtkSmoothPolyDataFilterWrap()
{ }

void VtkSmoothPolyDataFilterWrap::Init(v8::Local<v8::Object> exports)
{
	Nan::SetAccessor(exports, Nan::New("vtkSmoothPolyDataFilter").ToLocalChecked(), ConstructorGetter);
	Nan::SetAccessor(exports, Nan::New("SmoothPolyDataFilter").ToLocalChecked(), ConstructorGetter);
}

void VtkSmoothPolyDataFilterWrap::ConstructorGetter(
	v8::Local<v8::String> property,
	const Nan::PropertyCallbackInfo<v8::Value>& info)
{
	InitPtpl();
	info.GetReturnValue().Set(Nan::New(ptpl)->GetFunction());
}

void VtkSmoothPolyDataFilterWrap::InitPtpl()
{
	if (!ptpl.IsEmpty()) return;
	v8::Local<v8::FunctionTemplate> tpl = Nan::New<v8::FunctionTemplate>(New);
	VtkPolyDataAlgorithmWrap::InitPtpl( );
	tpl->Inherit(Nan::New<FunctionTemplate>(VtkPolyDataAlgorithmWrap::ptpl));
	tpl->SetClassName(Nan::New("VtkSmoothPolyDataFilterWrap").ToLocalChecked());
	tpl->InstanceTemplate()->SetInternalFieldCount(1);

	Nan::SetPrototypeMethod(tpl, "BoundarySmoothingOff", BoundarySmoothingOff);
	Nan::SetPrototypeMethod(tpl, "boundarySmoothingOff", BoundarySmoothingOff);

	Nan::SetPrototypeMethod(tpl, "BoundarySmoothingOn", BoundarySmoothingOn);
	Nan::SetPrototypeMethod(tpl, "boundarySmoothingOn", BoundarySmoothingOn);

	Nan::SetPrototypeMethod(tpl, "FeatureEdgeSmoothingOff", FeatureEdgeSmoothingOff);
	Nan::SetPrototypeMethod(tpl, "featureEdgeSmoothingOff", FeatureEdgeSmoothingOff);

	Nan::SetPrototypeMethod(tpl, "FeatureEdgeSmoothingOn", FeatureEdgeSmoothingOn);
	Nan::SetPrototypeMethod(tpl, "featureEdgeSmoothingOn", FeatureEdgeSmoothingOn);

	Nan::SetPrototypeMethod(tpl, "GenerateErrorScalarsOff", GenerateErrorScalarsOff);
	Nan::SetPrototypeMethod(tpl, "generateErrorScalarsOff", GenerateErrorScalarsOff);

	Nan::SetPrototypeMethod(tpl, "GenerateErrorScalarsOn", GenerateErrorScalarsOn);
	Nan::SetPrototypeMethod(tpl, "generateErrorScalarsOn", GenerateErrorScalarsOn);

	Nan::SetPrototypeMethod(tpl, "GenerateErrorVectorsOff", GenerateErrorVectorsOff);
	Nan::SetPrototypeMethod(tpl, "generateErrorVectorsOff", GenerateErrorVectorsOff);

	Nan::SetPrototypeMethod(tpl, "GenerateErrorVectorsOn", GenerateErrorVectorsOn);
	Nan::SetPrototypeMethod(tpl, "generateErrorVectorsOn", GenerateErrorVectorsOn);

	Nan::SetPrototypeMethod(tpl, "GetBoundarySmoothing", GetBoundarySmoothing);
	Nan::SetPrototypeMethod(tpl, "getBoundarySmoothing", GetBoundarySmoothing);

	Nan::SetPrototypeMethod(tpl, "GetConvergence", GetConvergence);
	Nan::SetPrototypeMethod(tpl, "getConvergence", GetConvergence);

	Nan::SetPrototypeMethod(tpl, "GetConvergenceMaxValue", GetConvergenceMaxValue);
	Nan::SetPrototypeMethod(tpl, "getConvergenceMaxValue", GetConvergenceMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetConvergenceMinValue", GetConvergenceMinValue);
	Nan::SetPrototypeMethod(tpl, "getConvergenceMinValue", GetConvergenceMinValue);

	Nan::SetPrototypeMethod(tpl, "GetEdgeAngle", GetEdgeAngle);
	Nan::SetPrototypeMethod(tpl, "getEdgeAngle", GetEdgeAngle);

	Nan::SetPrototypeMethod(tpl, "GetEdgeAngleMaxValue", GetEdgeAngleMaxValue);
	Nan::SetPrototypeMethod(tpl, "getEdgeAngleMaxValue", GetEdgeAngleMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetEdgeAngleMinValue", GetEdgeAngleMinValue);
	Nan::SetPrototypeMethod(tpl, "getEdgeAngleMinValue", GetEdgeAngleMinValue);

	Nan::SetPrototypeMethod(tpl, "GetFeatureAngle", GetFeatureAngle);
	Nan::SetPrototypeMethod(tpl, "getFeatureAngle", GetFeatureAngle);

	Nan::SetPrototypeMethod(tpl, "GetFeatureAngleMaxValue", GetFeatureAngleMaxValue);
	Nan::SetPrototypeMethod(tpl, "getFeatureAngleMaxValue", GetFeatureAngleMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetFeatureAngleMinValue", GetFeatureAngleMinValue);
	Nan::SetPrototypeMethod(tpl, "getFeatureAngleMinValue", GetFeatureAngleMinValue);

	Nan::SetPrototypeMethod(tpl, "GetFeatureEdgeSmoothing", GetFeatureEdgeSmoothing);
	Nan::SetPrototypeMethod(tpl, "getFeatureEdgeSmoothing", GetFeatureEdgeSmoothing);

	Nan::SetPrototypeMethod(tpl, "GetGenerateErrorScalars", GetGenerateErrorScalars);
	Nan::SetPrototypeMethod(tpl, "getGenerateErrorScalars", GetGenerateErrorScalars);

	Nan::SetPrototypeMethod(tpl, "GetGenerateErrorVectors", GetGenerateErrorVectors);
	Nan::SetPrototypeMethod(tpl, "getGenerateErrorVectors", GetGenerateErrorVectors);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfIterations", GetNumberOfIterations);
	Nan::SetPrototypeMethod(tpl, "getNumberOfIterations", GetNumberOfIterations);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfIterationsMaxValue", GetNumberOfIterationsMaxValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfIterationsMaxValue", GetNumberOfIterationsMaxValue);

	Nan::SetPrototypeMethod(tpl, "GetNumberOfIterationsMinValue", GetNumberOfIterationsMinValue);
	Nan::SetPrototypeMethod(tpl, "getNumberOfIterationsMinValue", GetNumberOfIterationsMinValue);

	Nan::SetPrototypeMethod(tpl, "GetOutputPointsPrecision", GetOutputPointsPrecision);
	Nan::SetPrototypeMethod(tpl, "getOutputPointsPrecision", GetOutputPointsPrecision);

	Nan::SetPrototypeMethod(tpl, "GetRelaxationFactor", GetRelaxationFactor);
	Nan::SetPrototypeMethod(tpl, "getRelaxationFactor", GetRelaxationFactor);

	Nan::SetPrototypeMethod(tpl, "GetSource", GetSource);
	Nan::SetPrototypeMethod(tpl, "getSource", GetSource);

	Nan::SetPrototypeMethod(tpl, "NewInstance", NewInstance);
	Nan::SetPrototypeMethod(tpl, "newInstance", NewInstance);

	Nan::SetPrototypeMethod(tpl, "SafeDownCast", SafeDownCast);
	Nan::SetPrototypeMethod(tpl, "safeDownCast", SafeDownCast);

	Nan::SetPrototypeMethod(tpl, "SetBoundarySmoothing", SetBoundarySmoothing);
	Nan::SetPrototypeMethod(tpl, "setBoundarySmoothing", SetBoundarySmoothing);

	Nan::SetPrototypeMethod(tpl, "SetConvergence", SetConvergence);
	Nan::SetPrototypeMethod(tpl, "setConvergence", SetConvergence);

	Nan::SetPrototypeMethod(tpl, "SetEdgeAngle", SetEdgeAngle);
	Nan::SetPrototypeMethod(tpl, "setEdgeAngle", SetEdgeAngle);

	Nan::SetPrototypeMethod(tpl, "SetFeatureAngle", SetFeatureAngle);
	Nan::SetPrototypeMethod(tpl, "setFeatureAngle", SetFeatureAngle);

	Nan::SetPrototypeMethod(tpl, "SetFeatureEdgeSmoothing", SetFeatureEdgeSmoothing);
	Nan::SetPrototypeMethod(tpl, "setFeatureEdgeSmoothing", SetFeatureEdgeSmoothing);

	Nan::SetPrototypeMethod(tpl, "SetGenerateErrorScalars", SetGenerateErrorScalars);
	Nan::SetPrototypeMethod(tpl, "setGenerateErrorScalars", SetGenerateErrorScalars);

	Nan::SetPrototypeMethod(tpl, "SetGenerateErrorVectors", SetGenerateErrorVectors);
	Nan::SetPrototypeMethod(tpl, "setGenerateErrorVectors", SetGenerateErrorVectors);

	Nan::SetPrototypeMethod(tpl, "SetNumberOfIterations", SetNumberOfIterations);
	Nan::SetPrototypeMethod(tpl, "setNumberOfIterations", SetNumberOfIterations);

	Nan::SetPrototypeMethod(tpl, "SetOutputPointsPrecision", SetOutputPointsPrecision);
	Nan::SetPrototypeMethod(tpl, "setOutputPointsPrecision", SetOutputPointsPrecision);

	Nan::SetPrototypeMethod(tpl, "SetRelaxationFactor", SetRelaxationFactor);
	Nan::SetPrototypeMethod(tpl, "setRelaxationFactor", SetRelaxationFactor);

	Nan::SetPrototypeMethod(tpl, "SetSourceData", SetSourceData);
	Nan::SetPrototypeMethod(tpl, "setSourceData", SetSourceData);

#ifdef VTK_NODE_PLUS_VTKSMOOTHPOLYDATAFILTERWRAP_INITPTPL
	VTK_NODE_PLUS_VTKSMOOTHPOLYDATAFILTERWRAP_INITPTPL
#endif
	ptpl.Reset( tpl );
}

void VtkSmoothPolyDataFilterWrap::New(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	if(!info.IsConstructCall())
	{
		Nan::ThrowError("Constructor not called in a construct call.");
		return;
	}

	if(info.Length() == 0)
	{
		vtkSmartPointer<vtkSmoothPolyDataFilter> native = vtkSmartPointer<vtkSmoothPolyDataFilter>::New();
		VtkSmoothPolyDataFilterWrap* obj = new VtkSmoothPolyDataFilterWrap(native);
		obj->Wrap(info.This());
	}
	else
	{
		if(info[0]->ToObject() != vtkNodeJsNoWrap )
		{
			Nan::ThrowError("Parameter Error");
			return;
		}
	}

	info.GetReturnValue().Set(info.This());
}

void VtkSmoothPolyDataFilterWrap::BoundarySmoothingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BoundarySmoothingOff();
}

void VtkSmoothPolyDataFilterWrap::BoundarySmoothingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->BoundarySmoothingOn();
}

void VtkSmoothPolyDataFilterWrap::FeatureEdgeSmoothingOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FeatureEdgeSmoothingOff();
}

void VtkSmoothPolyDataFilterWrap::FeatureEdgeSmoothingOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->FeatureEdgeSmoothingOn();
}

void VtkSmoothPolyDataFilterWrap::GenerateErrorScalarsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateErrorScalarsOff();
}

void VtkSmoothPolyDataFilterWrap::GenerateErrorScalarsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateErrorScalarsOn();
}

void VtkSmoothPolyDataFilterWrap::GenerateErrorVectorsOff(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateErrorVectorsOff();
}

void VtkSmoothPolyDataFilterWrap::GenerateErrorVectorsOn(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
		if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	native->GenerateErrorVectorsOn();
}

void VtkSmoothPolyDataFilterWrap::GetBoundarySmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetBoundarySmoothing();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetConvergence(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetConvergence();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetConvergenceMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetConvergenceMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetConvergenceMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetConvergenceMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetEdgeAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeAngle();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetEdgeAngleMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeAngleMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetEdgeAngleMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetEdgeAngleMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetFeatureAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFeatureAngle();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetFeatureAngleMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFeatureAngleMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetFeatureAngleMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFeatureAngleMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetFeatureEdgeSmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetFeatureEdgeSmoothing();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetGenerateErrorScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateErrorScalars();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetGenerateErrorVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetGenerateErrorVectors();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetNumberOfIterations(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfIterations();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetNumberOfIterationsMaxValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfIterationsMaxValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetNumberOfIterationsMinValue(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetNumberOfIterationsMinValue();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetOutputPointsPrecision(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	int r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetOutputPointsPrecision();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetRelaxationFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	double r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetRelaxationFactor();
	info.GetReturnValue().Set(Nan::New(r));
}

void VtkSmoothPolyDataFilterWrap::GetSource(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	vtkPolyData * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->GetSource();
	VtkPolyDataWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkPolyDataWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkPolyDataWrap *w = new VtkPolyDataWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkSmoothPolyDataFilterWrap::NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	vtkSmoothPolyDataFilter * r;
	if(info.Length() != 0)
	{
		Nan::ThrowError("Too many parameters.");
		return;
	}
	r = native->NewInstance();
	VtkSmoothPolyDataFilterWrap::InitPtpl();
	v8::Local<v8::Value> argv[1] =
		{ Nan::New(vtkNodeJsNoWrap) };
	v8::Local<v8::Function> cons =
		Nan::New<v8::FunctionTemplate>(VtkSmoothPolyDataFilterWrap::ptpl)->GetFunction();
	v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
	VtkSmoothPolyDataFilterWrap *w = new VtkSmoothPolyDataFilterWrap();
	w->native = r;
	w->Wrap(wo);
	info.GetReturnValue().Set(wo);
}

void VtkSmoothPolyDataFilterWrap::SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkObjectBaseWrap::ptpl))->HasInstance(info[0]))
	{
		VtkObjectBaseWrap *a0 = ObjectWrap::Unwrap<VtkObjectBaseWrap>(info[0]->ToObject());
		vtkSmoothPolyDataFilter * r;
		if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		r = native->SafeDownCast(
			(vtkObjectBase *) a0->native.GetPointer()
		);
		VtkSmoothPolyDataFilterWrap::InitPtpl();
		v8::Local<v8::Value> argv[1] =
			{ Nan::New(vtkNodeJsNoWrap) };
		v8::Local<v8::Function> cons =
			Nan::New<v8::FunctionTemplate>(VtkSmoothPolyDataFilterWrap::ptpl)->GetFunction();
		v8::Local<v8::Object> wo = cons->NewInstance(1, argv);
		VtkSmoothPolyDataFilterWrap *w = new VtkSmoothPolyDataFilterWrap();
		w->native = r;
		w->Wrap(wo);
		info.GetReturnValue().Set(wo);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetBoundarySmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetBoundarySmoothing(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetConvergence(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetConvergence(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetEdgeAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetEdgeAngle(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetFeatureAngle(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFeatureAngle(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetFeatureEdgeSmoothing(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetFeatureEdgeSmoothing(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetGenerateErrorScalars(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateErrorScalars(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetGenerateErrorVectors(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetGenerateErrorVectors(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetNumberOfIterations(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetNumberOfIterations(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetOutputPointsPrecision(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsInt32())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetOutputPointsPrecision(
			info[0]->Int32Value()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetRelaxationFactor(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsNumber())
	{
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetRelaxationFactor(
			info[0]->NumberValue()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

void VtkSmoothPolyDataFilterWrap::SetSourceData(const Nan::FunctionCallbackInfo<v8::Value>& info)
{
	VtkSmoothPolyDataFilterWrap *wrapper = ObjectWrap::Unwrap<VtkSmoothPolyDataFilterWrap>(info.Holder());
	vtkSmoothPolyDataFilter *native = (vtkSmoothPolyDataFilter *)wrapper->native.GetPointer();
	if(info.Length() > 0 && info[0]->IsObject() && (Nan::New(VtkPolyDataWrap::ptpl))->HasInstance(info[0]))
	{
		VtkPolyDataWrap *a0 = ObjectWrap::Unwrap<VtkPolyDataWrap>(info[0]->ToObject());
				if(info.Length() != 1)
		{
			Nan::ThrowError("Too many parameters.");
			return;
		}
		native->SetSourceData(
			(vtkPolyData *) a0->native.GetPointer()
		);
		return;
	}
	Nan::ThrowError("Parameter mismatch");
}

